<appendix id="instructionsappendix">
<title>Common x86 Instructions</title>

<sect1>
<title>Reading the Tables</title>

<para>
The tables of instructions presented in this appendix include:
</para>

<itemizedlist>
<listitem><para>The instruction code</para></listitem>
<listitem><para>The operands used</para></listitem>
<listitem><para>The flags used</para></listitem>
<listitem><para>A brief description of what the instruction does</para></listitem>
</itemizedlist>

<para>
In the operands section, it will list the type of operands it takes.  If
it takes more than one operand, each operand will be separated by a comma.
Each operand will have a list of codes which tell whether the operand can
be an immediate-mode value (I), a register (R), or a memory address (M).
For example, the <literal>movl</literal> instruction is listed as
<literal>I/R/M, R/M</literal>.  This means that the first operand can
be any kind of value, while the second operand must be a register or memory
location.  In addition, Intel assembly language <emphasis>never</emphasis>
allows more than one operand to be a memory location.
</para>

<para>
In the flags section, it lists the flags affected by the instruction. 
The following flags are mentioned:
</para>

<variablelist>

<varlistentry>
<term>O</term>
<listitem><para>
Overflow flag.  This is set to true if the destination operand was not large enough to hold the result of the instruction.
</para></listitem>
</varlistentry>
<varlistentry>
<term>S</term>
<listitem><para>
Sign flag.  This is used for signed arithmetic operations.  These operations will set the sign flag to the sign of the last result.
</para></listitem>
</varlistentry>

<varlistentry>
<term>Z</term>
<listitem><para>
Zero flag.  This flag is set to true if the result of the instructionn is zero.
</para></listitem>
</varlistentry>


<varlistentry>
<term>A</term>
<listitem><para>
Auxillary carry flag.
</para></listitem>
</varlistentry>


<varlistentry>
<term>P</term>
<listitem><para>
Parity flag.  This flag is set to true if the low byte of the last result had an even number of 1 bits.
</para></listitem>
</varlistentry>


<varlistentry>
<term>C</term>
<listitem><para>
Carry flag.  Used in addition to say whether or not the result would have carried over to an additional byte.
</para></listitem>
</varlistentry>

</variablelist>

<para>
Other flags exist, but they are much less important.
</para>

</sect1>

<sect1>
<title>Data Transfer Instructions</title>

<para>
These instructions perform little, if any computation.  Instead they are mostly used for moving data from one place to another.
</para>

<table>
<title>Data Transfer Instructions</title>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colname="instruction" />
<colspec colname="operands" />
<colspec colname="flags" />
<thead>
<row>
<entry>Instruction</entry><entry>Operands</entry><entry>Affected Flags</entry></row>
</thead>
<tbody>
<row><entry>movl</entry><entry>I/R/M, I/R/M</entry><entry>??</entry></row>
<row><entry namest="instruction" nameend="flags">
This copies a word of data from one location to another.  <literal>movl %eax, %ebx</literal> copies the contents of &eax; to &ebx;
</entry></row>
<row><entry>movb</entry><entry>I/R/M, I/R/M</entry><entry>??</entry></row>
<row><entry namest="instruction" nameend="flags">
Same as <literal>movl</literal>, but operates on individual bytes.
</entry></row>
<row><entry>leal</entry><entry>M, I/R/M</entry><entry>??</entry></row>
<row><entry namest="instruction" nameend="flags">
This takes a memory location given in the standard format, and, instead of
loading the contents of the memory location, loads the computed address.
For example, <literal>leal 5(%ebp,%ecx,1), %eax</literal> loads the address
computed by <literal>5 + %ebp + 1*%ecx</literal> and stores that in &eax;
</entry></row>
<row><entry>xchgl</entry><entry>R/M, R/M</entry><entry></entry></row>
<row><entry namest="instruction" nameend="flags">
Exchange the given registers or register w/ memory location.
</entry></row>
</tbody>
</tgroup>
</table>

</sect1>

<sect1>
<title>Integer Instructions</title>

<para>
These are basic calculating instructions that operate on signed or unsigned
integers.
</para>

<table>
<title>Integer Instructions</title>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colname="instruction" />
<colspec colname="operands" />
<colspec colname="flags" />
<thead>
<row>
<entry>Instruction</entry><entry>Operands</entry><entry>Affected Flags</entry></row>
</thead>
<tbody>
<row><entry>adcl</entry><entry>I/R/M, R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Add with carry.  Adds the first argument to the second, and, if there is an overflow, sets all listed flags to true.
</entry></row>
<row><entry>addl</entry><entry>I/R/M, R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Signed integer addition.
</entry></row>
<row><entry>cmpl</entry><entry>I/R/M, R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Compares two integers.
</entry></row>
<row><entry>decl</entry><entry>R/M</entry><entry>O/S/Z/A/P</entry></row>
<row><entry namest="instruction" nameend="flags">
Decrements the register or memory location.  Use <literal>decb</literal>
to decrement a byte instead.
</entry></row>
<row><entry>divl</entry><entry>R/M</entry><entry>O/S/Z/A/P</entry></row>
<row><entry namest="instruction" nameend="flags">
Performs unsigned division.
</entry></row>
<row><entry>idivl</entry><entry>R/M</entry><entry>O/S/Z/A/P</entry></row>
<row><entry namest="instruction" nameend="flags">
Performs signed division.
</entry></row>
<row><entry>imull</entry><entry>R, M/I</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Performs signed multiplication.
</entry></row>
<row><entry>incl</entry><entry>R/M</entry><entry>O/S/Z/A/P</entry></row>
<row><entry namest="instruction" nameend="flags">
Increments the given register or memory location.
</entry></row>
<row><entry>mull</entry><entry>R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Perform unsigned multiplication.
</entry></row>
<row><entry>negl</entry><entry>R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Negate the given register or memory location.
</entry></row>
<row><entry>sbbl</entry><entry>I/R/M, R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Performs subtraction with borrowing.
</entry></row>
<row><entry>subl</entry><entry>I/R/M, R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Perform subtraction.
</entry></row>
</tbody>
</tgroup>
</table>

</sect1>

<sect1>
<title>Logic Instructions</title>

<para>
These instructions operate on memory as bits instead of words.
</para>

<table>
<title>Logic Instructions</title>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colname="instruction" />
<colspec colname="operands" />
<colspec colname="flags" />
<thead>
<row>
<entry>Instruction</entry><entry>Operands</entry><entry>Affected Flags</entry></row>
</thead>
<tbody>
<row><entry>andl</entry><entry>I/R/M, R/M</entry><entry>O/S/Z/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
And's the contents of the two operands together, and stores the result in the second operand.  Sets the overflow and carry flags to false.
</entry></row>
<row><entry>notl</entry><entry>R/M</entry><entry></entry></row>
<row><entry namest="instruction" nameend="flags">
Performs a logical not on each bit in the operand.  Also known as a 
one's complement.
</entry></row>
<row><entry>orl</entry><entry>I/R/M, R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Performs a logical or between the two operands, and stores the result in the second operand.  Sets the overflow and carry flags to zero.
</entry></row>
<row><entry>rcll</entry><entry>R/M, I/&cl;</entry><entry>O/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Rotates the given location left the number of times in the second operand, which is either an immediate-mode value or the register &cl;.  Sets the overflow
and carry flags.
</entry></row>
<row><entry>rcrl</entry><entry>R/M, I/&cl;</entry><entry>O/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Same as above, but rotates right.
</entry></row>
<row><entry>roll</entry><entry>R/M, I/&cl;</entry><entry>O/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Rotate left.
</entry></row>
<row><entry>rorl</entry><entry>R/M, I/&cl;</entry><entry>O/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Rotate right.
</entry></row>
<row><entry>sall</entry><entry>R/M, I/&cl;</entry><entry>C</entry></row>
<row><entry namest="instruction" nameend="flags">
Arithmetic shift left.
</entry></row>
<row><entry>sarl</entry><entry>R/M, I/&cl;</entry><entry>C</entry></row>
<row><entry namest="instruction" nameend="flags">
Arithmetic shift right.
</entry></row>
<row><entry>shll</entry><entry>R/M, I/&cl;</entry><entry>C</entry></row>
<row><entry namest="instruction" nameend="flags">
Logical shift left.
</entry></row>
<row><entry>shrl</entry><entry>R/M, I/&cl;</entry><entry>C</entry></row>
<row><entry namest="instruction" nameend="flags">
Logical shift right.
</entry></row>
<row><entry>xorl</entry><entry>I/R/M, R/M</entry><entry>O/S/Z/A/P/C</entry></row>
<row><entry namest="instruction" nameend="flags">
Does an exclusive or on the two operands, and stores the result in the second operand.  Sets the overflow and carry flags to false.
</entry></row>
</tbody>
</tgroup>
</table>

</sect1>

<sect1>
<title>Flow Control Instructions</title>

<para>
These instructions may alter the flow of the program.
</para>

<table>
<title>Flow Control Instructions</title>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colname="instruction" />
<colspec colname="operands" />
<colspec colname="flags" />
<thead>
<row>
<entry>Instruction</entry><entry>Operands</entry><entry>Affected Flags</entry></row>
</thead>
<tbody>
<row><entry></entry></row>
</tbody>
</tgroup>
</table>
<para>
</para>

</sect1>

<!--
<sect1>
<title>Floating-Point Instructions</title>

<table>
<title>Floating-Point Instructions</title>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colname="instruction" />
<colspec colname="operands" />
<colspec colname="flags" />
<thead>
<row>
<entry>Instruction</entry><entry>Operands</entry><entry>Affected Flags</entry></row>
</thead>
<tbody>
</tbody>
</tgroup>
</table>
<para>
</para>

</sect1>
-->


<sect1>
<title>Assembler Directives</title>

<para>
These are instructions to the assembler and linker, instead of instructions
to the processor.  These are used to help the assembler put your code together
properly, and make it easier to use.  <literal>.globl</literal> and
<literal>.type</literal> are both used by the linker to help it know which
symbols need to be used by other programs, and what they do.
</para>

<table>
<title>Assembler Directives</title>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colname="instruction" />
<colspec colname="operands" />
<colspec colname="flags" />
<thead>
<row>
<entry>Directive</entry><entry>Operands</entry><entry></entry></row>
</thead>
<tbody>
<row><entry>.ascii</entry><entry>QUOTED STRING</entry></row>
<row><entry namest="instruction" nameend="flags">
Takes the given quoted string and converts it into byte data.
</entry></row>
<row><entry>.byte</entry><entry>VALUES</entry></row>
<row><entry namest="instruction" nameend="flags">
Takes a comma-separated list of values and inserts them right there
in the program as data.
</entry></row>
<row><entry>.equ</entry><entry>LABEL, VALUE</entry></row>
<row><entry namest="instruction" nameend="flags">
Sets the given label equivalent to the given value.  The value
can be a number, a character, or an constant expression that evaluates
to a a number or character.  From that point on, use of the label will
be substituted for the given value.
</entry></row>
<row><entry>.globl</entry><entry>LABEL</entry></row>
<row><entry namest="instruction" nameend="flags">
Sets the given label as global, meaning that it can be used from 
separately-compiled object files.
</entry></row>
<row><entry>.include</entry><entry>FILE</entry></row>
<row><entry namest="instruction" nameend="flags">
Includes the given file just as if it were typed in right there.
</entry></row>
<row><entry>.long</entry><entry>VALUES</entry></row>
<row><entry namest="instruction" nameend="flags">
Takes a sequence of numbers separated by commas, and inserts those
numbers as 4-byte words right where they are in the program.
</entry></row>
<row><entry>.section</entry><entry>SECTION NAME</entry></row>
<row><entry namest="instruction" nameend="flags">
Switches the section that is being worked on.  Common sections include
<literal>.text</literal> (for code), <literal>.data</literal> (for 
data embedded in the program itself), and <literal>.bss</literal> (for
uninitialized global data).
</entry></row>
</tbody>
</tgroup>
</table>
<para>
</para>

</sect1>

<sect1>
<title>Differences in Other Syntaxes and Terminology</title>

<para>
The syntax for assembly language used in this book is known at the
<emphasis>AT&amp;T</emphasis> syntax.  It is the one supported by the 
GNU tool chain that comes standard with every Linux distribution.  However,
the official syntax for Intel assembly language is different.  It is
the same assembly language for the same platform, but it looks different.
Some of the differences include:
</para>

<itemizedlist>
<listitem><para>In Intel syntax, the operands of instructions are reversed.</para></listitem>
<listitem><para>In Intel syntax, registers are not prefixed with the percent sign (<literal>%</literal>).</para></listitem>
<listitem><para>In Intel syntax, a dollar-sign (<literal>$</literal>) is not required to do immediate-mode addressing.  Instead, non-immediate addressing is accomplished by surrounding the address with brackets (<literal>[]</literal>).</para></listitem>
<listitem><para></para></listitem>
<listitem><para>In Intel syntax, the instruction name does not include the size of data being moved.  If that is ambiguous, it is explicitly stated as <literal>BYTE</literal>, <literal>WORD</literal>, or <literal>DWORD</literal> immediately after the instruction name.</para></listitem>
<listitem><para>The way that memory addresses are represented in Intel assembly language is much different.</para></listitem>
<listitem><para>Because the x86 processor line originally started out as a 16-bit processor, most literature about x86 processors refer to words as 16-bit values, and call 32-bit values double words.  However, we use the term "word" to refer to 32-bit values since that is the standard register size on modern x86 processors.  This is true of the syntax as well - <literal>DWORD</literal> stands for "double word" and is used for standard-sized registers.</para></listitem>
<listitem><para>Intel assembly language has the ability to address memory as a segment/offset pair.  We do not mention this because Linux does not support segmented memory, and is therefore irrelevant to Linux programming.</para></listitem>
</itemizedlist>

<para>
Other differences exist, but they are small in comparison.  To show many
of the differences, consider the following instruction:
</para>

<programlisting>
movl %eax, 8(%ebx,1,%edi)
</programlisting>

<para>
In Intel syntax, this would be written as:
</para>

<programlisting>
mov  [8 + %ebx + 1 * edi], eax
</programlisting>

<para>
This makes a little more sense, as it spells out exactly how the address
will be computed, but the order of operands is confusing.
</para>

</sect1>
</appendix>
