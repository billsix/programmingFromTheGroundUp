<chapter>
<title>Dealing with Files</title>
<!--

Copyright 2002 Jonathan Bartlett

Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation; with no Invariant Sections, with no Front-Cover Texts,
and with no Back-Cover Texts.  A copy of the license is included in fdl.xml

-->

<para>
A lot of computer programming deals with files.  After all, when we reboot our
computers, the only thing that remains from previous sessions are what has
been put on disk.  Data which is stored in files is called 
<emphasis>persistent</emphasis> data, because it persists between sessions.
</para>

<sect1>
<title>The UNIX File Concept</title>

<para>
Each operating system has it's own way of dealing with files.  However, the
UNIX method, which is used on Linux, is the simplest and most universal.
UNIX files, no matter what program created them, can all be accessed as a 
stream of bytes.  When you access a file, you start by opening it by name.
The operating system then gives you a number, called a <emphasis>file
descriptor</emphasis>, which you use to refer to the file until you are
through with it.  You can then read and write to the file using its
file descriptor.  When you are done reading and writing, you then close 
the file, which then makes the file descriptor useless.
</para>

<para>
In our programs we will use the following system calls to deal with files:

<orderedlist>

<listitem><para>
Tell Linux the name of the file to open, and what you want to do with it (read, write, 
both read and write, create it if it doesn't exist, etc.).  This is handled with
the <literal>open</literal> system call, which takes a filename, a number representing your read/write intentions, and a permission set as its parameters.  
Having the number 5 in <literal>%eax</literal> when you signal the interrupt
will indicate the <literal>open</literal> system call to Linux.
The storage location of the first character of the filename should be stored
in <literal>%ebx</literal>.  The read/write intentions, represented as a number,
should be stored in <literal>%ecx</literal>.  For now, use 0 for files you want to read
from, and 03101 for files you want to write to.  This will be explained in more detail
in <xref linkend="truthbinarynumbers" />.  Finally, the permission set should
be stored as a number in <literal>%edx</literal>.  If you are unfamiliar
with UNIX permissions, just use <literal>0666</literal> for the permissions.
</para></listitem>

<listitem><para>
Linux will then return to you a <emphasis>file descriptor</emphasis> in 
<literal>%eax</literal>, which is a number that
you use to refer to this file throughout your program.
</para></listitem>

<listitem><para>
Next you will operate on the file doing reads and/or writes, each time 
giving Linux the file descriptor you want to use.  <literal>read</literal>
is system call 3, and to call it you need to have the file descriptor
in <literal>%ebx</literal>, the address of a buffer for storing the 
data that is read, and the size of the buffer.  Buffers will be explained 
below.  <literal>read</literal> will return with either the number of 
characters read from the file, or an error code.  Error codes can be
distinguished because they are always negative numbers.  
<literal>write</literal> is system call 4, and it requires the same 
parameters as the <literal>read</literal> system call, except that the
buffer should already be filled with the data to write out.  The 
<literal>write</literal> system call will give back the number
of bytes written in <literal>%eax</literal> or an error code.
</para></listitem>

<listitem><para>
When you are through with them, you then tell Linux to close your file.  
Afterwards, your file descriptor is no longer valid.
This is done using <literal>close</literal>, system call 6.  The only
parameter to <literal>close</literal> is the file descriptor, which is
placed in <literal>%ebx</literal>.
</para></listitem>

</orderedlist>

</para>

</sect1>

<sect1 id="buffersbss">
<title>Buffers and <literal>.bss</literal></title>

<para>
In the previous section we mentioned buffers without explaining what they
were.  A buffer is a continuous block of bytes used for bulk data transfer.
When you request to read a file, the operating system needs to have a place
to store the data it reads.  That place is called a buffer.   Usually, buffers
are only used temporarily, while the data is transformed to another form.
For example, let's say that you want to read in a single line of text from
a file.  However, you do not know how long that line is.  Therefore, you
will simply read a large number of bytes from the file into a buffer, look
for the end-of-line character, copy that to another location, and start looking
for the next line.  
</para>

<para>
Another thing to note is that buffers are a fixed size, set by the programmer.
So, if you want to read in data 500 bytes at a time, you send the 
<literal>read</literal> system call the address of a 500-byte unused location,
and send it the number 500 so it knows how big it is.  You can make it smaller
or bigger, depending on your application needs.  
</para>

<para>
To create a buffer, you need to either reserve static or dynamic storage.
Static storage is what we have talked about so far, storage locations
declared using <literal>.long</literal> or <literal>.byte</literal> directives.
Dynamic storage will be discussed in <xref linkend="dynamicmemory" />.  Now, there
are problems with declaring buffers using <literal>.byte</literal>.
First, it is tedious to type.  You would have to type 500 numbers after
the <literal>.byte</literal> declaration, and they wouldn't be used
for anything but to take up space.
Second, it uses up space in the executable.  In the examples we've
used so far, it doesn't use up too much, but that can change in larger 
programs.  In order to get around this
if you want 500 bytes you have to type in 500 numbers and it wastes 500
bytes in the executable.  There is a solution to both of these.  So far,
we have discussed two program sections, the <literal>.text</literal> and
the <literal>.data</literal> sections.  There is another section called
<literal>.bss</literal>.  This section is like the data section, except
that it doesn't take up space in the executable.  This section can
reserve storage, but it can't initialize it.  In the <literal>.data</literal>
section, you could reserve storage and set it to an initial value.  In the
<literal>.bss</literal> section, you can't set an initial value.  This is
useful for buffers because we don't need to initialize them anyway, we
just need to reserve storage.  In order to do this, we do the following
commands:

<programlisting>
.section .bss
	.lcomm my_buffer, 500
</programlisting>

This will create a symbol, <literal>my_buffer</literal>, that refers to 
a 500-byte storage location that we can use as a buffer.  We can then do
the following, assuming we have opened a file for reading and have placed
the file descriptor in &ebx;:

<programlisting>
	movl $my_buffer, %ecx
	movl 500, %edx
	movl 3, %eax
	int  $0x80
</programlisting>

which will read up to 500 bytes into our buffer.  In this example, I placed
a dollar sign in front of <literal>my_buffer</literal>.  The reason for this
is that without the dollar sign, <literal>my_buffer</literal> is treated
as a memory location.  Instead of moving the address of 
<literal>my_buffer</literal> into &ecx;, without the dollar sign it would
move the first word of the data contained there into &ecx;.  The dollar
sign makes the assembler treat <literal>my_buffer</literal> as a number,
so the address itself, rather than what is stored there, gets moved to 
&ecx;.
</para>

</sect1>

<sect1>
<title>Standard and Special Files</title>

<para>
You might think that programs start without any files open by default.  This
is not true.  Linux programs always have at least three open file descriptors 
when they begin.  They are:

<variablelist>

<varlistentry>
<term>STDIN</term>
<listitem><para>
This is the <emphasis>standard input</emphasis>.  It is a read-only file, and 
usually represents your keyboard.<footnote><para>In Linux, almost everything 
is a "file".  Your keyboard input is considered a file, and so is your 
screen display.
</para></footnote>
This is always file descriptory 0.
</para></listitem>
</varlistentry>

<varlistentry>
<term>STDOUT</term>
<listitem><para>
This is the <emphasis>standard output</emphasis>.  It is a write-only file, 
and usually represents your screen display.  This is always file descriptor 1.
</para></listitem>
</varlistentry>

<varlistentry>
<term>STDERR</term>
<listitem><para>
This is your <emphasis>standard error</emphasis>.  It is a write-only file, 
and usually represents your screen display.  Most regular processing 
output goes to <literal>STDOUT</literal>, but any error messages that come 
up in the process go to <literal>STDERR</literal>.  This way, if you want to, 
you can split them up into separate places.  This is always file
descriptor 2.
</para></listitem>
</varlistentry>
</variablelist>

Any of these "files" can be redirected from or to a real file, rather
than a screen or a keyboard.  This is outside the scope of this book, but
any good book on the UNIX command-line will describe it in detail.
</para>

<para>
Notice that many of the files you write to aren't files at all.  UNIX-based
operating systems treat all input/output systems as files.  Network connections
are treated as files, your serial port is treated like a file, your audio
devices are treated as files, even your hard drive can be read and written 
to like a file.  Communication between processes is usually done through
files called pipes.   Some of these files have different methods of opening
and creating them than regular files, but they can all be read from and
written to using the standard <literal>read</literal> and 
<literal>write</literal> system calls.
</para>

</sect1>

<sect1>
<title>Using Files in a Program</title>

<para>
We are going to write a simple program to illustrate these concepts.  The 
program will take two files, and read from one, convert all of its 
lower-case letters to upper-case, and write to the other file.  Before we
do so, let's think about what we need to do to get the job done:

<itemizedlist>
<listitem><para>
Have a function that takes a block of memory and converts it to upper-case.
This function would need an address of a block of memory and its size as
parameters.
</para></listitem>

<listitem><para>
Have a section of code that repeatedly reads in to a buffer, calls our
conversion function on the buffer, and then writes the buffer back out
to the other file.
</para></listitem>

<listitem><para>
Begin the program by opening the necessary files.
</para></listitem>
</itemizedlist>

Notice that I've specified things in reverse order that they will be done.  
That's a useful trick in writing complex programs - first decide the meat
of what is being done.  In this case, it's converting blocks of characters
to upper-case.  Then, you think about what all needs to happen to get that
done.  In this case, you have to open files, and continually read and write
blocks to disk.  One of the keys of programming is continually breaking
down problems into smaller and smaller chunks until it's small enough that
you can easily solve the problem.<footnote><para>Maureen Sprankle's
<citetitle>Problem Solving and Programming Concepts</citetitle> is an 
excellent book on the problem-solving process applied to computer programming.
</para></footnote>
<!-- FIXME - do I need to introduce flowcharting or reference it here? -->
</para>

<para>
You may have been thinking that you will never remember all of these numbers
being thrown at you - the system call numbers, the interrupt number, etc.
In this program we will also introduce a new directive, <literal>.equ</literal>
which should help out.  <literal>.equ</literal> allows you to assign names
to numbers.  For example, if you did 
<literal>.equ LINUX_SYSCALL, 0x80</literal>, any time after that you wrote
<literal>LINUX_SYSCALL</literal>, the assembler would substitue 
<literal>0x80</literal> for that.  So now, you can write 
<literal>int $LINUX_SYSCALL</literal>, which is much easier to read, and
much easier to remember.  Coding is complex, but there are a lot of things
we can do like this to make it easier.
</para>

<para>
Here is the program.  Note that we have more labels than we use for jumps,
but some of them are there for clarity and consistency.  Try to trace
through the program and see what happens in various cases.  An in-depth
explanation of the program will follow.
</para>

<programlisting>
&toupper-nomm-simplified-s;
</programlisting>

<para>
Type in this program as <filename>toupper.s</filename>, and then enter in 
the following commands:  

<programlisting>
as toupper.s -o toupper.o
ld toupper.o -o toupper
</programlisting>

This builds a program called <filename>toupper</filename>, which converts
all of the lowercase characters in a file to uppercase.
For example, to convert the file <filename>toupper.s</filename> to 
uppercase, type in the command

<programlisting>
./toupper toupper.s toupper.uppercase
</programlisting>

and you will find in the file <filename>toupper.uppercase</filename> an 
uppercase version of your original file.
</para>

<para>
Let's examine how the program works.
</para>

<para>
The first section of the program is marked <literal>CONSTANTS</literal>.  In
programming, a constant is a value that is assigned when a program assembles or
compiles, and is never changed.  I make a habit of placing all of my constants
together at the beginning of the program.  It's only necessary to declare them
before you use them, but putting them all at the beginning makes them easy to 
find.  Making them all upper-case makes it obvious in your program which 
values are constants and where to find them.<footnote><para>This is fairly
standard practice among all programmers.</para></footnote>
In assembly language, we 
declare constants with
the <literal>.equ</literal> directive as mentioned before.  Here, we simply
give names to all of the standard numbers we've used so far, like system call
numbers, the syscall interrupt number, and file open options.
</para>

<para>
The next section is marked <literal>BUFFERS</literal>.  We only use one buffer in
this program, which we call <literal>BUFFER_DATA</literal>.  We also define a 
constant, <literal>BUFFER_SIZE</literal>, which holds the size of the buffer.  If
we always refer to this constant rather than typing out the number 500 whenever
we need to use the size of the buffer, if it later changes, we only need to modify
this value, rather than having to go through the entire program and changing all
of the values individually.
</para>

<para>
Instead of going on the the <literal>_startup</literal> section of the program, go
to the end where we define the convert_to_upper function.  This is the part that
actually does the conversion.  Starting out, we have a set of constants we are 
using.  The reason these are put here rather than at the top is that they only
deal with this one function.  We have:

<programlisting>
	.equ  LOWERCASE_A, 'a'              #The lower boundary of our search
	.equ  LOWERCASE_Z, 'z'              #The upper boundary of our search
	.equ  UPPER_CONVERSION, 'A' - 'a'   #Conversion between upper and lower case
</programlisting>

The first two simply define the letters that are the boundaries of what we are
searching for.  Remember that in the computer, letters are represented as numbers.
Therefore, we can use <literal>LOWERCASE_A</literal> in comparisons, additions,
subtractions, or anything else we can use numbers in.  Also, notice we define
the constant <literal>UPPER_CONVERSION</literal>.  Since letters are represented
as numbers, we can subtract them.  Subtracting an upper-case letter from the
same lower-case letter gives us how much we need to add to a lower-case letter
to make it upper case.  If that doesn't make sense, look at the 
ASCII<footnote><para>ASCII is the numbering scheme which encodes letters 
and digits as numbers</para></footnote> code tables
in the appendix <!--XREF-->, and do the math yourself.
</para>

<para>
After this, we have some constants labelled <literal>STACK POSITIONS</literal>.
Remember that function parameters 
are pushed onto the stack before function calls.  These constants, prefixed with
<literal>ST</literal> for clarity, define where in the stack we should expect
to find each piece of data.  The return address is at position 4, the length of 
the buffer is at position 8, and the address of the buffer is at position 12.  
This way, when I use these stack addresses in the program, it's easier to see
what is happening.
</para>

<para>
Next comes the label 
<literal>convert_to_upper</literal>.  This is the entry point of
the function.  The first two lines are our standard function lines
to save the stack pointer.  The next two lines

<programlisting>
	movl  ST_BUFFER(%ebp), %eax
	movl  ST_BUFFER_LEN(%ebp), %ebx
</programlisting>

move the function parameters into the appropriate registers for use.
Then, we load zero into &edi;.  What we are going to do is iterate
through each byte of the buffer by loading from the location 
&eax; + &edi;, incrementing &edi;, and repeating until &edi;
is equal to the buffer length in &ebx;.  The lines 

<programlisting>
	cmpl  $0, %ebx
	je    end_convert_loop
</programlisting>

is just a sanity check to make sure that noone gave us a buffer of
zero size.  If they did, we just clean up and leave.  Guarding
against potential user and programming errors is an important
task of a programmer, and is what makes usable, reliable software.
</para>

<para>
Now we start our loop.  First,
it moves a byte into &cl;.  The code for this is

<programlisting>
	movb  (%eax,%edi,1), %cl
</programlisting>

This says to start at &eax; and go &edi; locations forward, with each
location being 1 byte big.  Take the value found there, and put it in
&cl;.  Then, it checks to see if that value is in the range
of lower-case <wordasword>a</wordasword> to lower-case <wordasword>z</wordasword>.
To check the range, it simply checks to see if the letter is smaller than 
<wordasword>a</wordasword>.  If it is, it can't be a lower-case letter.  Likewise,
if it is larger than <wordasword>z</wordasword>, it can't be a lower-case letter.
So, in each of these cases, it simply moves on.  If it is in the proper range, it
then adds the uppercase conversion, and stores it back.
</para>

<para>
Either way, it then goes to the next value by incrementing %cl;.  Next it checks to
see if we are at the end of the buffer.  If we are not at the end, we jump back to 
the beginning of the loop (the <literal>convert_loop</literal> label).  If we are
at the end, it simply carries on to the end of the function.  Because we are just
modifying the buffer, we don't need to return anything to the calling program - the
changes are already in the buffer.  The label <literal>end_convert_loop</literal>
is not needed, but it's there so it's easy to see where the parts of the program are.
</para>

<para>
Now we know how the conversion process works.  Now we need to figure out how
to get the data in and out of the files.
</para>

</sect1>

<sect1>
<title>Reading and Writing Simple Records</title>

<para>
Most applications deal with data that is <emphasis>persistent</emphasis> - 
meaning that the data lives longer than the program by being stored on disk 
inf files.  You can shut down the program and open it back up, and you are
back where you started.  Now, there are two basic kinds of persistent
data - structured and unstructured.  Unstructured data is like what we
dealt with in the previous program.  It just dealt with text files that
were entered by a person.  The contents of the files weren't usable by
a program because a program can't interpret what the user is trying to
say in random text.
</para>

<para>
Structured data, on the other hand, is what computers excel at handling.
This is data that is divided up into fields and records.  For the most
part, the fields and records are fixed-length.  Because the data is
divided into fixed-length records and fields, the computer can interpret
the data properly.  Structured data can contain variable-length fields,
but at that point you are usually better off with a database.
<footnote>
<para>
A database is a program which handles persistent structured data for you.
You don't have to write the programs to read and write the data to disk,
to do lookups, or even to do basic processing.  It is a very high-level
interface to structured data which, although it adds some overhead and
additional complexity, is very useful for complex data processing tasks.
</para>
</footnote>
</para>

<para>
This section deals with reading and writing simple fixed-length records.
Let's create the following example fixed-length record about people:
</para>

<itemizedlist>
<listitem><para>Firstname - 40 bytes</para></listitem>
<listitem><para>Lastname - 40 bytes</para></listitem>
<listitem><para>Address - 240 bytes</para></listitem>
<listitem><para>Age - 4 bytes</para></listitem>
</itemizedlist>

<para>
In this, everything is character data except for the age, which is
simply a numeric field, using a standard 4-byte word (we could just
use a single byte for this, but keeping it at a word makes it easier
to process).  We can set up constants to make this easier to process
like this:
</para>

<programlisting>
	.equ RECORD_FIRSTNAME, 0
	.equ RECORD_LASTNAME, 40
	.equ RECORD_ADDRESS, 80
	.equ RECORD_AGE, 320

	.equ RECORD_SIZE, 324
</programlisting>

<para>
We will write three programs using this structure and these definitions.  
The first program will build the file.
The second program will display the file.  The third program will add
1 year to the age of every record.
</para>

<para>
When writing programs, you often have to write certain functions that
will be used over and over again.  In this case, we will have to have
two functions that we will use: one which reads a record, and one which
writes a record.  So what data do we need for these functions?  We need
to know:
</para>

<itemizedlist>
<listitem><para>The location of a buffer that we can read a record into</para></listitem>
<listitem><para>The file descriptor that we want to read from or write to</para></listitem>
</itemizedlist>

<para>
Let's look at our reading function first:
</para>

<programlisting>
#PURPOSE:   This function reads a record from the file descriptor
#
#INPUT:     The file descriptor and a buffer
#
#OUTPUT:    This function writes the data to the buffer and returns
#           a status code.
#
#STACK LOCAL VARIABLES
	.equ ST_READ_BUFFER, 8
	.equ ST_FILEDES, 16
.section .text 
.globl read_record
.type, @function
read_record:
	pushl %ebp
	movl  %esp, %ebp

	pushl %ebx
	movl  ST_FILEDES(%ebp), %ebx
	movl  ST_READ_BUFFER(%ebp), %ecx
	movl  $RECORD_SIZE, %edx
	movl  $SYS_READ, %eax
	int   $LINUX_SYSCALL

	#NOTE - %eax has the return value, which we will
	#       give back to our calling program
	popl  %ebx

	movl  %ebp, %esp
	popl  %ebp
	ret
</programlisting>

<para>
It's a pretty simply function.  The writing one is similar:
</para>

<programlisting>
#PURPOSE:   This function writes a record to the file descriptor
#
#INPUT:     The file descriptor and a buffer
#
#OUTPUT:    This function produces a status code
#
#STACK LOCAL VARIABLES
	.equ ST_WRITE_BUFFER, 8
	.equ ST_FILEDES, 16
.section .text 
.globl write_record
.type, @function
write_record:
	pushl %ebp
	movl  %esp, %ebp

	pushl %ebx
	movl  ST_FILEDES(%ebp), %ebx
	movl  ST_WRITE_BUFFER(%ebp), %ecx
	movl  $RECORD_SIZE, %edx
	movl  $SYS_WRITE, %eax
	int   $LINUX_SYSCALL

	#NOTE - %eax has the return value, which we will
	#       give back to our calling program
	popl  %ebx

	movl  %ebp, %esp
	popl  %ebp
	ret
</programlisting>

<para>
Now we are ready to write our programs.
</para>

<sect2>
<title>Writing Records</title>

<para>
This program will simply write some hardcoded records to disk.
It will:
</para>

<itemizedlist>
<listitem><para>Open the file</para></listitem>
<listitem><para>Write three records</para></listitem>
<listitem><para>Close the file</para></listitem>
</itemizedlist>

<para>
Here is the code:
</para>

<programlisting>
&write-records;
</programlisting>

<para>
This is a fairly simple program.  It merely consists of defining
the data we want to write in the <literal>.data</literal> section,
and then calling the right system calls and function calls to
accomplish it.  For a discussion of all of the system calls used,
see <xref linkend="syscallap" />.
</para>

</sect2>

<sect2>
<title>Reading Records</title>

<para>
Now we will consider just the opposite - reading records.  In this 
program, we will read each record, and display the first name listed
with each record.
</para>

<para>
Since each person's name is a different length, we will need a function
to count the number of characters we want to write.  Since we pad each
field with null characters, we can simply count characters until we 
reach a null byte.<footnote><para>If you have used C, this is what
the <literal>strlen</literal> function does.</para></footnote>
Note that this means our records must contain at least
one null byte each.  That's okay, though, since we are controlling how the
records are written.
</para>

<para>
Here is the code:
</para>

<programlisting>
#PURPOSE:  Count the characters until a null byte is reached.
#
#INPUT:    The address of the character string
#
#OUTPUT:   Returns the count in %eax
#
#PROCESS:  
#  Registers used:
#    %ecx - character count
#    %al - current character
#    %edx - current character address

	.type count_chars, @function
	.globl count_chars

	.equ DATA_START_ADDRESS, -8
count_chars:
	pushl %ebp
	movl  %esp, %ebp
	
	#Counter starts at zero
	movl  $0, %ecx  

	#Starting address of data
	movl  DATA_START_ADDRESS(%ebp), %edx

count_loop_begin:
	#Grab the current character
	movb  (%edx), %al
	#Is it null?
	cmpb  $0, %al
	#If yes, we're done
	je    count_loop_end
	#Otherwise, increment the counter and the pointer
	incl  %ecx
	incl  %edx
	#Go back to the beginning of the loop
	jmpl  count_loop_begin

count_loop_end:
	#We're done.  Move the count into %eax
	#and return.
	movl  %ecx, %eax

	popl  %ebp
	ret
</programlisting>

<para>
As you can see, it's a fairly straightforward function.  The program
will be fairly straightforward, too.  It will do the following:
</para>

<itemizedlist>
<listitem><para>Open the file</para></listitem>
<listitem><para>Attempt to read a record</para></listitem>
<listitem><para>If we are at the end of the file, exit</para></listitem>
<listitem><para>Otherwise, count the characters of the first name</para></listitem>
<listitem><para>Write the first name to <literal>STDOUT</literal></para></listitem>
<listitem><para>Go back to read another record</para></listitem>
</itemizedlist>

<para>
Here is the code:
</para>

<programlisting>
&read-records;
</programlisting>

</sect1>

<sect1>
<title>Review</title>

<remark>Need a lot more review entries</remark>

<sect2>
<title>Know the Concepts</title>

<itemizedlist>
<listitem><para>Describe the lifecycle of a file descriptor.</para></listitem>
<listitem><para>What are the standard file descriptors and what are they used for?</para></listitem>
<listitem><para>What is a buffer?</para></listitem>
<listitem><para>What is the difference between the <literal>.data</literal> section and the <literal>.bss</literal> section?</para></listitem>
</itemizedlist>

</sect2>

<sect2>
<title>Use the Concepts</title>

<itemizedlist>
<listitem><para>Write a program that will create a file called <filename>heynow.txt</filename> and write the words "Hey diddle diddle!" into it.</para></listitem>
<listitem><para>Write a program </para></listitem>

</itemizedlist>

</sect2>

<sect2>
<title>Going Further</title>

<itemizedlist>
<listitem><para></para></listitem>
</itemizedlist>

</sect2>

</sect1>

</chapter>
