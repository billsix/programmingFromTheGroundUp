<chapter lang="zh_cn">
<title lang="zh_cn">介绍</title>
<!--

Copyright 2002 Jonathan Bartlett

Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation; with no Invariant Sections, with no Front-Cover Texts,
and with no Back-Cover Texts.  A copy of the license is included in fdl.xml

-->

<sect1>
<title>欢迎来到编程世界</title>

<para lang="zh_cn">
我爱
<indexterm><primary>编程</primary></indexterm>编程。我追求的往往不仅仅是解决问题本身，而且解决的方式要够酷。我很享受这样做带来的挑战。编程就像写诗。它传递着信息，不仅仅给电脑，还给那些修改和使用程序的人们。利用一个程序，你可以用你自己的规则组建你自己的世界，根据你对你的问题和解决方案的理解来创建你的世界。老道的程序员使用简单和紧凑的程序来创建世界，很像是诗和散文。
</para>
<para lang="zh_cn">
世界上最伟大的程序员之一，高德纳(Donald Knuth)说，编程不是告诉计算机怎样去做一件事情，而是告诉一个人他们是如何让计算机去做一件事情。他的观点是，程序是被人来读的，而不仅仅是计算机。当你离开一个项目而去做其它的项目很久以后，你的程序也许还将会被其他人修改和升级。因此，编程不仅仅是和计算机进行交流，而且还要和那些接你班的人进行交流。一个程序员，既是一个问题的解决者，也是一个诗人，还是一个讲师。你的目标是解决眼前的问题，考虑周全而风格独具，并且能让未来的程序员学会你的解决方案。我希望这本书至少可以教给读者一些让计算兴奋的诗和魔法。
</para> 

<para>
大多数关于编程书籍让我感到非常沮丧。看完这些书，你恐怕仍然会问：“计算机到底是怎样工作的？”，而且得不到一个完美的答案。这些书通常会略过那些有难度的但是很重要的话题。我将会让你了解这些有难度的问题，因为他们才是通向大师级编程的唯一道路。我的目标是让你从对编程一无所知到理解如何像一个程序员那样去思考、编写和学习。你不用记住每件事情的细枝末节，但是你将从头到尾的掌握所有的相关背景。在看完这本书后，你应该能够做到以下的事情：
</para>

<itemizedlist>
<listitem><para>理解一个程序是如何工作的，以及如何和其它程序交流</para></listitem>
<listitem><para>阅读其他人的程序和了解它们如何工作</para></listitem>
<listitem><para>迅速掌握新的编程语言</para></listitem>
<listitem><para>迅速掌握计算机科学中的高级概念</para></listitem>
</itemizedlist>

<para>
I will not teach you everything.  Computer science is a massive
field, especially when you combine the theory with the practice of computer
programming.  However, I will attempt to get you started on the 
foundations so you can easily go wherever you want afterwards.
</para>

<para>
There is somewhat of a chicken and egg problem in teaching programming,
especially assembly language.  There is a lot to learn - it is almost too
much to learn almost at all at once.  However, each piece depends on all 
the others, which makes learning it a piece at a time difficult.
Therefore, you must be patient with yourself and the computer while 
learning to program.  If you don't understand something the first time,
reread it.  If you still don't understand it, it is sometimes best to
take it by faith and come back to it later.  Often after more exposure
to programming the ideas will make more sense.  Don't get discouraged.
It's a long climb, but very worthwhile.
</para>

<para>
At the end of each chapter are three sets of review exercises.  The first
set is more or less regurgitation - they check to see if can you give 
back what you learned in the chapter.  The second set contains application 
questions - they check to see if you can apply what you learned to solve 
problems.  The final set is to see if you are capable of broadening your
horizons.  Some of these questions may not be answerable until later in
the book, but they give you some things to think about.  Other questions
require some research into outside sources to discover the answer.  Still
others require you to simply analyze your options and explain a best solution.
Many of the questions don't have right or wrong answers, but that doesn't mean
they are unimportant.  Learning the issues involved in programming, learning
how to research answers, and learning how to look ahead are all a major
part of a programmer's work. 
</para>

<para>
If you have problems that you just can't get past, there is a mailing list
for this book where readers can discuss and get help with what they are
reading.  The address is <literal>pgubook-readers@nongnu.org</literal>.
This mailing list is open for any type of question or discussion along the
lines of this book.  You can subscribe to this list by going to http://mail.nongnu.org/mailman/listinfo/pgubook-readers.
</para>

<para>
If you are thinking of using this book for a class on computer programming but
do not have access to Linux computers for your students, I highly suggest you
try to find help from the K-12 Linux Project.  Their website is at 
http://www.k12linux.org/ and they have a helpful and responsive mailing list
available.
</para>
</sect1>

<sect1>
<title>Your Tools</title>

<para>
This book teaches assembly language for x86 processors and the GNU/Linux
operating system.  Therefore we will be giving all of 
the examples using the GNU/Linux<indexterm><primary>GNU/Linux</primary></indexterm> standard GCC tool set. 
If you are not familiar with GNU/Linux and the GCC tool set, they will
be described shortly.  If you are new to Linux, you 
should check out the guide available at 
http://rute.sourceforge.net/<footnote><para>This is quite a large 
document.  You certainly don't need to know everything to get started 
with this book.  You simply need to know how to navigate from the command
line and how to use an editor like <literal>pico</literal>, 
<literal>emacs</literal>, or <literal>vi</literal> 
(or others).</para></footnote>
What I intend to show you is more about programming in general than using
a specific tool set on a specific platform, but standardizing on one 
makes the task much easier.
</para>

<para>
Those new to Linux should also try to get involved in their local GNU/Linux
User's Group.  User's Group members are usually very helpful for new people,
and will help you from everything from installing Linux to learning to
use it most efficiently.  A listing of GNU/Linux User's Groups is available
at http://www.linux.org/groups/
</para>

<para>
All of these
programs have been tested using <productname>Red Hat Linux 8.0</productname>, 
and should work with any other GNU/Linux distribution, too.<footnote><para>By 
"GNU/Linux distribution", I mean an x86 GNU/Linux distribution.  GNU/Linux 
distributions for the Power Macintosh, the Alpha processor, or other 
processors will not work with this book.</para></footnote>  They will
not work with non-Linux operating systems such as BSD or other systems.
However, all of the <emphasis>skills</emphasis> learned in this book 
should be easily transferable to any other system.  
</para>

<para>
If you do not have access to a GNU/Linux<indexterm><primary>GNU/Linux</primary></indexterm> machine, you can look for
a hosting provider who offers a Linux <emphasis>shell account</emphasis>, which
is a command-line only interface to a Linux machine.  
There are many low-cost
shell account providers, but you have to make sure that they match the 
requirements above (i.e. - Linux on x86).  
Someone at your local GNU/Linux User's Group may be able to give you one as 
well.  Shell accounts only require
that you already have an Internet connection and a telnet program.  If you use
<trademark class="registered">Windows</trademark>, you already have a telnet client - just click on 
<literal>start</literal>, then <literal>run</literal>, then type in 
<literal>telnet</literal>.  However, it is usually better to download
<productname>PuTTY</productname> from
http://www.chiart.greenend.co.uk/~sgtatham/putty/
because Windows' telnet has some weird problems.  There are a lot of options
for the Macintosh, too.  <productname>NiftyTelnet</productname> is my 
favorite.
</para>

<para>
If you don't have GNU/Linux<indexterm><primary>GNU/Linux</primary></indexterm>
and can't find a shell account service, then you
can download <productname>Knoppix</productname> from http://www.knoppix.org/
Knoppix<indexterm><primary>Knoppix</primary></indexterm> is a 
GNU/Linux distribution that boots from CD so that you don't have
to actually install it.  Once you are done using it, you just reboot and
remove the CD and you are back to your regular operating system.
</para>

<para>
So what is GNU/Linux?  GNU/Linux<indexterm><primary>GNU/Linux</primary></indexterm> is an operating system modeled after
<trademark class="registered">UNIX</trademark>.  The GNU part comes from the <ulink url="http://www.gnu.org/">GNU 
Project</ulink><footnote><para>The GNU Project is a project by the Free
Software Foundation to produce a complete, free operating 
system.</para></footnote>, which includes most of the programs you 
will run, including
the GCC<indexterm><primary>GCC</primary></indexterm> tool set that we 
will use to program with.  The GCC tool set
contains all of the programs necessary to create programs in various
computer languages.
</para>

<para>
Linux<indexterm><primary>Linux</primary></indexterm> is the name
of the <emphasis>kernel</emphasis>.  The kernel<indexterm><primary>kernel</primary></indexterm> is the core part of an
operating system that keeps track of everything.  The kernel is
both a fence and a gate.  As a gate, it allows programs
to access hardware in a uniform way.  Without the kernel, you would have
to write programs to deal with every device model ever made.  The kernel
handles all device-specific interactions so you don't have to.  It also handles
file access and interaction between processes.  
For example, when you
type, your typing goes through several programs before it hits your editor.
First, the kernel is what handles your hardware, so it is the first to receive
notice about the keypress.  The keyboard sends in 
<emphasis>scancodes</emphasis> to the kernel, which then converts them to the
actual letters, numbers, and symbols they represent.  If you are using a
windowing system (like <trademark class="registered">Microsoft Windows</trademark> or the X Window System), then the
windowing system reads the keypress from the kernel, and delivers it to
whatever program is currently in focus on the user's display.
</para>

<example>
<title>How the computer processes keyboard sigals</title>
<programlisting>
Keyboard -> Kernel -> Windowing system -> Application program
</programlisting>
</example>

<para>
The kernel<indexterm><primary>kernel</primary></indexterm> also controls the flow of information between programs.  
The kernel is a program's gate to the world around it.  Every time that
data moves between processes, the kernel controls the messaging.  In our
keyboard example above, the kernel would have to be involved for the
windowing system to communicate the keypress to the application program.
</para>

<para>
As a fence, the kernel
prevents programs from accidentally overwriting each other's data and from
accessing files and devices that they don't have permission to.  It
limits the amount of damage a poorly-written program can do to other 
running programs.
</para>

<para>
In our case, the kernel<indexterm><primary>kernel</primary></indexterm>
is Linux<indexterm><primary>Linux</primary></indexterm>.  Now, the kernel 
all by itself won't do anything.  You can't even
boot up a computer with just a kernel.  Think of the kernel as the water pipes
for a house.  Without the pipes, the faucets won't work, but the pipes are
pretty useless if there are no faucets.  Together, the user applications
(from the GNU project and other places) and the kernel (Linux) make 
up the entire operating system, GNU/Linux.
</para>

<para>
For the most part, this book will be using the computer's low-level
assembly language.  There are essentially three kinds of languages:

<indexterm><primary>machine language</primary></indexterm>
</para>

<variablelist>

<varlistentry>
<term>Machine Language</term>
<listitem><para>
This is what the computer actually sees and deals with.  Every
command the computer sees is given as a number or sequence of
numbers.  
</para></listitem>
</varlistentry>

<varlistentry>
<term>Assembly Language</term>
<listitem><para>
This is the same as machine language, except the command numbers
have been replaced by letter sequences which are easier to memorize.
Other small things are done to make it easier as well.
</para></listitem>
</varlistentry>

<varlistentry>
<term>High-Level Language<indexterm><primary>high-level languages</primary></indexterm></term>
<listitem><para>
High-level languages are there to make programming easier.  Assembly
language requires you to work with the machine itself.  High-level
languages allow you to describe the program in a more natural language.
A single command in a high-level language usually is equivalent to
several commands in an assembly language.  
</para></listitem>
</varlistentry>

</variablelist>

<para>
<indexterm><primary>Assembly Language</primary></indexterm>
In this book we will learn assembly language, although we will cover a
bit of high-level languages.  
Hopefully by learning assembly language, your understanding of how programming
and computers work will put you a step ahead.
</para>
<!--

-->
<!--
<para>
Assembly language has long fallen out of vogue in computer science education, and I believe
that this is causing the current generation of programmers to have a much
weaker foundation.   Assembly language was being viewed as an optional add-on 
that was only useful for operating-system programmers.  I wrote this book
to bring assembly language to the forefront of programmer education.  I believe this
is important, because while interviewing programmers for jobs, I have found
that the near-universal trait of qualified candidates was that they all knew
assembly language.  Few were experts and even fewer used it regularly, but
everyone who knew assembly language had a deeper understanding of programming
issues than the other candidates.
</para>

<para>
</para>

-->

</sect1>

</chapter>

