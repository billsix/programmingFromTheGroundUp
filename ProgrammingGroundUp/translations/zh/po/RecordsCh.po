# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2006-05-15 16:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING"

# type: Content of: <chapter><title>
#: ../../RecordsCh.xml:2
#, no-wrap
msgid "Reading and Writing Simple Records"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:5
msgid ""
"As mentioned in <xref linkend=\"filesch\" />, many applications deal with "
"data that is <emphasis>persistent<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../RecordsCh.xml:6
#, no-wrap
msgid "persistent"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:6
msgid ""
"</indexterm></emphasis> - meaning that the data lives longer than the "
"program by being stored on disk in files.  You can shut down the program and "
"open it back up, and you are back where you started.  Now, there are two "
"basic kinds of persistent data - structured and unstructured.  Unstructured "
"data<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../RecordsCh.xml:10
#, no-wrap
msgid "unstructured data"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:10
msgid ""
"</indexterm> is like what we dealt with in the <literal>toupper</literal> "
"program.  It just dealt with text files that were entered by a person.  The "
"contents of the files weren't usable by a program because a program can't "
"interpret what the user is trying to say in random text."
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:18
msgid "Structured data<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../RecordsCh.xml:18
#, no-wrap
msgid "structured data"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:18
msgid ""
"</indexterm>, on the other hand, is what computers excel at handling.  "
"Structured data is data that is divided up into fields<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../RecordsCh.xml:19
#, no-wrap
msgid "fields"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:19
msgid "</indexterm> and records<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../RecordsCh.xml:19 ../../RecordsCh.xml:37
#, no-wrap
msgid "records"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:19
msgid ""
"</indexterm>.  For the most part, the fields and records are fixed-length.  "
"Because the data is divided into fixed-length records and fixed-format "
"fields, the computer can interpret the data.  Structured data can contain "
"variable-length fields, but at that point you are usually better off with a "
"database<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../RecordsCh.xml:23
#, no-wrap
msgid "database"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:23
msgid "</indexterm>.  <footnote>"
msgstr ""

# type: Content of: <chapter><para><para>
#: ../../RecordsCh.xml:26
msgid ""
"A database is a program which handles persistent structured data for you.  "
"You don't have to write the programs to read and write the data to disk, to "
"do lookups, or even to do basic processing.  It is a very high-level "
"interface to structured data which, although it adds some overhead and "
"additional complexity, is very useful for complex data processing tasks.  "
"References for learning how databases work are listed in <xref "
"linkend=\"wherenextch\" />."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:33 ../../RecordsCh.xml:364
msgid "</footnote>"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:37
msgid ""
"This chapter deals with reading and writing simple fixed-length "
"records<indexterm>"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:37
msgid ""
"</indexterm>.  Let's say we wanted to store some basic information about "
"people we know.  We could imagine the following example fixed-length record "
"about people:"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:43
msgid "Firstname - 40 bytes"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:44
msgid "Lastname - 40 bytes"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:45
msgid "Address - 240 bytes"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:46
msgid "Age - 4 bytes"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:50
msgid ""
"In this, everything is character data except for the age, which is simply a "
"numeric field, using a standard 4-byte word (we could just use a single byte "
"for this, but keeping it at a word makes it easier to process)."
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:57
msgid ""
"In programming, you often have certain definitions that you will use over "
"and over again within the program, or perhaps within several programs.  It "
"is good to separate these out into files that are simply included into the "
"assembly language files as needed.  For example, in our next programs we "
"will need to access the different parts of the record above.  This means we "
"need to know the offsets<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../RecordsCh.xml:62
#, no-wrap
msgid "offsets"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:62
msgid ""
"</indexterm> of each field from the beginning of the record in order to "
"access them using base pointer addressing<indexterm>"
msgstr ""

# type: Content of: <chapter><para><primary>
#: ../../RecordsCh.xml:64
#, no-wrap
msgid "base pointer addressing mode"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:64
msgid ""
"</indexterm>.  The following constants describe the offsets to the above "
"structure.  Put them in a file named <filename>record-def.s</filename>:"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:75
msgid ""
"In addition, there are several constants that we have been defining over and "
"over in our programs, and it is useful to put them in a file, so that we "
"don't have to keep entering them.  Put the following constants<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:78 ../../RecordsCh.xml:183 ../../RecordsCh.xml:326 ../../RecordsCh.xml:336
#, no-wrap
msgid "constants"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:78
msgid "</indexterm> in a file called <filename>linux.s</filename>:"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:86
msgid ""
"We will write three programs in this chapter using the structure defined in "
"<filename>record-def.s</filename>.  The first program will build a file "
"containing several records as defined above. The second program will display "
"the records in the file.  The third program will add 1 year to the age of "
"every record."
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:94
msgid ""
"In addition to the standard constants we will be using throughout the "
"programs, there are also two functions that we will be using in several of "
"the programs - one which reads a record and one which writes a record."
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:101
msgid ""
"What parameters do these functions need in order to operate? We basically "
"need:"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:106
msgid "The location of a buffer that we can read a record into"
msgstr ""

# type: Content of: <chapter><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:107
msgid "The file descriptor that we want to read from or write to"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:111
msgid "Let's look at our reading function first:"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:119
msgid ""
"It's a pretty simple function.  It just reads data the size of our structure "
"into an appropriately sized buffer from the given file descriptor.  The "
"writing one is similar:"
msgstr ""

# type: Content of: <chapter><para>
#: ../../RecordsCh.xml:129
msgid ""
"Now that we have our basic definitions down, we are ready to write our "
"programs."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../RecordsCh.xml:134
#, no-wrap
msgid "Writing Records"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:137
msgid "This program will simply write some hardcoded records to disk.  It will:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:142 ../../RecordsCh.xml:265
msgid "Open the file"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:143
msgid "Write three records"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:144
msgid "Close the file"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:148
msgid ""
"Type the following code into a file called "
"<filename>write-records.s</filename>: <indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:149 ../../RecordsCh.xml:189
#, no-wrap
msgid ".rept"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:149 ../../RecordsCh.xml:150 ../../RecordsCh.xml:151
msgid "</indexterm> <indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:150 ../../RecordsCh.xml:190
#, no-wrap
msgid ".endr"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:151
#, no-wrap
msgid "padding"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:152
#, no-wrap
msgid "null"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:152
msgid "</indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:162
msgid ""
"This is a fairly simple program.  It merely consists of defining the data we "
"want to write in the <literal>.data<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:163 ../../RecordsCh.xml:193
#, no-wrap
msgid ".data"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:163
msgid ""
"</indexterm></literal> section, and then calling the right system calls and "
"function calls to accomplish it.  For a refresher of all of the system calls "
"used, see <xref linkend=\"syscallap\" />."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:170
msgid "You may have noticed the lines:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:179
msgid "<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:179
#, no-wrap
msgid ".include"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:179
msgid ""
"</indexterm> These statements cause the given files to basically be pasted "
"right there in the code.  You don't need to do this with functions, because "
"the linker<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:182 ../../RecordsCh.xml:209
#, no-wrap
msgid "linker"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:182
msgid ""
"</indexterm> can take care of combining functions exported with "
"<literal>.globl<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:183
#, no-wrap
msgid ".globl"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:183
msgid "</indexterm></literal>.  However, constants<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:183
msgid "</indexterm> defined in another file do need to be imported in this way."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:188
msgid ""
"Also, you may have noticed the use of a new assembler directive, "
"<literal>.rept<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:189
msgid ""
"</indexterm></literal>.  This directive repeats the contents of the file "
"between the <literal>.rept</literal> and the <literal>.endr<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:190
msgid ""
"</indexterm></literal> directives the number of times specified after "
"<literal>.rept</literal>.  This is usually used the way we used it - to "
"pad<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:192
#, no-wrap
msgid "pad"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:192
msgid "</indexterm> values in the <literal>.data<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:193
msgid ""
"</indexterm></literal> section.  In our case, we are adding null "
"characters<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:193 ../../RecordsCh.xml:238
#, no-wrap
msgid "null characters"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:193
msgid "</indexterm> to the end of each field until they are their defined lengths."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:198
msgid "To build the application, run the commands:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:208
msgid ""
"Here we are assembling two files separately, and then combining them "
"together using the linker<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:209
msgid "</indexterm>.  To run the program, just type the following:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:218
msgid ""
"This will cause a file called <filename>test.dat</filename> to be created "
"containing the records.  However, since they contain non-printable "
"characters (the null character, specifically), they may not be viewable by a "
"text editor.  Therefore we need the next program to read them for us."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../RecordsCh.xml:227
#, no-wrap
msgid "Reading Records"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:230
msgid ""
"Now we will consider the process of reading records.  In this program, we "
"will read each record and display the first name listed with each record."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:236
msgid ""
"Since each person's name is a different length, we will need a function to "
"count the number of characters we want to write.  Since we pad each field "
"with null characters<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:238
msgid ""
"</indexterm>, we can simply count characters until we reach a null "
"character.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../RecordsCh.xml:239
msgid "If you have used C, this is what the <literal>strlen<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><para><primary>
#: ../../RecordsCh.xml:240
#, no-wrap
msgid "strlen"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../RecordsCh.xml:240
msgid "</indexterm></literal> function does."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:240
msgid ""
"</footnote> Note that this means our records must contain at least one null "
"character each."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:246
msgid ""
"Here is the code.  Put it in a file called "
"<filename>count-chars.s</filename>:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:254
msgid ""
"As you can see, it's a fairly straightforward function.  It simply loops "
"through the bytes, counting as it goes, until it hits a null character.  "
"Then it returns the count."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:260
msgid ""
"Our record-reading program will be fairly straightforward, too.  It will do "
"the following:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:266
msgid "Attempt to read a record"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:267
msgid "If we are at the end of the file, exit"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:268
msgid "Otherwise, count the characters of the first name"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:269
msgid "Write the first name to <literal>STDOUT</literal>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:270
msgid "Write a newline to <literal>STDOUT</literal>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:271
msgid "Go back to read another record"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:275
msgid ""
"To write this, we need one more simple function - a function to write out a "
"newline to <literal>STDOUT</literal>.  Put the following code into "
"<filename>write-newline.s</filename>:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:285
msgid ""
"Now we are ready to write the main program.  Here is the code to "
"<filename>read-records.s</filename>:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:294
msgid ""
"To build this program, we need to assemble all of the parts and link them "
"together:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:308
msgid ""
"The backslash in the first line simply means that the command continues on "
"the next line.  You can run your program by doing "
"<literal>./read-records</literal>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:314
msgid ""
"As you can see, this program opens the file and then runs a loop of reading, "
"checking for the end of file, and writing the firstname.  The one construct "
"that might be new is the line that says:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:324
msgid ""
"It looks like we are combining and add instruction with a push instruction, "
"but we are not.  You see, both <literal>RECORD_FIRSTNAME</literal> and "
"<literal>record_buffer</literal> are constants<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:326
msgid ""
"</indexterm>.  The first is a direct constant, created through the use of a "
"<literal>.equ<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:327
#, no-wrap
msgid ".equ"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:327
msgid ""
"</indexterm></literal> directive, while the latter is defined automatically "
"by the assembler<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:328
#, no-wrap
msgid "assembler"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:328
msgid ""
"</indexterm> through its use as a label (it's value being the "
"address<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:329
#, no-wrap
msgid "address"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:329
msgid ""
"</indexterm> that the data that follows it will start at).  Since they are "
"both constants that the assembler knows, it is able to add them together "
"while it is assembling your program, so the whole instruction is a single "
"immediate-mode<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../RecordsCh.xml:332
#, no-wrap
msgid "immediate mode addressing"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:332
msgid "</indexterm> push of a single constant."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:336
msgid "The <literal>RECORD_FIRSTNAME</literal> constant<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:336
msgid ""
"</indexterm> is the number of bytes after the beginning of a record before "
"we hit the first name.  <literal>record_buffer</literal> is the name of our "
"buffer for holding records.  Adding them together gets us the address of the "
"first name member of the record stored in <literal>record_buffer</literal>."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../RecordsCh.xml:346
#, no-wrap
msgid "Modifying the Records"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:349
msgid "In this section, we will write a program that:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:353
msgid "Opens an input and output file"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:354
msgid "Reads records from the input"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:355
msgid "Increments the age"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:356
msgid "Writes the new record to the output file"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:360
msgid ""
"Like most programs we've encountered recently, this program is pretty "
"straightforward.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../RecordsCh.xml:361
msgid ""
"You will find that after learning the mechanics of programming, most "
"programs are pretty straightforward once you know exactly what it is you "
"want to do.  Most of them initialize data, do some processing in a loop, and "
"then clean everything up."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:372
msgid ""
"You can type it in as <filename>add-year.s</filename>.  To build it, type "
"the following<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../RecordsCh.xml:373
msgid ""
"This assumes that you have already built the object files "
"<filename>read-record.o</filename> and <filename>write-record.o</filename> "
"in the previous examples.  If not, you will have to do so."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:376 ../../RecordsCh.xml:389
msgid "</footnote>:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:385
msgid "To run the program, just type in the following<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../RecordsCh.xml:386
msgid ""
"This is assuming you created the file in a previous run of "
"<literal>write-records</literal>.  If not, you need to run "
"<literal>write-records</literal> first before running this program."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:397
msgid ""
"This will add a year to every record listed in <filename>test.dat</filename> "
"and write the new records to the file <filename>testout.dat</filename>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../RecordsCh.xml:402
msgid ""
"As you can see, writing fixed-length records is pretty simple.  You only "
"have to read in blocks of data to a buffer, process them, and write them "
"back out.  Unfortunately, this program doesn't write the new ages out to the "
"screen so you can verify your program's effectiveness.  This is because we "
"won't get to displaying numbers until <xref linkend=\"linking\" /> and <xref "
"linkend=\"countingchapter\" />.  After reading those you may want to come "
"back and rewrite this program to display the numeric data that we are "
"modifying."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../RecordsCh.xml:415
#, no-wrap
msgid "Review"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../RecordsCh.xml:418
#, no-wrap
msgid "Know the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:421
msgid "What is a record?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:422
msgid "What is the advantage of fixed-length records over variable-length records?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:423
msgid "How do you include constants in multiple assembly source files?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:424
msgid "Why might you want to split up a project into multiple source files?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:425
msgid ""
"What does the instruction <literal>incl record_buffer + RECORD_AGE</literal> "
"do? What addressing mode is it using? How many operands does the "
"<literal>incl</literal> instructions have in this case? Which parts are "
"being handled by the assembler and which parts are being handled when the "
"program is run?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../RecordsCh.xml:431
#, no-wrap
msgid "Use the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:434
msgid ""
"Add another data member to the person structure defined in this chapter, and "
"rewrite the reading and writing functions and programs to take them into "
"account.  Remember to reassemble and relink your files before running your "
"programs."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:435
msgid "Create a program that uses a loop to write 30 identical records to a file."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:436
msgid ""
"Create a program to find the largest age in the file and return that age as "
"the status code of the program."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:437
msgid ""
"Create a program to find the smallest age in the file and return that age as "
"the status code of the program."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../RecordsCh.xml:443
#, no-wrap
msgid "Going Further"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:446
msgid ""
"Rewrite the programs in this chapter to use command-line arguments to "
"specify the filesnames."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:447
msgid ""
"Research the <literal>lseek</literal> system call.  Rewrite the "
"<literal>add-year</literal> program to open the source file for both reading "
"and writing (use $2 for the read/write mode), and write the modified records "
"back to the same file they were read from."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:448
msgid ""
"Research the various error codes that can be returned by the system calls "
"made in these programs.  Pick one to rewrite, and add code that checks "
"&eax-indexed; for error conditions, and, if one is found, writes a message "
"about it to <literal>STDERR</literal> and exit."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:449
msgid ""
"Write a program that will add a single record to the file by reading the "
"data from the keyboard.  Remember, you will have to make sure that the data "
"has at least one null character at the end, and you need to have a way for "
"the user to indicate they are done typing.  Because we have not gotten into "
"characters to numbers conversion, you will not be able to read the age in "
"from the keyboard, so you'll have to have a default age."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../RecordsCh.xml:450
msgid ""
"Write a function called <literal>compare-strings</literal> that will compare "
"two strings up to 5 characters.  Then write a program that allows the user "
"to enter 5 characters, and have the program return all records whose first "
"name starts with those 5 characters."
msgstr ""
