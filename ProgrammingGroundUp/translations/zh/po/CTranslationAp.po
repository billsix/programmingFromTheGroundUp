# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
msgid ""
msgstr ""
"Project-Id-Version: pgubook\n"
"POT-Creation-Date: 2006-05-15 16:01+0800\n"
"PO-Revision-Date: 2006-07-30 01:09+0800\n"
"Last-Translator: Zhang Le <robert.zhangle@gmail.com>\n"
"Language-Team: zh_CN <robert.zhangle@gmail.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Pootle 0.10beta3\n"

# type: Content of: <appendix><title>
#: ../../CTranslationAp.xml:2
#, no-wrap
msgid "C Idioms in Assembly Language"
msgstr "以汇编语言翻译C语句"

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:17 ../../CTranslationAp.xml:130
msgid "<indexterm>"
msgstr ""

# type: Content of: <appendix><para><primary>
#: ../../CTranslationAp.xml:17
#, no-wrap
msgid "C programming language"
msgstr "C语言"

# type: Content of: <appendix><para>
#: ../../CTranslationAp.xml:17
msgid ""
"</indexterm> This appendix is for C programmers learning assembly language.  "
"It is meant to give a general idea about how C constructs can be implemented "
"in assembly language."
msgstr ""

# type: Content of: <appendix><simplesect><title>
#: ../../CTranslationAp.xml:24
#, no-wrap
msgid "If Statement"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:27
msgid "In C, an if statement<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:27
#, no-wrap
msgid "if statement"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:27
msgid "</indexterm> consists of three parts - the condition<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:27
#, no-wrap
msgid "condition"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:27
msgid "</indexterm>, the true branch<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:27
#, no-wrap
msgid "true branch"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:27
msgid "</indexterm>, and the false branch<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:27
#, no-wrap
msgid "false branch"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:27
msgid ""
"</indexterm>.  However, since assembly language is not a block structured "
"language<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:28
#, no-wrap
msgid "block structured language"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:28
msgid ""
"</indexterm>, you have to work a little to implement the block-like nature "
"of C.  For example, look at the following C code:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:46
msgid "In assembly language, this can be rendered as:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:77
msgid ""
"As you can see, since assembly language is linear, the blocks have to jump "
"around each other.  Recovergence is handled by the programmer, not the "
"system."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:83
msgid "A case statement<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:83
#, no-wrap
msgid "case statement"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:83
msgid "</indexterm> is written just like a sequence of if statements."
msgstr ""

# type: Content of: <appendix><simplesect><title>
#: ../../CTranslationAp.xml:89
#, no-wrap
msgid "Function Call"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:92
msgid "A function call<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:92
#, no-wrap
msgid "function call"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:92
msgid ""
"</indexterm> in assembly language simply requires pushing the arguments to "
"the function onto the stack in <emphasis>reverse</emphasis> order, and "
"issuing a <literal>call<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:94
#, no-wrap
msgid "call"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:94
msgid ""
"</indexterm></literal> instruction.  After calling, the arguments are then "
"popped back off of the stack.  For example, consider the C code:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:104
msgid "In assembly language, this would be rendered as:"
msgstr ""

# type: Content of: <appendix><simplesect><title>
#: ../../CTranslationAp.xml:127
#, no-wrap
msgid "Variables and Assignment"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:130
#, no-wrap
msgid "global variables"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:130 ../../CTranslationAp.xml:131
msgid "</indexterm> <indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:131
#, no-wrap
msgid "static variables"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:132 ../../CTranslationAp.xml:437
#, no-wrap
msgid "local variables"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:132
msgid ""
"</indexterm> Global and static variables are declared using "
"<literal>.data</literal> or <literal>.bss</literal> entries.  Local "
"variables are declared by reserving space on the stack at the beginning of "
"the function.  This space is given back at the end of the function."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:141
msgid ""
"Interestingly, global variables are accessed differently than local "
"variables in assembly language.  Global variables are accessed using direct "
"addressing<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:142
#, no-wrap
msgid "direct addressing mode"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:142
msgid ""
"</indexterm>, while local variables are accessed using base pointer "
"addressing<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:143 ../../CTranslationAp.xml:372
#, no-wrap
msgid "base pointer addressing mode"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:143
msgid "</indexterm>.  For example, consider the following C code:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:162
msgid "This would be rendered in assembly language as:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:187
msgid ""
"What may not be obvious is that accessing the global variable takes fewer "
"machine cycles than accessing the local variable.  However, that may not "
"matter because the stack is more likely to be in physical memory<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:189
#, no-wrap
msgid "physical memory"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:189
msgid "</indexterm> (instead of swap)  than the global variable is."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:194
msgid ""
"Also note that in the C programming language, after the compiler loads a "
"value into a register, that value will likely stay in that register until "
"that register is needed for something else.  It may also move registers.  "
"For example, if you have a variable <literal>foo</literal>, it may start on "
"the stack, but the compiler will eventually move it into registers for "
"processing.  If there aren't many variables in use, the value may simply "
"stay in the register until it is needed again.  Otherwise, when that "
"register is needed for something else, the value, if it's changed, is copied "
"back to its corresponding memory location.  In C, you can use the keyword "
"<literal>volatile<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:202
#, no-wrap
msgid "volatile"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:202
msgid ""
"</indexterm></literal> to make sure all modifications and references to the "
"variable are done to the memory location itself, rather than a register copy "
"of it, in case other processes, threads, or hardware may be modifying the "
"value while your function is running."
msgstr ""

# type: Content of: <appendix><simplesect><title>
#: ../../CTranslationAp.xml:212
#, no-wrap
msgid "Loops"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:215
msgid "Loops<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:215
#, no-wrap
msgid "loops"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:215
msgid ""
"</indexterm> work a lot like if statements in assembly language - the blocks "
"are formed by jumping around.  In C, a while loop consists of a loop body, "
"and a test to determine whether or not it is time to exit the loop. A for "
"loop is exactly the same, with optional initialization and counter-increment "
"sections.  These can simply be moved around to make a while loop<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:219
#, no-wrap
msgid "while loop"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:219 ../../CTranslationAp.xml:433
msgid "</indexterm>."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:223
msgid "In C, a while loop looks like this:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:236
msgid "This can be rendered in assembly language like this:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:256
msgid ""
"The x86 assembly language has some direct support for looping as well.  The "
"&ecx-indexed; register can be used as a counter that "
"<emphasis>ends</emphasis> with zero.  The <literal>loop<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:258
#, no-wrap
msgid "loop"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:258
msgid ""
"</indexterm></literal> instruction will decrement &ecx; and jump to a "
"specified address unless &ecx; is zero.  For example, if you wanted to "
"execute a statement 100 times, you would do this in C:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:272
msgid "In assembly language it would be written like this:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:291
msgid ""
"One thing to notice is that the <literal>loop</literal> instruction "
"<emphasis>requires you to be counting backwards to zero</emphasis>.  If you "
"need to count forwards or use another ending number, you should use the loop "
"form which does not include the <literal>loop</literal> instruction."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:298
msgid ""
"For really tight loops of character string operations, there is also the "
"<literal>rep<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:299
#, no-wrap
msgid "rep"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:299
msgid ""
"</indexterm></literal> instruction, but we will leave learning about that as "
"an exercise to the reader."
msgstr ""

# type: Content of: <appendix><simplesect><title>
#: ../../CTranslationAp.xml:306
#, no-wrap
msgid "Structs"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:309
msgid "Structs<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:309
#, no-wrap
msgid "structs"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:309
msgid ""
"</indexterm> are simply descriptions of memory blocks.  For example, in C "
"you can say:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:322
msgid ""
"This doesn't do anything by itself, except give you ways of intelligently "
"using 84 bytes of data.  You can do basically the same thing using "
"<literal>.equ<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:324
#, no-wrap
msgid ".equ"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:324
msgid "</indexterm></literal> directives in assembly language.  Like this:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:335
msgid ""
"When you declare a variable of this type, all you are doing is reserving 84 "
"bytes of space.  So, if you have this in C:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:349
msgid "In assembly language you would have:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:372
msgid ""
"To access structure members, you just have to use base pointer "
"addressing<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:372
msgid ""
"</indexterm> with the offsets defined above.  For example, in C you could "
"set the person's age like this:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:382
msgid "In assembly language it would look like this:"
msgstr ""

# type: Content of: <appendix><simplesect><title>
#: ../../CTranslationAp.xml:392
#, no-wrap
msgid "Pointers"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:395
msgid "Pointers<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:395
#, no-wrap
msgid "pointers"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:395
msgid ""
"</indexterm> are very easy.  Remember, pointers are simply the "
"address<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:396
#, no-wrap
msgid "address"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:396
msgid ""
"</indexterm> that a value resides at.  Let's start by taking a look at "
"global variables.  For example:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:405
msgid "In assembly language, this would be:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:415
msgid "Taking the address of this data in C:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:423
msgid "Taking the address of this data in assembly language:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:431
msgid ""
"You see, with assembly language, you are almost always accessing memory "
"through pointers.  That's what direct addressing is.  To get the pointer "
"itself, you just have to go with immediate mode addressing<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:433
#, no-wrap
msgid "immediate mode addressing"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:437
msgid "Local variables<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:437
msgid ""
"</indexterm> are a little more difficult, but not much.  Here is how you "
"take the address of a local variable in C:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:456
msgid "The same code in assembly language:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:488
msgid ""
"As you can see, to take the address of a local variable, the address has to "
"be computed the same way the computer computes the addresses in base pointer "
"addressing.  There is an easier way - the processor provides the instruction "
"<literal>leal<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:491
#, no-wrap
msgid "leal"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:491
msgid "</indexterm></literal>, which stands for \"load effective address<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:491
#, no-wrap
msgid "effective address"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:491
msgid ""
"</indexterm>\".  This lets the computer compute the address, and then load "
"it wherever you want.  So, we could just say:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:503
msgid ""
"It's the same number of lines, but a little cleaner.  Then, to use this "
"value, you simply have to move it to a general-purpose register and use "
"indirect addressing<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:505
#, no-wrap
msgid "indirect addressing mode"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:505
msgid "</indexterm>, as shown in the example above."
msgstr ""

# type: Content of: <appendix><simplesect><title>
#: ../../CTranslationAp.xml:511
#, no-wrap
msgid "Getting GCC to Help"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:514
msgid "One of the nice things about GCC<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:514
#, no-wrap
msgid "GCC"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:514
msgid ""
"</indexterm> is its ability to spit out assembly language code.  To convert "
"a C language file to assembly, you can simply do:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:524
msgid ""
"The output will be in <filename>file.s</filename>.  It's not the most "
"readable output - most of the variable names have been removed and replaced "
"either with numeric stack locations or references to automatically-generated "
"labels.  To start with, you probably want to turn off optimizations with "
"<literal>-O0</literal> so that the assembly language output will follow your "
"source code better."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:533
msgid ""
"Something else you might notice is that GCC reserves more stack space for "
"local variables than we do, and then AND's &esp-indexed; <footnote>"
msgstr ""

# type: Content of: <appendix><simplesect><para><para>
#: ../../CTranslationAp.xml:537
msgid "Note that different versions of GCC do this differently."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:539
msgid ""
"</footnote> This is to increase memory and cache efficiency by double-word "
"aligning variables."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:546
msgid ""
"Finally, at the end of functions, we usually do the following instructions "
"to clean up the stack before issuing a <literal>ret<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:547
#, no-wrap
msgid "ret"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:547
msgid "</indexterm></literal> instruction:"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:556
msgid ""
"However, GCC output will usually just include the instruction "
"<literal>leave<indexterm>"
msgstr ""

# type: Content of: <appendix><simplesect><para><primary>
#: ../../CTranslationAp.xml:557
#, no-wrap
msgid "leave"
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:557
msgid ""
"</indexterm></literal>.  This instruction is simply the combination of the "
"above two instructions.  We do not use <literal>leave</literal> in this text "
"because we want to be clear about exactly what is happening at the processor "
"level."
msgstr ""

# type: Content of: <appendix><simplesect><para>
#: ../../CTranslationAp.xml:564
msgid ""
"I encourage you to take a C program you have written and compile it to "
"assembly language and trace the logic.  Then, add in optimizations and try "
"again.  See how the compiler chose to rearrange your program to be more "
"optimized, and try to figure out why it chose the arrangement and "
"instructions it did."
msgstr ""
