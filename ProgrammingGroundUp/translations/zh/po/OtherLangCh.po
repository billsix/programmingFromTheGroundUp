# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2006-05-15 16:01+0800\n"
"PO-Revision-Date: 2006-07-30 17:54+0800\n"
"Last-Translator: Zhang Le <robert.zhangle@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING\n"
"X-Generator: Pootle 0.10beta3\n"

# type: Content of: <chapter><title>
#: ../../OtherLangCh.xml:2
#, no-wrap
msgid "High-Level Languages"
msgstr "高级语言"

# type: Content of: <chapter><para>
#: ../../OtherLangCh.xml:16
msgid ""
"In this chapter we will begin to look at our first \"real-world\" "
"programming language.  Assembly language is the language used at the "
"machine's level, but most people find coding in assembly language too "
"cumbersome for everyday use.  Many computer languages have been invented to "
"make the programming task easier.  Knowing a wide variety of languages is "
"useful for many reasons, including"
msgstr ""

# type: Content of: <chapter><para><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:25
msgid ""
"Different languages are based on different concepts, which will help you to "
"learn different and better programming methods and ideas."
msgstr ""

# type: Content of: <chapter><para><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:26
msgid "Different languages are good for different types of projects."
msgstr ""

# type: Content of: <chapter><para><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:27
msgid ""
"Different companies have different standard languages, so knowing more "
"languages makes your skills more marketable."
msgstr ""

# type: Content of: <chapter><para><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:28
msgid "The more languages you know, the easier it is to pick up new ones."
msgstr ""

# type: Content of: <chapter><para>
#: ../../OtherLangCh.xml:31
msgid ""
"As a programmer, you will often have to pick up new languages.  Professional "
"programmers can usually pick up a new language with about a weeks worth of "
"study and practice.  Languages are simply tools, and learning to use a new "
"tool should not be something a programmer flinches at.  In fact, if you do "
"computer consulting you will often have to learn new languages on the spot "
"in order to keep yourself employed. It will often be your customer, not you, "
"who decides what language is used.  This chapter will introduce you to a few "
"of the languages available to you.  I encourage you to explore as many "
"languages as you are interested in.  I personally try to learn a new "
"language every few months."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../OtherLangCh.xml:44
#, no-wrap
msgid "Compiled and Interpreted Languages"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:47
msgid ""
"Many languages are <emphasis>compiled</emphasis> languages.  When you write "
"assembly language<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:48
#, no-wrap
msgid "assembly language"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:48
msgid ""
"</indexterm>, each instruction you write is translated into exactly one "
"machine instruction for processing.  With compilers<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:50
#, no-wrap
msgid "compilers"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:50
msgid ""
"</indexterm>, a statement can translate into one or hundreds of machine "
"instructions.  In fact, depending on how advanced your compiler is, it might "
"even restructure parts of your code to make it faster.  In assembly language "
"what you write is what you get."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:58
msgid ""
"There are also languages that are <emphasis>interpreted</emphasis> "
"languages.  These languages require that the user run a program called an "
"<emphasis>interpreter<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:60
#, no-wrap
msgid "interpreter"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:60
msgid ""
"</indexterm></emphasis> that in turn runs the given program.  These are "
"usually slower than compiled programs, since the interpreter has to read and "
"interpret the code as it goes along.  However, in well-made interpreters, "
"this time can be fairly negligible.  There is also a class of hybrid "
"languages which partially compile a program before execution into "
"byte-codes.  This is done because the interpreter can read the byte-codes "
"much faster than it can read the regular language."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:71
msgid ""
"There are many reasons to choose one or the other.  Compiled programs are "
"nice, because you don't have to already have an interpreter installed in the "
"user's machine.  You have to have a compiler for the language, but the users "
"of your program don't.  In an interpreted language, you have to be sure that "
"the user has an interpreter installed for your program, and that the "
"computer knows which interpreter to run your program with.  However, "
"interpeted languages tend to be more flexible, while compiled languages are "
"more rigid."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:82
msgid ""
"Language choice is usually driven by available tools and support for "
"programming methods rather than by whether a language is compiled or "
"interpretted.  In fact many languages have options for either one."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:88
msgid ""
"High-level languages, whether compiled or interpreted, are oriented around "
"you, the programmer, instead of around the machine.  This opens them up to a "
"wide variety of features, which can include the following:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:94
msgid "Being able to group multiple operations into a single expression"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:95
msgid ""
"Being able to use \"big values\" - values that are much more conceptual than "
"the 4-byte words that computers normally deal with (for example, being able "
"to view text strings as a single value rather than as a string of bytes)."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:96
msgid "Having access to better flow control<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para><primary>
#: ../../OtherLangCh.xml:96
#, no-wrap
msgid "flow control"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:96
msgid "</indexterm> constructs than just jumps."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:97
msgid "Having a compiler to check types of value assignments and other assertions."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:98
msgid "Having memory handled automatically."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:99
msgid ""
"Being able to work in a language that resembles the problem domain rather "
"than the computer hardware."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:103
msgid ""
"So why does one choose one language over another? For example, many choose "
"Perl because it has a vast library of functions for handling just about "
"every protocol or type of data on the planet.  Python, however, has a "
"cleaner syntax and often lends itself to more straightforward solutions.  "
"Its cross-platform GUI tools are also excellent.  PHP makes writing web "
"applications simple.  Common LISP has more power and features than any other "
"environment for those willing to learn it.  Scheme is the model of "
"simplicity and power combined together.  C is easy to interface with other "
"languages."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:115
msgid ""
"Each language is different, and the more languages you know the better "
"programmer you will be.  Knowing the concepts of different languages will "
"help you in all programming, because you can match the programming language "
"to the problem better, and you have a larger set of tools to work with.  "
"Even if certain features aren't directly supported in the language you are "
"using, often they can be simulated.  However, if you don't have a broad "
"experience with languages, you won't know of all the possibilities you have "
"to choose from."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../OtherLangCh.xml:128
#, no-wrap
msgid "Your First C Program"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:131
msgid "<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:131
#, no-wrap
msgid "C Programming Language"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:131
msgid ""
"</indexterm> Here is your first C program, which prints \"Hello world\" to "
"the screen and exits.  Type it in, and give it the name Hello-World.c"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:140
msgid ""
"As you can see, it's a pretty simple program.  To compile it, run the "
"command"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:147
msgid "To run the program, do"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:153
msgid "Let's look at how this program was put together."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:157
msgid ""
"Comments in C are started with <literal>/*</literal> and ended with "
"<literal>*/</literal>.  Comments can span multiple lines, but many people "
"prefer to start and end comments on the same line so they don't get "
"confused."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:164
msgid "<literal>#include &lt;stdio.h&gt;</literal> <indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:165
#, no-wrap
msgid "stdio.h"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:165
msgid ""
"</indexterm> is the first part of the program.  This is a "
"<emphasis>preprocessor directive</emphasis>.  C compiling is split into two "
"stages - the preprocessor<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:168
#, no-wrap
msgid "preprocessor"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:168
msgid ""
"</indexterm> and the main compiler.  This directive tells the preprocessor "
"to look for the file <filename>stdio.h</filename> and paste it into your "
"program.  The preprocessor is responsible for putting together the text of "
"the program.  This includes sticking different files together, running "
"macros on your program text, etc.  After the text is put together, the "
"preprocessor is done and the main compiler goes to work."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:178
msgid ""
"Now, everything in <filename>stdio.h</filename> is now in your program just "
"as if you typed it there yourself.  The angle brackets around the filename "
"tell the compiler to look in its standard paths for the file "
"(<filename>/usr/include<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:181
#, no-wrap
msgid "/usr/include"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:181
msgid "</indexterm></filename> and <filename>/usr/local/include<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:182
#, no-wrap
msgid "/usr/local/include"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:182
msgid ""
"</indexterm></filename>, usually).  If it was in quotes, like "
"<literal>#include \"stdio.h\"</literal> it would look in the current "
"directory for the file.  Anyway, <filename>stdio.h</filename> contains the "
"declarations for the standard input and output functions and variables.  "
"These declarations tell the compiler what functions are available for input "
"and output.  The next few lines are simply comments about the program."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:193
msgid ""
"Then there is the line <literal>int main(int argc, char **argv)</literal>.  "
"This is the start of a function.  C Functions are declared with their name, "
"arguments and return type.  This declaration says that the function's name "
"is <literal>main</literal>, it returns an <literal>int</literal> (integer - "
"4 bytes long on the x86 platform), and has two arguments - an "
"<literal>int</literal> called <literal>argc</literal> and a <literal>char "
"**</literal> called <literal>argv</literal>.  You don't have to worry about "
"where the arguments are positioned on the stack - the C compiler takes care "
"of that for you.  You also don't have to worry about loading values into and "
"out of registers because the compiler takes care of that, too."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:207
msgid ""
"The <literal>main</literal> function is a special function in the C language "
"- it is the start of all C programs (much like <literal>_start</literal> in "
"our assembly-language programs).  It always takes two parameters.  The first "
"parameter is the number of arguments given to this command, and the second "
"parameter is a list of the arguments that were given."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:216
msgid ""
"The next line is a function call.  In assembly language, you had to push the "
"arguments of a function onto the stack, and then call the function.  C takes "
"care of this complexity for you.  You simply have to call the function with "
"the parameters in parenthesis.  In this case, we call the function "
"<literal>puts</literal>, with a single parameter.  This parameter is the "
"character string we want to print.  We just have to type in the string in "
"quotations, and the compiler takes care of defining storage and moving the "
"pointers to that storage onto the stack before calling the function.  As you "
"can see, it's a lot less work."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:228
msgid ""
"Finally our function returns the number <literal>0</literal>.  In assembly "
"language, we stored our return value in &eax;, but in C we just use the "
"<literal>return</literal> command and it takes care of that for us.  The "
"return value of the <literal>main</literal> function is what is used as the "
"exit code for the program."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:236
msgid "As you can see, using high-level languages<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:236
#, no-wrap
msgid "high-level languages"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:236
msgid ""
"</indexterm> makes life much easier.  It also allows our programs to run on "
"multiple platforms more easily.  In assembly language, your program is tied "
"to both the operating system and the hardware platform, while in compiled "
"and interpreted languages the same code can usually run on multiple "
"operating systems and hardware platforms.  For example, this program can be "
"built and executed on x86 hardware running <trademark "
"class=\"registered\">Linux</trademark>, <trademark "
"class=\"registered\">Windows</trademark>, <trademark "
"class=\"registered\">UNIX</trademark>, or most other operating systems.  In "
"addition, it can also run on Macintosh hardware running a number of "
"operating systems."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:250
msgid ""
"Additional information on the C programming language can be found in <xref "
"linkend=\"ctranslationap\" />."
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:257 ../../OtherLangCh.xml:277
#, no-wrap
msgid "Perl"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:260
msgid ""
"Perl is an interpreted language, existing mostly on Linux and UNIX-based "
"platforms.  It actually runs on almost all platforms, but you find it most "
"often on Linux and UNIX-based ones.  Anyway, here is the Perl version of the "
"program, which should be typed into a file named "
"<filename>Hello-World.pl</filename>:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:270
msgid ""
"Since Perl is interpreted, you don't need to compile or link it.  Just run "
"in with the following command:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:277
msgid "As you can see, the Perl<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:277
msgid ""
"</indexterm> version is even shorter than the C version.  With Perl you "
"don't have to declare any functions or program entry points.  You can just "
"start typing commands and the interpreter will run them as it comes to "
"them.  In fact this program only has two lines of code, one of which is "
"optional."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:285
msgid ""
"The first, optional line is used for UNIX machines to tell which interpreter "
"to use to run the program.  The <literal>#!</literal> tells the computer "
"that this is an interpreted program, and the "
"<filename>/usr/bin/perl</filename> tells the computer to use the program "
"<filename>/usr/bin/perl</filename> to interpret the program.  However, since "
"we ran the program by typing in <literal>perl Hello-World.pl</literal>, we "
"had already specified that we were using the perl interpreter."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:295
msgid ""
"The next line calls a Perl builtin function, print.  This has one parameter, "
"the string to print.  The program doesn't have an explicit return statement "
"- it knows to return simply because it runs off the end of the file.  It "
"also knows to return 0 because there were no errors while it ran.  You can "
"see that interpreted languages are often focused on letting you get working "
"code as quickly as possible, without having to do a lot of extra legwork."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:304
msgid ""
"One thing about Perl that isn't so evident from this example is that Perl "
"treats strings as a single value.  In assembly language, we had to program "
"according to the computer's memory architecture, which meant that strings "
"had to be treated as a sequence of multiple values, with a pointer to the "
"first letter.  Perl pretends that strings can be stored directly as values, "
"and thus hides the complication of manipulating them for you.  In fact, one "
"of Perl's main strengths is its ability and speed at manipulating text."
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../OtherLangCh.xml:317 ../../OtherLangCh.xml:320
#, no-wrap
msgid "Python"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:320
msgid "The Python<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:320
msgid ""
"</indexterm> version of the program looks almost exactly like the Perl one.  "
"However, Python is really a very different language than Perl, even if it "
"doesn't seem so from this trivial example.  Type the program into a file "
"named <filename>Hello-World.py</filename>.  The program follows:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../OtherLangCh.xml:331
msgid "You should be able to tell what the different lines of the program do."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../OtherLangCh.xml:337
#, no-wrap
msgid "Review"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../OtherLangCh.xml:340
#, no-wrap
msgid "Know the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:343
msgid ""
"What is the difference between an intepretted language and a compiled "
"language?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:344
msgid "What reasons might cause you to need to learn a new programming language?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../OtherLangCh.xml:350
#, no-wrap
msgid "Use the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:353
msgid ""
"Learn the basic syntax of a new programming language.  Re-code one of the "
"programs in this book in that language."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:354
msgid ""
"In the program you wrote in the question above, what specific things were "
"automated in the programming language you chose?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:355
msgid ""
"Modify your program so that it runs 10,000 times in a row, both in assembly "
"language and in your new language.  Then run the <literal>time</literal> "
"command to see which is faster.  Which does come out ahead? Why do you think "
"that is?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:356
msgid ""
"How does the programming language's input/output methods differ from that of "
"the Linux system calls?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../OtherLangCh.xml:362
#, no-wrap
msgid "Going Further"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:365
msgid ""
"Having seen languages which have such brevity as Perl, why do you think this "
"book started you with a language as verbose as assembly language?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:366
msgid ""
"How do you think high level languages have affected the process of "
"programming?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:367
msgid "Why do you think so many languages exist?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../OtherLangCh.xml:368
msgid ""
"Learn two new high level languages.  How do they differ from each other? How "
"are they similar? What approach to problem-solving does each take?"
msgstr ""
