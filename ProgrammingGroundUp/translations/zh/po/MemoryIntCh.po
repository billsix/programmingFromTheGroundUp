# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2006-05-15 16:01+0800\n"
"PO-Revision-Date: 2006-07-30 17:53+0800\n"
"Last-Translator: Zhang Le <robert.zhangle@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING\n"
"X-Generator: Pootle 0.10beta3\n"

# type: Content of: <chapter><title>
#: ../../MemoryIntCh.xml:2
#, no-wrap
msgid "Intermediate Memory Topics"
msgstr "中级内存话题"

# type: Content of: <chapter><sect1><title>
#: ../../MemoryIntCh.xml:5
#, no-wrap
msgid "How a Computer Views Memory"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:8
msgid ""
"Let's review how memory within a computer works.  You may also want to "
"re-read <xref linkend=\"computerarchitecture\" />."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:13
msgid ""
"A computer looks at memory as a long sequence of numbered storage "
"locations.  A sequence of <emphasis>millions</emphasis> of numbered storage "
"locations.  Everything is stored in these locations.  Your programs are "
"stored there, your data is stored there, everything.  Each storage location "
"looks like every other one.  The locations holding your program are just "
"like the ones holding your data.  In fact, the computer has no idea which "
"are which, except that the executable file tells it where to start "
"executing."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:24
msgid ""
"These storage locations are called bytes.  The computer can combine up to "
"four of them together into a single word.  Normally numeric data is operated "
"on a word at a time.  As we mentioned, instructions are also stored in this "
"same memory.  Each instruction is a different length.  Most instructions "
"take up one or two storage locations for the instruction itself, and then "
"storage locations for the instruction's arguments.  For example, the "
"instruction"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:36
msgid ""
"takes up 7 storage locations.  The first two hold the instruction, the third "
"one tells which registers to use, and the next four hold the storage "
"location of <literal>data_items</literal>.  In memory, instructions look "
"just like all the other numbers, and the instructions themselves can be "
"moved into and out of registers just like numbers, because that's what they "
"are."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:45
msgid ""
"This chapter is focused on the details of computer memory.  To get started "
"let's review some basic terms that we will be using in this chapter:"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../MemoryIntCh.xml:52
#, no-wrap
msgid "Byte"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../MemoryIntCh.xml:54
msgid ""
"This is the size of a storage location.  On x86 processors, a byte can hold "
"numbers between 0 and 255."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../MemoryIntCh.xml:60
#, no-wrap
msgid "Word"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../MemoryIntCh.xml:62
msgid ""
"This is the size of a normal register.  On x86 processors, a word is four "
"bytes long.  Most computer operations handle a word at a time."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../MemoryIntCh.xml:68
#, no-wrap
msgid "Address"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../MemoryIntCh.xml:71
msgid ""
"An address is a number that refers to a byte in memory.  For example, the "
"first byte on a computer has an address of 0, the second has an address of "
"1, and so on.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para><para>
#: ../../MemoryIntCh.xml:73
msgid "You actually never use addresses this low, but it works for discussion."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../MemoryIntCh.xml:74
msgid ""
"</footnote> Every piece of data on the computer not in a register has an "
"address.  The address of data which spans several bytes is the same as the "
"address of its first byte."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../MemoryIntCh.xml:80
msgid ""
"Normally, we don't ever type the numeric address of anything, but we let the "
"assembler do it for us.  When we use labels in code, the symbol used in the "
"label will be equivalent to the address it is labelling.  The assembler will "
"then replace that symbol with its address wherever you use it in your "
"program.  For example, say you have the following code:"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../MemoryIntCh.xml:92
msgid ""
"Now, any time in the program that <literal>my_data</literal> is used, it "
"will be replaced by the address of the first value of the "
"<literal>.long</literal> directive."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../MemoryIntCh.xml:100
#, no-wrap
msgid "Pointer"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../MemoryIntCh.xml:102
msgid ""
"A pointer is a register or memory word whose value is an address.  In our "
"programs we use <literal>%ebp</literal> as a pointer to the current stack "
"frame.  All base pointer addressing involves pointers.  Programming uses a "
"lot of pointers, so it's an important concept to grasp."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../MemoryIntCh.xml:182
#, no-wrap
msgid "The Memory Layout of a Linux Program"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:185
msgid "When you program is loaded into memory, each <literal>.section<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:185
#, no-wrap
msgid ".section"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:185
msgid ""
"</indexterm></literal> is loaded into its own region of memory.  All of the "
"code and data declared in each section is brought together, even if they "
"were separated in your source code."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:192
msgid "The actual instructions (the <literal>.text<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:192
#, no-wrap
msgid ".text"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:192
msgid ""
"</indexterm></literal> section) are loaded at the address 0x08048000 "
"(numbers starting with <literal>0x</literal> are in hexadecimal, which will "
"be discussed in <xref linkend=\"countingchapter\" />).<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../MemoryIntCh.xml:194
msgid ""
"Addresses mentioned in this chapter are not set in stone and may vary based "
"on kernel version."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:195
msgid "</footnote> The <literal>.data<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:195
#, no-wrap
msgid ".data"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:195
msgid ""
"</indexterm></literal> section is loaded immediately after that, followed by "
"the <literal>.bss<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:197
#, no-wrap
msgid ".bss"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:197
msgid "</indexterm></literal> section."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:202
msgid ""
"The last byte that can be addressed on Linux is location 0xbfffffff.  Linux "
"starts the stack here and grows it downward toward the other sections.  "
"Between them is a huge gap.  The initial layout of the stack is as follows: "
"At the bottom of the stack (the bottom of the stack is the top address of "
"memory - see <xref linkend=\"functionschapter\" />), there is a word of "
"memory that is zero.  After that comes the null-terminated name of the "
"program using ASCII characters.  After the program name comes the program's "
"environment variables (these are not important to us in this book).  Then "
"come the program's command-line arguments.  These are the values that the "
"user typed in on the command line to run this program.  When we run "
"<literal>as</literal>, for example, we give it several arguments - "
"<literal>as</literal>, <literal>sourcefile.s</literal>, "
"<literal>-o</literal>, and <literal>objectfile.o</literal>.  After these, we "
"have the number of arguments that were used.  When the program begins, this "
"is where the stack pointer, &esp-indexed;, is pointing.  Further pushes on "
"the stack move &esp; down in memory.  For example, the instruction"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:227
msgid "is equivalent to"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:234
msgid "Likewise, the instruction"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:240
msgid "is the same as"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:249
msgid ""
"Your program's data region starts at the bottom of memory and goes up.  The "
"stack starts at the top of memory, and moves downward with each push.  This "
"middle part between the stack and your program's data sections is "
"inaccessible memory - you are not allowed to access it until you tell the "
"kernel that you need it.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../MemoryIntCh.xml:253
msgid ""
"The stack can access it as it grows downward, and you can access the stack "
"regions through &esp-indexed;.  However, your program's data section doesn't "
"grow that way.  The way to grow that will be explained shortly."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:256
msgid ""
"</footnote> If you try, you will get an error (the error message is usually "
"\"segmentation fault\").  The same will happen if you try to access data "
"before the beginning of your program, 0x08048000.  The last accessible "
"memory address to your program is called the <emphasis>system "
"break<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:262
#, no-wrap
msgid "system break"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:262
msgid "</indexterm></emphasis> (also called the <emphasis>current break<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../MemoryIntCh.xml:263 ../../MemoryIntCh.xml:553
#, no-wrap
msgid "current break"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:263
msgid "</indexterm></emphasis> or just the <emphasis>break</emphasis>)."
msgstr ""

# type: Content of: <chapter><sect1><mediaobject><caption><para>
#: ../../MemoryIntCh.xml:270
msgid "<emphasis>Memory Layout of a Linux Program at Startup</emphasis>"
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../MemoryIntCh.xml:276
#, no-wrap
msgid "Every Memory Address is a Lie"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:278
msgid ""
"So, why does the computer not allow you to access memory in the break area? "
"To answer this question, we will have to delve into the depths of how your "
"computer really handles memory."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:284
msgid ""
"You may have wondered, since every program gets loaded into the same place "
"in memory, don't they step on each other, or overwrite each other? It would "
"seem so.  However, as a program writer, you only access <emphasis>virtual "
"memory<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:287 ../../MemoryIntCh.xml:429
#, no-wrap
msgid "virtual memory"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:287 ../../MemoryIntCh.xml:315 ../../MemoryIntCh.xml:467 ../../MemoryIntCh.xml:486
msgid "</indexterm></emphasis>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:291
msgid "<emphasis>Physical memory<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:291
#, no-wrap
msgid "physical memory"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:291
msgid ""
"</indexterm></emphasis> refers to the actual RAM chips inside your computer "
"and what they contain.  It's usually between 16 and 512 Megabytes on modern "
"computers.  If we talk about a <emphasis>physical memory address</emphasis>, "
"we are talking about where exactly on these chips a piece of memory is "
"located.  Virtual memory is the way <emphasis>your program</emphasis> thinks "
"about memory.  Before loading your program, Linux finds an empty physical "
"memory space large enough to fit your program, and then tells the processor "
"to pretend that this memory is actually at the address 0x0804800 to load "
"your program into.  Confused yet? Let me explain further."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:304
msgid ""
"Each program gets its own sandbox to play in.  Every program running on your "
"computer thinks that it was loaded at memory address 0x0804800, and that its "
"stack starts at 0xbffffff.  When Linux loads a program, it finds a section "
"of unused memory, and then tells the processor to use that section of memory "
"as the address 0x0804800 for this program.  The address that a program "
"believes it uses is called the virtual address<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:310
#, no-wrap
msgid "virtual address"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:310
msgid ""
"</indexterm>, while the actual address on the chips that it refers to is "
"called the physical address<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:312
#, no-wrap
msgid "physical address"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:312
msgid ""
"</indexterm>.  The process of assigning virtual addresses to physical "
"addresses is called <emphasis>mapping<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:315
#, no-wrap
msgid "mapping"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:319
msgid ""
"Earlier we talked about the inaccessible memory between the "
"<literal>.bss</literal> and the stack, but we didn't talk about why it was "
"there.  The reason is that this region of virtual memory addresses hasn't "
"been mapped onto physical memory addresses.  The mapping process takes up "
"considerable time and space, so if every possible virtual address of every "
"possible program were mapped, you would not have enough physical memory to "
"even run one program.  So, the break is the beginning of the area that "
"contains unmapped memory.  With the stack, however, Linux will automatically "
"map in memory that is accessed from stack pushes."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:332
msgid ""
"Of course, this is a very simplified view of virtual memory.  The full "
"concept is much more advanced.  For example, Virtual memory can be mapped to "
"more than just physical memory; it can be mapped to disk as well.  Swap "
"partitions on Linux allow Linux's virtual memory system to map memory not "
"only to physical RAM, but also to disk blocks as well.  For example, let's "
"say you only have 16 Megabytes of physical memory.  Let's also say that 8 "
"Megabytes are being used by Linux and some basic applications, and you want "
"to run a program that requires 20 Megabytes of memory.  Can you? The answer "
"is yes, but only if you have set up a swap partition.  What happens is that "
"after all of your remaining 8 Megabytes of physical memory have been mapped "
"into virtual memory, Linux starts mapping parts of your application's "
"virtual memory to disk blocks.  So, if you access a \"memory\" location in "
"your program, that location may not actually be in memory at all, but on "
"disk.  As the programmer you won't know the difference, though, because it "
"is all handled behind the scenes by Linux."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:351
msgid ""
"Now, x86 processors cannot run instructions directly from disk, nor can they "
"access data directly from disk.  This requires the help of the operating "
"system.  When you try to access memory that is mapped to disk, the processor "
"notices that it can't service your memory request directly.  It then asks "
"Linux to step in.  Linux notices that the memory is actually on disk.  "
"Therefore, it moves some data that is currently in memory onto disk to make "
"room, and then moves the memory being accessed from the disk back into "
"physical memory.  It then adjusts the processor's virtual-to-physical memory "
"lookup tables so that it can find the memory in the new location.  Finally, "
"Linux returns control to the program and restarts it at the instruction "
"which was trying to access the data in the first place.  This instruction "
"can now be completed successfully, because the memory is now in physical "
"RAM.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../MemoryIntCh.xml:363
msgid ""
"Note that not only can Linux have a virtual address map to a different "
"physical address, it can also move those mappings around as needed."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:366
msgid "</footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:370
msgid "Here is an overview of the way memory accesses are handled under Linux:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:374
msgid "The program tries to load memory from a virtual address."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:375
msgid ""
"The processor, using tables supplied by Linux, transforms the virtual memory "
"address into a physical memory address on the fly."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:376
msgid ""
"If the processor does not have a physical address listed for the memory "
"address, it sends a request to Linux to load it."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:377
msgid ""
"Linux looks at the address.  If it is mapped to a disk location, it "
"continues on to the next step.  Otherwise, it terminates the program with a "
"segmentation fault error."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:378
msgid ""
"If there is not enough room to load the memory from disk, Linux will move "
"another part of the program or another program onto disk to make room."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:379
msgid "Linux then moves the data into a free physical memory address."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:380
msgid ""
"Linux updates the processor's virtual-to-physical memory mapping tables to "
"reflect the changes."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:381
msgid ""
"Linux restores control to the program, causing it to re-issue the "
"instruction which caused this process to happen."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:382
msgid ""
"The processor can now handle the instruction using the newly-loaded memory "
"and translation tables."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:386
msgid ""
"It's a lot of work for the operating system, but it gives the user and the "
"programmer great flexibility when it comes to memory management."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:391
msgid ""
"Now, in order to make the process more efficient, memory is separated out "
"into groups called <emphasis>pages<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:392
#, no-wrap
msgid "pages"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:392
msgid ""
"</indexterm></emphasis>.  When running Linux on x86 processors, a page is "
"4096 bytes of memory.  All of the memory mappings are done a page at a "
"time.  Physical memory assignment, swapping<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:395
#, no-wrap
msgid "swapping"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:395
msgid "</indexterm>, mapping, etc. are all done to memory pages<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:395
#, no-wrap
msgid "memory pages"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:395
msgid ""
"</indexterm> instead of individual memory addresses.  What this means to you "
"as a programmer is that whenever you are programming, you should try to keep "
"most memory accesses within the same basic range of memory, so you will only "
"need a page or two of memory at a time.  Otherwise, Linux may have to keep "
"moving pages on and off of disk to satisfy your memory needs. Disk access is "
"slow, so this can really slow down your program."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:404
msgid ""
"Sometimes so many programs can be loaded that there is hardly enough "
"physical memory for them.  They wind up spending more time just swapping "
"memory on and off of disk than they do actually processing it.  This leads "
"to a condition called <emphasis>swap death<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:407
#, no-wrap
msgid "swap death"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:407
msgid ""
"</indexterm></emphasis> which leads to your system being unresponsive and "
"unproductive.  It's usually usually recoverable if you start terminating "
"your memory-hungry programs, but it's a pain."
msgstr ""

# type: Content of: <chapter><sect1><note><title>
#: ../../MemoryIntCh.xml:413
#, no-wrap
msgid "Resident Set Size"
msgstr ""

# type: Content of: <chapter><sect1><note><para>
#: ../../MemoryIntCh.xml:415
msgid ""
"The amount of memory that your program currently has in physical memory is "
"called its resident set size<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><note><para><primary>
#: ../../MemoryIntCh.xml:416
#, no-wrap
msgid "resident set size"
msgstr ""

# type: Content of: <chapter><sect1><note><para>
#: ../../MemoryIntCh.xml:416
msgid ""
"</indexterm>, and can be viewed by using the program "
"<literal>top</literal>.  The resident set size is listed under the column "
"labelled \"RSS\"."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../MemoryIntCh.xml:425
#, no-wrap
msgid "Getting More Memory"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:428
msgid ""
"We now know that Linux maps all of our virtual memory into physical memory "
"or swap.  If you try to access a piece of virtual memory<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:429
msgid ""
"</indexterm> that hasn't been mapped yet, it triggers an error known as a "
"segmentation fault, which will terminate your program.  The program break "
"point, if you remember, is the last valid address you can use.  Now, this is "
"all great if you know beforehand how much storage you will need.  You can "
"just add all the memory you need to your <literal>.data</literal> or "
"<literal>.bss</literal> sections, and it will all be there.  However, let's "
"say you don't know how much memory you will need.  For example, with a text "
"editor, you don't know how long the person's file will be.  You could try to "
"find a maximum file size, and just tell the user that they can't go beyond "
"that, but that's a waste if the file is small.  Therefore Linux has a "
"facility to move the break point to accomodate an application's memory "
"needs."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:444
msgid ""
"If you need more memory, you can just tell Linux where you want the new "
"break point to be, and Linux will map all the memory you need between the "
"current and new break point, and then move the break point to the spot you "
"specify.  That memory is now available for your program to use.  The way we "
"tell Linux to move the break point is through the <literal>brk<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../MemoryIntCh.xml:449 ../../MemoryIntCh.xml:612
#, no-wrap
msgid "brk"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:449
msgid ""
"</indexterm></literal> system call.  The <literal>brk</literal> system call "
"is call number 45 (which will be in &eax;).  &ebx; should be loaded with the "
"requested breakpoint.  Then you call <literal>int $0x80</literal> to signal "
"Linux to do its work.  After mapping in your memory, Linux will return the "
"new break point in &eax;.  The new break point might actually be larger than "
"what you asked for, because Linux rounds up to the nearest page.  If there "
"is not enough physical memory or swap to fulfill your request, Linux will "
"return a zero in &eax;.  Also, if you call <literal>brk</literal> with a "
"zero in &ebx;, it will simply return the last usable memory address."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:462
msgid ""
"The problem with this method is keeping track of the memory we request.  "
"Let's say I need to move the break to have room to load a file, and then "
"need to move a break again to load another file.  Let's say I then get rid "
"of the first file.  You now have a giant gap in memory that's mapped, but "
"that you aren't using.  If you continue to move the break in this way for "
"each file you load, you can easily run out of memory.  So, what is needed is "
"a <emphasis>memory manager<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:467
#, no-wrap
msgid "memory manager"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:471
msgid ""
"A memory manager is a set of routines that takes care of the dirty work of "
"getting your program memory for you.  Most memory managers have two basic "
"functions - <literal>allocate</literal> and "
"<literal>deallocate</literal>.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../MemoryIntCh.xml:473
msgid ""
"The function names usually aren't <literal>allocate</literal> and "
"<literal>deallocate</literal>, but the functionality will be the same.  In "
"the C programming language, for example, they are named "
"<literal>malloc</literal> and <literal>free</literal>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:476
msgid ""
"</footnote> Whenever you need a certain amount of memory, you can simply "
"tell <literal>allocate</literal> how much you need, and it will give you "
"back an address to the memory.  When you're done with it, you tell "
"<literal>deallocate</literal> that you are through with it.  "
"<literal>allocate</literal> will then be able to reuse the memory.  This "
"pattern of memory management is called <emphasis>dynamic memory "
"allocation<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../MemoryIntCh.xml:481
#, no-wrap
msgid "dynamic memory allocation"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:481
msgid ""
"</indexterm></emphasis>.  This minimizes the number of \"holes\" in your "
"memory, making sure that you are making the best use of it you can.  The "
"pool of memory used by memory managers is commonly referred to as "
"<emphasis>the heap<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../MemoryIntCh.xml:486 ../../MemoryIntCh.xml:551
#, no-wrap
msgid "heap"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:490
msgid ""
"The way memory managers work is that they keep track of where the system "
"break is, and where the memory that you have allocated is.  They mark each "
"block of memory in the heap as being used or unused.  When you request "
"memory, the memory manager checks to see if there are any unused blocks of "
"the appropriate size.  If not, it calls the <literal>brk</literal> system "
"call to request more memory.  When you free memory it marks the block as "
"unused so that future requests can retrieve it.  In the next section we will "
"look at building our own memory manager."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../MemoryIntCh.xml:503
#, no-wrap
msgid "A Simple Memory Manager"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:506
msgid ""
"Here I will show you a simple memory manager.  It is very primitive but it "
"shows the principles quite well.  As usual, I will give you the program "
"first for you to look through.  Afterwards will follow an in-depth "
"explanation.  It looks long, but it is mostly comments."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:517
msgid ""
"The first thing to notice is that there is no <literal>_start</literal> "
"symbol.  The reason is that this is just a set of functions.  A memory "
"manager by itself is not a full program - it doesn't do anything.  It is "
"simply a utility to be used by other programs."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:523
msgid "To assemble the program, do the following:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:531
msgid "Okay, now let's look at the code."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../MemoryIntCh.xml:535
#, no-wrap
msgid "Variables and Constants"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:538
msgid "At the beginning of the program, we have two locations set up:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:550
msgid ""
"Remember, the section of memory being managed is commonly referred to as the "
"<emphasis>heap<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:551
msgid ""
"</indexterm></emphasis>.  When we assemble the program, we have no idea "
"where the beginning of the heap is, nor where the current break<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:553
msgid ""
"</indexterm> is.  Therefore, we reserve space for their addresses, but just "
"fill them with a 0 for the time being."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:559
msgid ""
"Next we have a set of constants to define the structure of the heap.  The "
"way this memory manager works is that before each region of memory "
"allocated, we will have a short record describing the memory.  This record "
"has a word reserved for the available flag and a word for the region's "
"size.  The actual memory allocated immediately follows this record.  The "
"available flag is used to mark whether this region is available for "
"allocations, or if it is currently in use.  The size field lets us know both "
"whether or not this region is big enough for an allocation request, as well "
"as the location of the next memory region.  The following constants describe "
"this record:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:577
msgid ""
"This says that the header is 8 bytes total, the available flag is offset 0 "
"bytes from the beginning, and the size field is offset 4 bytes from the "
"beginning.  If we are careful to always use these constants, then we protect "
"ourselves from having to do too much work if we later decide to add more "
"information to the header."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:585
msgid ""
"The values that we will use for our <literal>available</literal> field are "
"either 0 for unavailable, or 1 for available.  To make this easier to read, "
"we have the following definitions:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:595
msgid "Finally, we have our Linux system call definitions:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../MemoryIntCh.xml:606
#, no-wrap
msgid "The <literal>allocate_init</literal> function"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:609
msgid ""
"Okay, this is a simple function.  All it does is set up the "
"<literal>heap_begin</literal> and <literal>current_break</literal> variables "
"we discussed earlier.  So, if you remember the discussion earlier, the "
"current break can be found using the <literal>brk<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:612
msgid "</indexterm></literal> system call.  So, the function starts like this:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:626
msgid ""
"Anyway, after <literal>int $LINUX_SYSCALL</literal>, <literal>%eax</literal> "
"holds the last valid address.  We actually want the first invalid address "
"instead of the last valid address, so we just increment "
"<literal>%eax</literal>.  Then we move that value to the "
"<literal>heap_begin</literal> and <literal>current_break</literal> "
"locations.  Then we leave the function.  The code looks like this:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:644
msgid ""
"The heap consists of the memory between <literal>heap_begin</literal> and "
"<literal>current_break</literal>, so this says that we start off with a heap "
"of zero bytes.  Our <literal>allocate</literal> function will then extend "
"the heap as much as it needs to when it is called."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../MemoryIntCh.xml:653
#, no-wrap
msgid "The <literal>allocate</literal> function"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:656
msgid ""
"This is the doozy function.  Let's start by looking at an outline of the "
"function:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../MemoryIntCh.xml:662
msgid "Start at the beginning of the heap."
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../MemoryIntCh.xml:666
msgid "Check to see if we're at the end of the heap."
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../MemoryIntCh.xml:670
msgid ""
"If we are at the end of the heap, grab the memory we need from Linux, mark "
"it as \"unavailable\" and return it.  If Linux won't give us any more, "
"return a 0."
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../MemoryIntCh.xml:675
msgid ""
"If the current memory region is marked \"unavailable\", go to the next one, "
"and go back to step 2."
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../MemoryIntCh.xml:680
msgid ""
"If the current memory region is too small to hold the requested amount of "
"space, go back to step 2."
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../MemoryIntCh.xml:685
msgid ""
"If the memory region is available and large enough, mark it as "
"\"unavailable\" and return it."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:692
msgid ""
"Now, look back through the code with this in mind.  Be sure to read the "
"comments so you'll know which register holds which value."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:697
msgid ""
"Now that you've looked back through the code, let's examine it one line at a "
"time.  We start off like this:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:710
msgid ""
"This part initializes all of our registers.  The first two lines are "
"standard function stuff.  The next move pulls the size of the memory to "
"allocate off of the stack.  This is our only function parameter.  After "
"that, it moves the beginning heap address and the end of the heap into "
"registers.  I am now ready to do processing."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:717
msgid ""
"The next section is marked <literal>alloc_loop_begin</literal>.  In this "
"loop we are going to examine memory regions until we either find an open "
"memory region or determine that we need more memory.  Our first instructions "
"check to see if we need more memory:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:728
msgid ""
"&eax; holds the current memory region being examined and &ebx; holds the "
"location past the end of the heap.  Therefore if the next region to be "
"examined is past the end of the heap, it means we need more memory to "
"allocate a region of this size.  Let's skip down to "
"<literal>move_break</literal> and see what happens there:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:748
msgid ""
"When we reach this point in the code, &ebx; holds where we want the next "
"region of memory to be.  So, we add our header size and region size to "
"&ebx;, and that's where we want the system break to be.  We then push all "
"the registers we want to save on the stack, and call the "
"<literal>brk</literal> system call. After that we check for errors:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:761
msgid ""
"If there were no errors we pop the registers back off the stack, mark the "
"memory as unavailable, record the size of the memory, and make sure &eax; "
"points to the start of usable memory (which is <emphasis>after</emphasis> "
"the header)."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:776
msgid ""
"Then we store the new program break and return the pointer to the allocated "
"memory."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:787
msgid ""
"The <literal>error</literal> code just returns 0 in &eax;, so we won't "
"discuss it."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:792
msgid ""
"Let's go back look at the rest of the loop.  What happens if the current "
"memory being looked at isn't past the end of the heap? Well, let's look."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:803
msgid ""
"This first grabs the size of the memory region and puts it in &edx;.  Then "
"it looks at the available flag to see if it is set to "
"<literal>UNAVAILABLE</literal>.  If so, that means that memory region is in "
"use, so we'll have to skip over it.  So, if the available flag is set to "
"<literal>UNAVAILABLE</literal>, you go to the code labeled "
"<literal>next_location</literal>.  If the available flag is set to "
"<literal>AVAILABLE</literal>, then we keep on going."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:812
msgid ""
"Let's say that the space was available, and so we keep going.  Then we check "
"to see if this space is big enough to hold the requested amount of memory.  "
"The size of this region is being held in &edx;, so we do this:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:823
msgid ""
"If the requested size is less than or equal to the current region's size, we "
"can use this block.  It doesn't matter if the current region is larger than "
"requested, because the extra space will just be unused.  So, let's jump down "
"to <literal>allocate_here</literal> and see what happens:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:838
msgid ""
"It marks the memory as being unavailable.  Then it moves the pointer &eax; "
"past the header, and uses it as the return value for the function.  "
"Remember, the person using this function doesn't need to even know about our "
"memory header record.  They just need a pointer to usable memory."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:845
msgid ""
"Okay, so let's say the region wasn't big enough.  What then? Well, we would "
"then be at the code labeled <literal>next_location</literal>.  This section "
"of code is used any time that we figure out that the current memory region "
"won't work for allocating memory.  All it does is advance &eax; to the next "
"possible memory region, and goes back to the beginning of the loop.  "
"Remember that &edx; is holding the size of the current memory region, and "
"<literal>HEADER_SIZE</literal> is the symbol for the size of the memory "
"region's header.  So this code will move us to the next memory region:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:863
msgid "And now the function runs another loop."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:867
msgid ""
"Whenever you have a loop, you must make sure that it will "
"<emphasis>always</emphasis> end.  The best way to do that is to examine all "
"of the possibilities, and make sure that all of them eventually lead to the "
"loop ending.  In our case, we have the following possibilities:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:875
msgid "We will reach the end of the heap"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:876
msgid "We will find a memory region that's available and large enough"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:877
msgid "We will go to the next location"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:882
msgid ""
"The first two items are conditions that will cause the loop to end.  The "
"third one will keep it going.  However, even if we never find an open "
"region, we will eventually reach the end of the heap, because it is a finite "
"size.  Therefore, we know that no matter which condition is true, the loop "
"has to eventually hit a terminating condition."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../MemoryIntCh.xml:891
#, no-wrap
msgid "The <literal>deallocate</literal> function"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:894
msgid ""
"The <literal>deallocate</literal> function is much easier than the "
"<literal>allocate</literal> one.  That's because it doesn't have to do any "
"searching at all.  It can just mark the current memory region as "
"<literal>AVAILABLE</literal>, and <literal>allocate</literal> will find it "
"next time it is called.  So we have:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:909
msgid ""
"In this function, we don't have to save &ebp-indexed; or &esp-indexed; since "
"we're not changing them, nor do we have to restore them at the end.  All "
"we're doing is reading the address of the memory region from the stack, "
"backing up to the beginning of the header, and marking the region as "
"available.  This function has no return value, so we don't care what we "
"leave in &eax;."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../MemoryIntCh.xml:919
#, no-wrap
msgid "Performance Issues and Other Problems"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:922
msgid ""
"Our simplistic memory manager is not really useful for anything more than an "
"academic exercise.  This section looks at the problems with such a "
"simplistic allocator."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:927
msgid ""
"The biggest problem here is speed.  Now, if there are only a few allocations "
"made, then speed won't be a big issue.  But think about what happens if you "
"make a thousand allocations.  On allocation number 1000, you have to search "
"through 999 memory regions to find that you have to request more memory.  As "
"you can see, that's getting pretty slow.  In addition, remember that Linux "
"can keep pages of memory on disk instead of in memory.  So, since you have "
"to go through every piece of memory your program's memory, that means that "
"Linux has to load every part of memory that's currently on disk to check to "
"see if it is available.  You can see how this could get really, really "
"slow.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><para>
#: ../../MemoryIntCh.xml:934
msgid ""
"This is why adding more memory to your computer makes it run faster.  The "
"more memory your computer has, the less it puts on disk, so it doesn't have "
"to always be interrupting your programs to retreive pages off the disk."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:937
msgid ""
"</footnote> This method is said to run in <emphasis>linear</emphasis> time, "
"which means that every element you have to manage makes your program take "
"longer.  A program that runs in <emphasis>constant</emphasis> time takes the "
"same amount of time no matter how many elements you are managing.  Take the "
"<literal>deallocate</literal> function, for instance.  It only runs 4 "
"instructions, no matter how many elements we are managing, or where they are "
"in memory.  In fact, although our <literal>allocate</literal> function is "
"one of the slowest of all memory managers, the <literal>deallocate</literal> "
"function is one of the fastest."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:948
msgid ""
"Another performance problem is the number of times we're calling the "
"<literal>brk</literal> system call.  System calls take a long time.  They "
"aren't like functions, because the processor has to switch modes.  Your "
"program isn't allowed to map itself memory, but the Linux kernel is.  So, "
"the processor has to switch into <emphasis>kernel mode<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../MemoryIntCh.xml:952
#, no-wrap
msgid "kernel mode"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:952
msgid ""
"</indexterm></emphasis>, then Linux maps the memory, and then switches back "
"to <emphasis>user mode<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../MemoryIntCh.xml:953
#, no-wrap
msgid "user mode"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:953
msgid ""
"</indexterm></emphasis> for your application to continue running.  This is "
"also called a <emphasis>context switch<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../MemoryIntCh.xml:955
#, no-wrap
msgid "context switch"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:955
msgid ""
"</indexterm></emphasis>.  Context switches are relatively slow on x86 "
"processors.  Generally, you should avoid calling the kernel unless you "
"really need to."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:961
msgid ""
"Another problem that we have is that we aren't recording where Linux "
"actually sets the break.  Previously we mentioned that Linux might actually "
"set the break past where we requested it.  In this program, we don't even "
"look at where Linux actually sets the break - we just assume it sets it "
"where we requested.  That's not really a bug, but it will lead to "
"unnecessary <literal>brk</literal> system calls when we already have the "
"memory mapped in."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../MemoryIntCh.xml:969
msgid ""
"Another problem we have is that if we are looking for a 5-byte region of "
"memory, and the first open one we come to is 1000 bytes, we will simply mark "
"the whole thing as allocated and return it.  This leaves 995 bytes of "
"unused, but allocated, memory.  It would be nice in such situations to break "
"it apart so the other 995 bytes can be used later.  It would also be nice to "
"combine consecutive free spaces when looking for large allocations."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../MemoryIntCh.xml:982
#, no-wrap
msgid "Using our Allocator"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:985
msgid ""
"The programs we do in this book aren't complicated enough to necessitate a "
"memory manager.  Therefore, we will just use our memory manager to allocate "
"a buffer for one of our file reading/writing programs instead of assigning "
"it in the <literal>.bss</literal>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:992
msgid ""
"The program we will demonstrate this on is "
"<filename>read-records.s</filename> from <xref linkend=\"records\" />.  This "
"program uses a buffer named <literal>record_buffer</literal> to handle its "
"input/output needs.  We will simply change this from being a buffer defined "
"in <literal>.bss</literal> to being a pointer to a dynamically-allocated "
"buffer using our memory manager.  You will need to have the code from that "
"program handy as we will only be discussing the changes in this section."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1001
msgid ""
"The first change we need to make is in the declaration.  Currently it looks "
"like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1010
msgid ""
"It would be a misnomer to keep the same name, since we are switching it from "
"being an actual buffer to being a pointer to a buffer.  In addition, it now "
"only needs to be one word big (enough to hold a pointer).  The new "
"declaration will stay in the <literal>.data</literal> section and look like "
"this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1022
msgid ""
"Our next change is we need to initialize our memory manager immediately "
"after we start our program.  Therefore, right after the stack is set up, the "
"following call needs to be added:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1032
msgid ""
"After that, the memory manager is ready to start servicing memory allocation "
"requests.  We need to allocate enough memory to hold these records that we "
"are reading.  Therefore, we will call <literal>allocate</literal> to "
"allocate this memory, and then save the pointer it returns into "
"<literal>record_buffer_ptr</literal>.  Like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1045
msgid ""
"Now, when we make the call to <literal>read_record</literal>, it is "
"expecting a pointer.  In the old code, the pointer was the immediate-mode "
"reference to <literal>record_buffer</literal>.  Now, "
"<literal>record_buffer_ptr</literal> just holds the pointer rather than the "
"buffer itself.  Therefore, we must do a direct mode load to get the value in "
"<literal>record_buffer_ptr</literal>.  We need to remove this line:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1057
msgid "And put this line in its place:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1065
msgid ""
"The next change comes when we are trying to find the address of the "
"firstname field of our record.  In the old code, it was "
"<literal>$RECORD_FIRSTNAME + record_buffer</literal>.  However, that only "
"works because it is a constant offset from a constant address.  In the new "
"code, it is the offset of an address stored in "
"<literal>record_buffer_ptr</literal>.  To get that value, we will need to "
"move the pointer into a register, and then add "
"<literal>$RECORD_FIRSTNAME</literal> to it to get the pointer.  So where we "
"have the following code:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1080
msgid "We need to replace it with this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1090
msgid "Similarly, we need to change the line that says"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1098
msgid "so that it reads like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1107
msgid ""
"Finally, one change that we need to make is to deallocate the memory once we "
"are done with it (in this program it's not necessary, but it's a good "
"practice anyway).  To do that, we just send "
"<literal>record_buffer_ptr</literal> to the <literal>deallocate</literal> "
"function right before exitting:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1119
msgid "Now you can build your program with the following commands:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1128
msgid "You can then run your program by doing <literal>./read-records</literal>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1132
msgid ""
"The uses of dynamic memory allocation may not be apparent to you at this "
"point, but as you go from academic exercises to real-life programs you will "
"use it continually."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../MemoryIntCh.xml:1139
#, no-wrap
msgid "More Information"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../MemoryIntCh.xml:1142
msgid ""
"More information on memory handling in Linux and other operating systems can "
"be found at the following locations:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1147
msgid ""
"More information about the memory layout of Linux programs can be found in "
"Konstantin Boldyshev's document, \"Startup state of a Linux/i386 ELF "
"binary\", available at http://linuxassembly.org/startup.html"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1148
msgid ""
"A good overview of virtual memory in many different systems is available at "
"http://cne.gmu.edu/modules/vm/"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1149
msgid ""
"Several in-depth articles on Linux's virtual memory subsystem is available "
"at http://www.nongnu.org/lkdp/files.html"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1150
msgid ""
"Doug Lea has written up a description of his popular memory allocator at "
"http://gee.cs.oswego.edu/dl/html/malloc.html"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1151
msgid ""
"A paper on the 4.4 BSD memory allocator is available at "
"http://docs.freebsd.org/44doc/papers/malloc.html"
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../MemoryIntCh.xml:1157
#, no-wrap
msgid "Review"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../MemoryIntCh.xml:1160
#, no-wrap
msgid "Know the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1163
msgid "Describe the layout of memory when a Linux program starts."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1164
msgid "What is the heap?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1165
msgid "What is the current break?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1166
msgid "Which direction does the stack grow in?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1167
msgid "Which direction does the heap grow in?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1168
msgid "What happens when you access unmapped memory?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1169
msgid ""
"How does the operating system prevent processes from writing over each "
"other's memory?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1170
msgid ""
"Describe the process that occurs if a piece of memory you are using is "
"currently residing on disk?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1171
msgid "Why do you need an allocator?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../MemoryIntCh.xml:1177
#, no-wrap
msgid "Use the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1180
msgid ""
"Modify the memory manager so that it calls <literal>allocate_init</literal> "
"automatically if it hasn't been initialized."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1181
msgid ""
"Modify the memory manager so that if the requested size of memory is smaller "
"than the region chosen, it will break up the region into multiple parts.  Be "
"sure to take into account the size of the new header record when you do "
"this."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1182
msgid ""
"Modify one of your programs that uses buffers to use the memory manager to "
"get buffer memory rather than using the <literal>.bss</literal>."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../MemoryIntCh.xml:1188
#, no-wrap
msgid "Going Further"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1191
msgid ""
"Research <emphasis>garbage collection</emphasis>.  What advantages and "
"disadvantages does this have over the style of memory management used here?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1192
msgid ""
"Research <emphasis>reference counting</emphasis>.  What advantages and "
"disadvantages does this have over the style of memory management used here?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../MemoryIntCh.xml:1193
msgid ""
"Change the name of the functions to <literal>malloc</literal> and "
"<literal>free</literal>, and build them into a shared library.  Use "
"<literal>LD_PRELOAD</literal> to force them to be used as your memory "
"manager instead of the default one.  Add some <literal>write</literal> "
"system calls to STDOUT to verify that your memory manager is being used "
"instead of the default one."
msgstr ""
