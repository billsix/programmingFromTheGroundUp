# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2006-05-15 16:00+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING"

# type: Content of: <chapter><sect1><sect2><title>
#: ../../CountingCh.xml:4 ../../CountingCh.xml:69
#, no-wrap
msgid "Counting Like a Computer"
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../CountingCh.xml:18
#, no-wrap
msgid "Counting"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../CountingCh.xml:21
#, no-wrap
msgid "Counting Like a Human"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:24
msgid ""
"In many ways, computers count just like humans.  So, before we start "
"learning how computers count, let's take a deeper look at how we count."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:30
msgid ""
"How many fingers do you have? No, it's not a trick question.  Humans "
"(normally) have ten fingers.  Why is that significant? Look at our numbering "
"system.  At what point does a one-digit number become a two-digit number? "
"That's right, at ten.  Humans count and do math using a base ten numbering "
"system.  Base ten means that we group everything in tens.  Let's say we're "
"counting sheep.  1, 2, 3, 4, 5, 6, 7, 8, 9, 10.  Why did we all of a sudden "
"now have two digits, and re-use the 1? That's because we're grouping our "
"numbers by ten, and we have 1 group of ten sheep.  Okay, let's go to the "
"next number 11.  That means we have 1 group of ten sheep, and 1 sheep left "
"ungrouped.  So we continue - 12, 13, 14, 15, 16, 17, 18, 19, 20.  Now we "
"have 2 groups of ten.  21 - 2 groups of ten, and 1 sheep ungrouped.  22 - 2 "
"groups of ten, and 2 sheep ungrouped.  So, let's say we keep counting, and "
"get to 97, 98, 99, and 100.  Look, it happened again! What happens at 100? "
"We now have ten groups of ten.  At 101 we have ten groups of ten, and 1 "
"ungrouped sheep.  So we can look at any number like this.  If we counted "
"60879 sheep, that would mean that we had 6 groups of ten groups of ten "
"groups of ten groups of ten, 0 groups of ten groups of ten groups of ten, 8 "
"groups of ten groups of ten, 7 groups of ten, and 9 sheep left ungrouped."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:53
msgid ""
"So, is there anything significant about grouping things by ten? No! It's "
"just that grouping by ten is how we've always done it, because we have ten "
"fingers.  We could have grouped at nine or at eleven (in which case we would "
"have had to make up a new symbol).  The only difference between the "
"different groupings of numbers is that we have to re-learn our "
"multiplication, addition, subtraction, and division tables for each "
"grouping.  The rules haven't changed, just the way we represent them.  Also, "
"some of our tricks that we learned don't always apply, either.  For example, "
"let's say we grouped by nine instead of ten.  Moving the decimal point one "
"digit to the right no longer multiplies by ten, it now multiplies by nine.  "
"In base nine, 500 is only nine times as large as 50."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:72
msgid ""
"The question is, how many fingers does the computer have to count with? The "
"computer only has two fingers.  So that means all of the groups are groups "
"of two.  So, let's count in binary - 0 (zero), 1 (one), 10 (two - one group "
"of two), 11 (three - one group of two and one left over), 100 (four - two "
"groups of two), 101 (five - two groups of two and one left over), 110 (six - "
"two groups of two and one group of two), and so on.  In base two, moving the "
"decimal one digit to the right multiplies by two, and moving it to the left "
"divides by two.  Base two<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:79 ../../CountingCh.xml:144
#, no-wrap
msgid "base two"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:79
msgid "</indexterm> is also referred to as binary."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:84
msgid ""
"The nice thing about base two is that the basic math tables are very short.  "
"In base ten, the multiplication tables are ten columns wide, and ten columns "
"tall.  In base two, it is very simple:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:109
msgid "So, let's add the numbers 10010101 with 1100101:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:118
msgid "Now, let's multiply them:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../CountingCh.xml:141
#, no-wrap
msgid "Conversions Between Binary and Decimal"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:144
msgid "Let's learn how to convert numbers from binary<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:144 ../../CountingCh.xml:200 ../../CountingCh.xml:902
#, no-wrap
msgid "binary"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:144
msgid "</indexterm> (base two<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:144
msgid "</indexterm>) to decimal<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:145 ../../CountingCh.xml:200 ../../CountingCh.xml:902
#, no-wrap
msgid "decimal"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:145
msgid "</indexterm> (base ten<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:145
#, no-wrap
msgid "base ten"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:145
msgid ""
"</indexterm>).  This is actually a rather simple process.  If you remember, "
"each digit<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:146
#, no-wrap
msgid "digit"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:146
msgid ""
"</indexterm> stands for some grouping of two.  So, we just need to add up "
"what each digit represents, and we will have a decimal number.  Take the "
"binary number 10010101.  To find out what it is in decimal, we take it apart "
"like this:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:164
msgid "and then we add all of the pieces together, like this:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:172
msgid ""
"So 10010101 in binary is 149 in decimal.  Let's look at 1100101.  It can be "
"written as"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:181
msgid ""
"So we see that 1100101 in binary is 101 in decimal.  Let's look at one more "
"number, 11101011001001.  You can convert it to decimal by doing"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:194
msgid ""
"Now, if you've been paying attention, you have noticed that the numbers we "
"just converted are the same ones we used to multiply with earlier.  So, "
"let's check our results: 101 * 149 = 15049.  It worked!"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:200
msgid "Now let's look at going from decimal<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:200
msgid "</indexterm> back to binary<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:200
msgid ""
"</indexterm>.  In order to do the conversion, you have to "
"<emphasis>divide</emphasis> the number into groups of two.  So, let's say "
"you had the number 17.  If you divide it by two, you get 8 with 1 left "
"over.  So that means there are 8 groups of two, and 1 ungrouped.  That means "
"that the rightmost digit will be 1.  Now, we have the rigtmost digit figured "
"out, and 8 groups of 2 left over.  Now, let's see how many groups of two "
"groups of two we have, by dividing 8 by 2.  We get 4, with nothing left "
"over.  That means that all groups two can be further divided into more "
"groups of two.  So, we have 0 groups of only two.  So the next digit to the "
"left is 0.  So, we divide 4 by 2 and get two, with 0 left over, so the next "
"digit is 0.  Then, we divide 2 by 2 and get 1, with 0 left over.  So the "
"next digit is 0.  Finally, we divide 1 by 2 and get 0 with 1 left over, so "
"the next digit to the left is 1.  Now, there's nothing left, so we're done.  "
"So, the number we wound up with is 10001."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:218
msgid ""
"Previously, we converted to binary 11101011001001 to decimal 15049.  Let's "
"do the reverse to make sure that we did it right:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:238
msgid ""
"Then, we put the remaining numbers back together, and we have the original "
"number! Remember the first division remainder goes to the far right, so from "
"the bottom up you have 11101011001001."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:244
msgid "Each digit in a binary number is called a <emphasis>bit<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:244 ../../CountingCh.xml:281 ../../CountingCh.xml:995
#, no-wrap
msgid "bits"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:244
msgid "</indexterm></emphasis>, which stands for <emphasis>binary digit<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:245
#, no-wrap
msgid "binary digit"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:245
msgid ""
"</indexterm></emphasis>.  Remember, computers divide up their memory into "
"storage locations called bytes<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:246 ../../CountingCh.xml:867 ../../CountingCh.xml:954 ../../CountingCh.xml:995
#, no-wrap
msgid "bytes"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:246
msgid ""
"</indexterm>.  Each storage location on an x86 processor (and most others) "
"is 8 bits long.  Earlier we said that a byte can hold any number between 0 "
"and 255.  The reason for this is that the largest number you can fit into 8 "
"bits is 255.  You can see this for yourself if you convert binary 11111111 "
"into decimal:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:262
msgid ""
"The largest number that you can hold in 16 bits is 65535.  The largest "
"number you can hold in 32 bits is 4294967295 (4 billion).  The largest "
"number you can hold in 64 bits is 18,446,744,073,709,551,615.  The largest "
"number you can hold in 128 bits is "
"340,282,366,920,938,463,463,374,607,431,768,211,456.  Anyway, you see the "
"picture.  For x86 processors, most of the time you will deal with 4-byte "
"numbers (32 bits), because that's the size of the registers<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:268 ../../CountingCh.xml:996
#, no-wrap
msgid "registers"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:268
msgid "</indexterm>."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../CountingCh.xml:276
#, no-wrap
msgid "Truth, Falsehood, and Binary Numbers"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:279
msgid ""
"Now we've seen that the computer stores everything as sequences of 1's and "
"0's.  Let's look at some other uses of this.  What if, instead of looking at "
"a sequence of bits<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:281
msgid ""
"</indexterm> as a number, we instead looked at it as a set of "
"switches<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:282
#, no-wrap
msgid "switches"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:282
msgid ""
"</indexterm>.  For example, let's say there are four switches that control "
"lighting in the house.  We have a switch for outside lights, a switch for "
"the hallway lights, a switch for the living room lights, and a switch for "
"the bedroom lights.  We could make a little table showing which of these "
"were on and off, like so:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:293
msgid ""
"It's obvious from looking at this that all of the lights are on except the "
"hallway ones.  Now, instead of using the words \"On\" and \"Off\", let's use "
"the numbers 1 and 0.  1 will represent on, and 0 will represent off.  So, we "
"could represent the same information as"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:303
msgid ""
"Now, instead of having labels on the light switches, let's say we just "
"memorized which position went with which switch.  Then, the same information "
"could be represented as"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:311
msgid "or as"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:317
msgid ""
"This is just one of many ways you can use the computers storage locations to "
"represent more than just numbers.  The computers memory just sees numbers, "
"but programmers can use these numbers to represent anything their "
"imaginations can come up with.  They just sometimes have to be creative when "
"figuring out the best representation."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:325
msgid ""
"Not only can you do regular arithmetic with binary numbers, they also have a "
"few operations of their own, called binary <indexterm "
"zone=\"truthbinarynumbers\">"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:327
#, no-wrap
msgid "binary operations"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:327
msgid "</indexterm> or logical operations <indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:329
#, no-wrap
msgid "logical operations"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:329
msgid "</indexterm>.  The standard binary operations are"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:334
msgid "AND<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:334 ../../CountingCh.xml:370 ../../CountingCh.xml:500 ../../CountingCh.xml:580
#, no-wrap
msgid "AND"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:334 ../../CountingCh.xml:335 ../../CountingCh.xml:336 ../../CountingCh.xml:337
msgid "</indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:335
msgid "OR<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:335 ../../CountingCh.xml:381 ../../CountingCh.xml:690
#, no-wrap
msgid "OR"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:336
msgid "NOT<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para><primary>
#: ../../CountingCh.xml:336 ../../CountingCh.xml:391 ../../CountingCh.xml:847
#, no-wrap
msgid "NOT"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:337
msgid "XOR<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:337 ../../CountingCh.xml:399 ../../CountingCh.xml:434 ../../CountingCh.xml:525
#, no-wrap
msgid "XOR"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:341
msgid ""
"Before we look at examples, I'll describe them for you.  AND takes two bits "
"and returns one bit.  AND will return a 1 only if both bits are 1, and a 0 "
"otherwise.  For example, 1 AND 1 is 1, but 1 AND 0 is 0, 0 AND 1 is 0, and 0 "
"AND 0 is 0."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:348
msgid ""
"OR takes two bits and returns one bit.  It will return 1 if either of the "
"original bits is 1.  For example, 1 OR 1 is 1, 1 OR 0 is one, 0 OR 1 is 1, "
"but 0 OR 0 is 0."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:355
msgid "NOT only takes one bit and returns its opposite.  NOT 1 is 0 and NOT 0 is 1."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:360
msgid "Finally, XOR is like OR, except it returns 0 if both bits are 1."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:365
msgid ""
"Computers can do these operations on whole registers at a time.  For "
"example, if a register has 10100010101010010101101100101010 and another one "
"has 10001000010101010101010101111010, you can run any of these operations on "
"the whole registers.  For example, if we were to AND them, the computer will "
"run from the first bit to the 32nd and run the AND<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:370
msgid "</indexterm> operation on that bit in both registers.  In this case:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:379
msgid ""
"You'll see that the resulting set of bits only has a one where "
"<emphasis>both</emphasis> numbers had a one, and in every other position it "
"has a zero.  Let's look at what an OR<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:381
msgid "</indexterm> looks like:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:390
msgid ""
"In this case, the resulting number has a 1 where either number has a 1 in "
"the given position.  Let's look at the NOT<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:391
msgid "</indexterm> operation:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:399
msgid "This just reverses each digit.  Finally, we have XOR<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:399
msgid ""
"</indexterm>, which is like an OR, except if <emphasis>both</emphasis> "
"digits are 1, it returns 0."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:410
msgid ""
"This is the same two numbers used in the OR operation, so you can compare "
"how they work.  Also, if you XOR a number with itself, you will always get "
"0, like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:424
msgid "These operations are useful for two reasons:"
msgstr ""

# type: Content of: <chapter><sect1><para><itemizedlist><listitem><para>
#: ../../CountingCh.xml:427
msgid "The computer can do them extremely fast"
msgstr ""

# type: Content of: <chapter><sect1><para><itemizedlist><listitem><para>
#: ../../CountingCh.xml:428
msgid "You can use them to compare many truth values at the same time"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:431
msgid ""
"You may not have known that different instructions execute at different "
"speeds.  It's true, they do.  And these operations are the fastest on most "
"processors.  For example, you saw that XORing a number with itself produces "
"0.  Well, the XOR<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:434
msgid ""
"</indexterm> operation is faster than the loading operation, so many "
"programmers use it to load a register<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:435 ../../CountingCh.xml:1036
#, no-wrap
msgid "register"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:435
msgid "</indexterm> with zero.  For example, the code"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:442
msgid "is often replaced by"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:448
msgid ""
"We'll discuss speed more in <xref linkend=\"optimizationch\" />, but I want "
"you to see how programmers often do tricky things, especially with these "
"binary operators, to make things fast.  Now let's look at how we can use "
"these operators to manipulate true<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:451
#, no-wrap
msgid "true"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:451
msgid "</indexterm>/false<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:451
#, no-wrap
msgid "false"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:451
msgid ""
"</indexterm> values.  Earlier we discussed how binary numbers can be used to "
"represent any number of things.  Let's use binary numbers to represent what "
"things my Dad and I like.  First, let's look at the things I like:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:463
msgid "Now, let's look at what my Dad likes:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:472
msgid ""
"Now, let's use a 1 to say yes we like something, and a 0 to say no we "
"don't.  Now we have:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:489
msgid "Now, if we just memorize which position each of these are in, we have"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:499
msgid ""
"Now, let's see we want to get a list of things both my Dad and I like.  You "
"would use the AND<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:500
msgid "</indexterm> operation.  So"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:509
msgid "Which translates to"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:519
msgid ""
"Remember, the computer has no idea what the ones and zeroes represent.  "
"That's your job and your program's job.  If you wrote a program around this "
"representation your program would at some point examine each bit and have "
"code to tell the user what it's for (if you asked a computer what two people "
"agreed on and it answered 1001, it wouldn't be very useful).  Anyway, let's "
"say we want to know the things that we disagree on.  For that we would use "
"XOR<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:525
msgid ""
"</indexterm>, because it will return 1 only if one or the other is 1, but "
"not both.  So"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:535
msgid "And I'll let you translate that back out."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:539
msgid ""
"The previous operations: AND, OR, NOT, and XOR are called <emphasis>boolean "
"operators<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:540 ../../CountingCh.xml:542
#, no-wrap
msgid "boolean operators"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:540
msgid ""
"</indexterm></emphasis> because they were first studied by George Boole.  "
"So, if someone mentiones boolean operators<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:542
msgid "</indexterm> or boolean algebra<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:543
#, no-wrap
msgid "boolean algebra"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:543
msgid "</indexterm>, you now know what they are talking about."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:548
msgid ""
"In addition to the boolean operations, there are also two binary "
"operators<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:549
#, no-wrap
msgid "binary operators"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:549
msgid "</indexterm> that aren't boolean, shift<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:549
#, no-wrap
msgid "shift"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:549
msgid "</indexterm> and rotate<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:549
#, no-wrap
msgid "rotate"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:549
msgid ""
"</indexterm>.  Shifts and rotates each do what their name implies, and can "
"do so to the right or the left.  A left shift moves each digit of a binary "
"number one space to the left, puts a zero in the ones spot, and chops off "
"the furthest digit to the left.  A left rotate does the same thing, but "
"takes the furthest digit to the left and puts it in the ones spot.  For "
"example,"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:562
msgid ""
"Notice that if you rotate a number for every digit it has (i.e. - rotating a "
"32-bit number 32 times), you wind up with the same number you started with.  "
"However, if you <emphasis>shift</emphasis> a number for every digit you "
"have, you wind up with 0.  So, what are these shifts useful for? Well, if "
"you have binary numbers representing things, you use shifts to peek at each "
"individual value.  Let's say, for instance, that we had my Dad's likes "
"stored in a register (32 bits).  It would look like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:574
msgid ""
"Now, as we said previously, this doesn't work as program output.  So, in "
"order to do output, we would need to do shifting<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:575
#, no-wrap
msgid "shifting"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:575
msgid "</indexterm> and <emphasis>masking<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:576
#, no-wrap
msgid "masking"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:576
msgid ""
"</indexterm></emphasis>.  Masking is the process of eliminating everything "
"you don't want.  In this case, for every value we are looking for, we will "
"shift the number so that value is in the ones place, and then mask that "
"digit so that it is all we see.  Masking is accomplished by doing an "
"AND<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:580
msgid ""
"</indexterm> with a number that has the bits we are interested in set to 1.  "
"For example, let's say we wanted to print out whether my Dad likes dressy "
"clothes or not.  That data is the second value from the right.  So, we have "
"to shift the number right 1 digit so it looks like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:591
msgid ""
"and then, we just want to look at that digit, so we mask it by ANDing it "
"with 00000000000000000000000000000001."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:601
msgid ""
"This will make the value of the register 1 if my Dad likes dressy clothes, "
"and 0 if he doesn't.  Then we can do a comparison to 1 and print the "
"results.  The code would look like this:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:628
msgid ""
"And then we would have two labels which printed something about whether or "
"not he likes dressy clothes and then exits.  The <literal>0b</literal> "
"notation means that what follows is a binary number<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:630
#, no-wrap
msgid "binary number"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:630
msgid ""
"</indexterm>.  In this case it wasn't needed, because 1 is the same in any "
"numbering system, but I put it there for clarity.  We also didn't need the "
"31 zeroes, but I put them in to make a point that the number you are using "
"is 32 bits."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:638
msgid "When a number represents a set of options for a function<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:638
#, no-wrap
msgid "functions"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:638
msgid "</indexterm> or system call<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:638
#, no-wrap
msgid "system call"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:638
msgid ""
"</indexterm>, the individual true/false elements are called "
"<emphasis>flags<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:639
#, no-wrap
msgid "flags"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:639
msgid ""
"</indexterm></emphasis>.  Many system calls have numerous options that are "
"all set in the same register using a mechanism like we've described.  The "
"<literal>open<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:642
#, no-wrap
msgid "open"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:642
msgid ""
"</indexterm></literal> system call, for example, has as its second parameter "
"a list of flags to tell the operating system how to open the file.  Some of "
"the flags include:"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../CountingCh.xml:651
#, no-wrap
msgid "<literal>O_WRONLY<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../CountingCh.xml:651
#, no-wrap
msgid "O_WRONLY"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../CountingCh.xml:651 ../../CountingCh.xml:658 ../../CountingCh.xml:665 ../../CountingCh.xml:673 ../../CountingCh.xml:681
#, no-wrap
msgid "</indexterm></literal>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../CountingCh.xml:653
msgid ""
"This flag is <literal>0b00000000000000000000000000000001</literal> in "
"binary, or <literal>01</literal> in octal (or any number system for that "
"matter).  This says to open the file in write-only mode."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../CountingCh.xml:658
#, no-wrap
msgid "<literal>O_RDWR<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../CountingCh.xml:658
#, no-wrap
msgid "O_RDWR"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../CountingCh.xml:660
msgid ""
"This flag is <literal>0b00000000000000000000000000000010</literal> in "
"binary, or <literal>02</literal> in octal.  This says to open the file for "
"both reading and writing."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../CountingCh.xml:665
#, no-wrap
msgid "<literal>O_CREAT<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../CountingCh.xml:665
#, no-wrap
msgid "O_CREAT"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../CountingCh.xml:667
msgid ""
"This flag is <literal>0b00000000000000000000000001000000</literal> in "
"binary, or <literal>0100</literal> in octal.  It means to create the file if "
"it doesn't already exist."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../CountingCh.xml:673
#, no-wrap
msgid "<literal>O_TRUNC<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../CountingCh.xml:673
#, no-wrap
msgid "O_TRUNC"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../CountingCh.xml:675
msgid ""
"This flag is <literal>0b00000000000000000000001000000000</literal> in "
"binary, or <literal>01000</literal> in octal.  It means to erase the "
"contents of the file if the file already exists."
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term>
#: ../../CountingCh.xml:681
#, no-wrap
msgid "<literal>O_APPEND<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><term><primary>
#: ../../CountingCh.xml:681
#, no-wrap
msgid "O_APPEND"
msgstr ""

# type: Content of: <chapter><sect1><variablelist><varlistentry><listitem><para>
#: ../../CountingCh.xml:683
msgid ""
"This flag is <literal>0b00000000000000000000010000000000</literal> in "
"binary, or <literal>02000</literal> in octal.  It means to start writing at "
"the end of the file rather than at the beginning."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:690
msgid "To use these flags, you simply OR<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:690
msgid ""
"</indexterm> them together in the combination that you want.  For example, "
"to open a file in write-only mode, and have it create the file if it doesn't "
"exist, I would use <literal>O_WRONLY</literal> (01) and "
"<literal>O_CREAT</literal> (0100).  OR'd together, I would have 0101."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:697
msgid ""
"Note that if you don't set either <literal>O_WRONLY</literal> or "
"<literal>O_RDWR</literal>, then the file is automatically opened in "
"read-only mode (<literal>O_RDONLY</literal>, except that it isn't really a "
"flag since it's zero)."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:701
msgid ""
"Many functions and system calls use flags for options, as it allows a single "
"word to hold up to 32 possible options if each option is represented by a "
"single bit."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../CountingCh.xml:709
#, no-wrap
msgid "The Program Status Register"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:712
msgid ""
"We've seen how bits on a register can be used to give the answers of yes/no "
"and true/false statements.  On your computer, there is a register called the "
"<emphasis>program status register<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:714
#, no-wrap
msgid "program status register"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:714
msgid ""
"</indexterm></emphasis>.  This register holds a lot of information about "
"what happens in a computation.  For example, have you ever wondered what "
"would happen if you added two numbers and the result was larger than would "
"fit in a register? The program status register has a flag called the carry "
"flag<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:718
#, no-wrap
msgid "carry flag"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:718
msgid ""
"</indexterm>.  You can test it to see if the last computation overflowed the "
"register.  There are flags for a number of different statuses.  In fact, "
"when you do a compare (<literal>cmpl<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:721
#, no-wrap
msgid "cmpl"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:721
msgid ""
"</indexterm></literal>) instruction, the result is stored in this register.  "
"The conditional jump<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:722
#, no-wrap
msgid "conditional jump"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:722
msgid ""
"</indexterm> instructions (<literal>jge</literal>, <literal>jne</literal>, "
"etc) use these results to tell whether or not they should jump.  "
"<literal>jmp<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:724
#, no-wrap
msgid "jmp"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:724
msgid "</indexterm></literal>, the unconditional jump<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:725
#, no-wrap
msgid "unconditional jump"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:725
msgid ""
"</indexterm>, doesn't care what is in the status register, since it is "
"unconditional."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:730
msgid ""
"Let's say you needed to store a number larger than 32 bits.  So, let's say "
"the number is 2 registers wide, or 64 bits.  How could you handle this? If "
"you wanted to add two 64 bit numbers, you would add the least significant "
"registers first.  Then, if you detected an carry, you could add 1 to the "
"most significant register.  In fact, this is probably the way you learned to "
"do decimal addition.  If the result in one column is more than 9, you simply "
"carried the number to the next most significant column.  If you added 65 and "
"37, first you add 7 and 4 to get 12.  You keep the 2 in the right column, "
"and carry the one to the next column.  There you add 6, 3, and the 1 you "
"carried.  This results in 10.  So, you keep the zero in that column and "
"carry the one to the next most significant column, which is empty, so you "
"just put the one there.  Luckily, 32 bits is usually big enough to hold the "
"numbers we use regularly."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:747
msgid ""
"Additional program status register flags are examined in <xref "
"linkend=\"instructionsappendix\" />."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../CountingCh.xml:754
#, no-wrap
msgid "Other Numbering Systems"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:757
msgid ""
"What we have studied so far only applies to positive integers.  However, "
"real-world numbers are not always positive integers.  Negative numbers and "
"numbers with decimals are also used."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../CountingCh.xml:763
#, no-wrap
msgid "Floating-point Numbers"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:766
msgid ""
"So far, the only numbers we've dealt with are integers - numbers with no "
"decimal point.  Computers have a general problem with numbers with decimal "
"points, because computers can only store fixed-size, finite values.  Decimal "
"numbers can be any length, including infinite length (think of a repeating "
"decimal, like the result of 1 / 3)."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:775
msgid ""
"The way a computer handles decimals is by storing them at a fixed "
"precision<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:776
#, no-wrap
msgid "precision"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:776
msgid ""
"</indexterm> (number of significant bits).  A computer stores decimal "
"numbers in two parts - the <emphasis>exponent<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:778
#, no-wrap
msgid "exponent"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:778
msgid "</indexterm></emphasis> and the <emphasis>mantissa<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:778
#, no-wrap
msgid "mantissa"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:778
msgid ""
"</indexterm></emphasis>.  The mantissa contains the actual digits that will "
"be used, and the exponent is what magnitude the number is.  For example, "
"12345.2 can be represented as 1.23452 * 10^4.  The mantissa is 1.23452 and "
"the exponent is 4 with a base of 10.  Computers, however, use a base of 2.  "
"All numbers are stored as X.XXXXX * 2^XXXX.  The number 1, for example, is "
"stored as 1.00000 * 2^0.  Separating the mantissa and the exponent into two "
"different values is called a <emphasis>floating point</emphasis><indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:785
#, no-wrap
msgid "floating point"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:785
msgid ""
"</indexterm> representation, because the position of the significant digits "
"with respect to the decimal point can vary based on the exponent."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:789
msgid ""
"Now, the mantissa and the exponent are only so long, which leads to some "
"interesting problems.  For example, when a computer stores an integer, if "
"you add 1 to it, the resulting number is one larger.  This does not "
"necessarily happen with floating point numbers.  If the number is "
"sufficiently big, adding 1 to it might not even register in the mantissa "
"(remember, both parts are only so long).  This affects several things, "
"especially order of operations.  If you add 1.0 to a given floating point "
"number, it might not even affect the number if it is large enough.  For "
"example, on x86 platforms, a four-byte floating-point number, although it "
"can represent very large numbers, cannot have 1.0 added to it past "
"16777216.0, because it is no longer significant.  The number no longer "
"changes when 1.0 is added to it.  So, if there is a multiplication followed "
"by an addition it may give a different result than if the addition is "
"performed first."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:806
msgid ""
"You should note that it takes most computers a lot longer to do "
"floating-point arithmetic than it does integer arithmetic.  So, for programs "
"that really need speed, integers are mostly used."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../CountingCh.xml:821
#, no-wrap
msgid "Negative Numbers"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:824
msgid "How would you think that negative numbers<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:824
#, no-wrap
msgid "negative numbers"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:824
msgid ""
"</indexterm> on a computer might be represented? One thought might be to use "
"the first digit of a number as the sign<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:826 ../../CountingCh.xml:862
#, no-wrap
msgid "sign"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:826
msgid ""
"</indexterm>, so <literal>00000000000000000000000000000001</literal> would "
"represent the number 1, and "
"<literal>10000000000000000000000000000001</literal> would represent -1.  "
"This makes a lot of sense, and in fact some old processors work this way.  "
"However, it has some problems.  First of all, it takes a lot more circuitry "
"to add and subtract signed numbers represented this way.  Even more "
"problematic, this representation has a problem with the number 0.  In this "
"system, you could have both a negative and a positive 0.  This leads to a "
"lot of questions, like \"should negative zero be equal to positive zero?\", "
"and \"What should the sign of zero be in various circumstances?\"."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:839
msgid ""
"These problems were overcome by using a representation of negative numbers "
"called <emphasis>two's complement<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:841 ../../CountingCh.xml:872
#, no-wrap
msgid "two's complement"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:841
msgid ""
"</indexterm></emphasis> representation.  To get the negative representation "
"of a number in two's complement form, you must perform the following steps:"
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../CountingCh.xml:847
msgid "Perform a NOT<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../CountingCh.xml:847
msgid "</indexterm> operation on the number"
msgstr ""

# type: Content of: <chapter><sect1><sect2><orderedlist><listitem><para>
#: ../../CountingCh.xml:848
msgid "Add one to the resulting number"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:852
msgid ""
"So, to get the negative of "
"<literal>00000000000000000000000000000001</literal>, you would first do a "
"NOT operation, which gives "
"<literal>11111111111111111111111111111110</literal>, and then add one, "
"giving <literal>11111111111111111111111111111111</literal>.  To get negative "
"two, first take <literal>00000000000000000000000000000010</literal>.  The "
"NOT of that number is <literal>11111111111111111111111111111101</literal>.  "
"Adding one gives <literal>11111111111111111111111111111110</literal>.  With "
"this representation, you can add numbers just as if they were positive, and "
"come out with the right answers.  For example, if you add one plus negative "
"one in binary, you will notice that all of the numbers flip to zero.  Also, "
"the first digit still carries the sign<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:862
msgid ""
"</indexterm> bit, making it simple to determine whether or not the number is "
"positive or negative.  Negative numbers will always have a "
"<literal>1</literal> in the leftmost bit.  This also changes which numbers "
"are valid for a given number of bits.  With signed numbers, the possible "
"magnitude of the values is split to allow for both positive and negative "
"numbers.  For example, a byte<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:867
msgid ""
"</indexterm> can normally have values up to 255.  A signed byte, however, "
"can store values from -128 to 127."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:872
msgid "One thing to note about the two's complement<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:872
msgid "</indexterm> representation of signed numbers<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:872
#, no-wrap
msgid "signed numbers"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:872
msgid ""
"</indexterm> is that, unlike unsigned quantities, if you increase the number "
"of bits, you can't just add zeroes to the left of the number.  For example, "
"let's say we are dealing with four-bit quantities and we had the number -3, "
"<literal>1101</literal>.  If we were to extend this into an eight-bit "
"register, we could not represent it as <literal>00001101</literal> as this "
"would represent 13, not -3.  When you increase the size of a signed quantity "
"in two's complement representation, you have to perform <emphasis>sign "
"extension<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:879
#, no-wrap
msgid "sign extension"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:879
msgid ""
"</indexterm></emphasis>.  Sign extension means that you have to pad the "
"left-hand side of the quantity with whatever digit is in the sign digit when "
"you add bits.  So, if we extend a negative number by 4 digits, we should "
"fill the new digits with a 1.  If we extend a positive number by 4 digits, "
"we should fill the new digits with a 0.  So, the extension of -3 from four "
"to eight bits will yield <literal>11111101</literal>."
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:888
msgid ""
"The x86 processor has different forms of several instructions depending on "
"whether they expect the quantities they operate on to be signed<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:889
#, no-wrap
msgid "signed"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:889
msgid "</indexterm> or unsigned<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:889
#, no-wrap
msgid "unsigned"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:889
msgid ""
"</indexterm>.  These are listed in <xref linkend=\"instructionsappendix\" "
"/>.  For example, the x86 processor has both a sign-preserving shift-right, "
"<literal>sarl<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:891
#, no-wrap
msgid "sarl"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:891
msgid ""
"</indexterm></literal>, and a shift-right which does not preserve the sign "
"bit, <literal>shrl<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para><primary>
#: ../../CountingCh.xml:891
#, no-wrap
msgid "shrl"
msgstr ""

# type: Content of: <chapter><sect1><sect2><para>
#: ../../CountingCh.xml:891
msgid "</indexterm></literal>."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../CountingCh.xml:899
#, no-wrap
msgid "Octal and Hexadecimal Numbers"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:902
msgid "The numbering systems discussed so far have been decimal<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:902
msgid "</indexterm> and binary<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:902
msgid ""
"</indexterm>.  However, two others are used common in computing - "
"octal<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:903 ../../CountingCh.xml:937
#, no-wrap
msgid "octal"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:903
msgid "</indexterm> and hexadecimal<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:903 ../../CountingCh.xml:953 ../../CountingCh.xml:972
#, no-wrap
msgid "hexadecimal"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:903
msgid ""
"</indexterm>.  In fact, they are probably written more often than binary.  "
"Octal is a representation that only uses the numbers 0 through 7.  So the "
"octal number 10 is actually 8 in decimal because it is one group of eight.  "
"Octal 121 is decimal 81 (one group of 64 (8^2), two groups of 8, and one "
"left over).  What makes octal nice is that every 3 binary digits make one "
"octal digit (there is no such grouping of binary digits into decimal).  So 0 "
"is 000, 1 is 001, 2 is 010, 3 is 011, 4 is 100, 5 is 101, 6 is 110, and 7 is "
"111."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:915
msgid "<indexterm zone=\"octalhexadecimalpermissions\">"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:915
#, no-wrap
msgid "permissions"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:915
msgid ""
"</indexterm> Permissions in Linux are done using octal.  This is because "
"Linux permissions are based on the ability to read, write and execute.  The "
"first bit is the read permission, the second bit is the write permission, "
"and the third bit is the execute permission.  So, 0 (000) gives no "
"permissions, 6 (110) gives read and write permission, and 5 (101) gives read "
"and execute permissions.  These numbers are then used for the three "
"different sets of permissions - the owner, the group, and everyone else.  "
"The number 0644 means read and write for the first permission set, and "
"read-only for the second and third set.  The first permission set is for the "
"owner of the file.  The third permission set is for the group owner of the "
"file.  The last permission set is for everyone else.  So, "
"<literal>0751</literal> means that the owner of the file can read, write, "
"and execute the file, the group members can read and execute the file, and "
"everyone else can only execute the file."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:935
msgid ""
"Anyway, as you can see, octal is used to group bits (binary digits)  into "
"threes.  The way the assembler knows that a number is octal is because "
"octal<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:937
msgid ""
"</indexterm> numbers are prefixed with a zero.  For example 010 means 10 in "
"octal, which is 8 in decimal. If you just write 10 that means 10 in "
"decimal.  The beginning zero is what differentiates the two.  So, "
"<emphasis>be careful not to put any leading zeroes in front of decimal "
"numbers, or they will be interepreted as octal numbers</emphasis>!"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:946
msgid ""
"Hexadecimal numbers (also called just \"hex\")  use the numbers 1-15 for "
"each digit.  however, since 10-15 don't have their own numbers, hexadecimal "
"uses the letters <literal>a</literal> through <literal>f</literal> to "
"represent them.  For example, the letter <literal>a</literal> represents 10, "
"the letter <literal>b</literal> represents 11, and so on.  10 in hexadecimal "
"is 16 in decimal.  In octal, each digit represented three bits.  In "
"hexadecimal<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:953
msgid ""
"</indexterm>, each digit represents four bits.  Every two digits is a full "
"byte<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:954
msgid "</indexterm>, and eight digits is a 32-bit word<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:954
#, no-wrap
msgid "word"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:954
msgid ""
"</indexterm>.  So you see, it is considerably easier to write a hexadecimal "
"number than it is to write a binary number, because it's only a quarter as "
"many digits.  The most important number to remember in hexadecimal is "
"<literal>f</literal>, which means that all bits are set.  So, if I want to "
"set all of the bits of a register to 1, I can just do"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:966
msgid "Which is considerably easier and less error-prone than writing"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:972
msgid "Note also that hexadecimal<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:972
msgid ""
"</indexterm> numbers are prefixed with <literal>0x</literal>.  So, when we "
"do"
msgstr ""

# type: Content of: <chapter><sect1><para><programlisting><primary>
#: ../../CountingCh.xml:976
#, no-wrap
msgid "int"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:979
msgid ""
"We are calling interrupt number 128 (8 groups of 16), or interrupt number "
"<literal>0b00000000000000000000000010000000</literal>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:984
msgid ""
"Hexadecimal and octal numbers take some getting used to, but they are "
"heavily used in computer programming.  It might be worthwhile to make up "
"some numbers in hex and try to convert them back and forth to binary, "
"decimal, and octal."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../CountingCh.xml:992
#, no-wrap
msgid "Order of Bytes in a Word"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:995
msgid "One thing that confuses many people when dealing with bits<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:995
msgid "</indexterm> and bytes<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:995
msgid ""
"</indexterm> on a low level is that, when bytes are written from "
"registers<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:996
msgid "</indexterm> to memory<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:996
#, no-wrap
msgid "memory"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:996
msgid ""
"</indexterm>, their bytes are written out "
"least-significant-portion-first.<footnote>"
msgstr ""

# type: Content of: <chapter><sect1><para><para>
#: ../../CountingCh.xml:997
msgid ""
"<emphasis>Significance</emphasis> in this context is referring to which "
"digit they represent.  For example, in the number 294, the digit 2 is the "
"most significant because it represents the hundreds place, 9 is the next "
"most significant, and 4 is the least significant."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:997
msgid ""
"</footnote> What most people expect is that if they have a word in a "
"register, say <literal>0x5d 23 ef ee</literal> (the spacing is so you can "
"see where the bytes are), the bytes will be written to memory in that "
"order.  However, on x86 processors, the bytes are actually written in "
"reverse order.  In memory the bytes would be <literal>0xee ef 23 "
"5d</literal> on x86 processors.  The bytes are written in reverse order from "
"what they would appear conceptually, but the bits within the bytes are "
"ordered normally."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1007
msgid ""
"Not all processors behave this way.  The x86 processor is a "
"<emphasis>little-endian<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:1008
#, no-wrap
msgid "little-endian"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1008
msgid ""
"</indexterm></emphasis> processor, which means that it stores the \"little "
"end\", or least-significant byte of its words first."
msgstr ""

# type: Content of: <chapter><sect1><mediaobject><caption><para>
#: ../../CountingCh.xml:1016
msgid "<emphasis>Register-to-memory transfers on little-endian systems</emphasis>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1020
msgid "Other processors are <emphasis>big-endian<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para><primary>
#: ../../CountingCh.xml:1021
#, no-wrap
msgid "big-endian"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1021
msgid ""
"</indexterm></emphasis> processors, which means that they store the \"big "
"end\", or most significant byte, of their words first, the way we would "
"naturally read a number."
msgstr ""

# type: Content of: <chapter><sect1><mediaobject><caption><para>
#: ../../CountingCh.xml:1029
msgid "<emphasis>Register-to-memory transfers on big-endian systems</emphasis>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1033
msgid ""
"This difference is not normally a problem (although it has sparked many "
"technical controversies throughout the years).  Because the bytes are "
"reversed again (or not, if it is a big-endian processor)  when being read "
"back into a register<indexterm>"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1036
msgid ""
"</indexterm>, the programmer usually never notices what order the bytes are "
"in.  The byte-switching magic happens automatically behind the scenes during "
"register-to-memory transfers.  However, the byte order can cause problems in "
"several instances:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1043
msgid ""
"If you try to read in several bytes at a time using <literal>movl</literal> "
"but deal with them on a byte-by-byte basis using the least significant byte "
"(i.e. - by using &al; and/or shifting of the register), this will be in a "
"different order than they appear in memory."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1044
msgid ""
"If you read or write files written for different architectures, you may have "
"to account for whatever order they write their bytes in."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1045
msgid ""
"If you read or write to network sockets, you may have to account for a "
"different byte order in the protocol."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1049
msgid ""
"As long as you are aware of the issue, it usually isn't a big deal.  For "
"more in-depth look at byte order issues, you should read DAV's Endian FAQ at "
"http://www.rdrop.com/~cary/html/endian_faq.html, especially the article \"On "
"Holy Wars and a Plea for Peace\" by Daniel Cohen."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../CountingCh.xml:1057
#, no-wrap
msgid "Converting Numbers for Display"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1060
msgid ""
"So far, we have been unable to display any number stored to the user, except "
"by the extremely limitted means of passing it through exit codes.  In this "
"section, we will discuss converting positive numbers into strings for "
"display."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1067
msgid ""
"The function will be called <literal>integer2string</literal>, and it will "
"take two parameters - an integer to convert and a string buffer filled with "
"null characters (zeroes).  The buffer will be assumed to be big enough to "
"store the entire number as a string.(at least 11 characters long, to include "
"a trailing null character)."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1075
msgid ""
"Remember that the way that we see numbers is in base 10.  Therefore, to "
"access the individual decimal digits of a number, we need to be dividing by "
"10 and displaying the remainder for each digit.  Therefore, the process will "
"look like this:"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1082
msgid "Divide the number by ten"
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1083
msgid "The remainder is the current digit.  Convert it to a character and store it."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1084
msgid "We are finished if the quotient is zero."
msgstr ""

# type: Content of: <chapter><sect1><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1085
msgid ""
"Otherwise, take the quotient and the next location in the buffer and repeat "
"the process."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1089
msgid ""
"The only problem is that since this process deals with the one's place "
"first, it will leave the number backwards.  Therefore, we will have to "
"finish by reversing the characters.  We will do this by storing the "
"characters on the stack as we compute them.  This way, as we pop them back "
"off to fill in the buffer, it will be in the reverse order that we pushed "
"them on."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1097
msgid ""
"The code for the function should be put in a file called "
"<filename>integer-to-string.s</filename> and should be entered as follows:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1106
msgid ""
"To show this used in a full program, use the following code, along with the "
"<literal>count_chars</literal> and <literal>write_newline</literal> "
"functions written about in previous chapters.  The code should be in a file "
"called <filename>conversion-program.s</filename>."
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1117
msgid "To build the program, issue the following commands:"
msgstr ""

# type: Content of: <chapter><sect1><para>
#: ../../CountingCh.xml:1129
msgid ""
"To run just type <literal>./conversion-program</literal> and the output "
"should say <literal>824</literal>."
msgstr ""

# type: Content of: <chapter><sect1><title>
#: ../../CountingCh.xml:1137
#, no-wrap
msgid "Review"
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../CountingCh.xml:1140
#, no-wrap
msgid "Know the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1143
msgid "Convert the decimal number 5,294 to binary."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1144
msgid ""
"What number does 0x0234aeff represent? Specify in binary, octal, and "
"decimal."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1145
msgid "Add the binary numbers 10111001 and 101011."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1146
msgid "Multiply the binary numbers 1100 1010110."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1147
msgid "Convert the results of the previous two problems into decimal."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1148
msgid "Describe how AND, OR, NOT, and XOR work."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1149
msgid "What is masking for?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1150
msgid ""
"What number would you use for the flags of the <literal>open</literal> "
"system call if you wanted to open the file for writing, and create the file "
"if it doesn't exist?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1151
msgid "How would you represent -55 in a thirty-two bit register?"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1152
msgid "Sign-extend the previous quantity into a 64-bit register."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1153
msgid ""
"Describe the difference between little-endian and big-endian storage of "
"words in memory."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../CountingCh.xml:1159
#, no-wrap
msgid "Use the Concepts"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1162
msgid ""
"Go back to previous programs that returned numeric results through the exit "
"status code, and rewrite them to print out the results instead using our "
"integer to string conversion function."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1163
msgid ""
"Modify the <literal>integer2string</literal> code to return results in octal "
"rather than decimal."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1164
msgid ""
"Modify the <literal>integer2string</literal> code so that the conversion "
"base is a parameter rather than hardcoded."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1165
msgid ""
"Write a function called <literal>is_negative</literal> that takes a single "
"integer as a parameter and returns 1 if the parameter is negative, and 0 if "
"the parameter is positive."
msgstr ""

# type: Content of: <chapter><sect1><sect2><title>
#: ../../CountingCh.xml:1171
#, no-wrap
msgid "Going Further"
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1174
msgid ""
"Modify the <literal>integer2string</literal> code so that the conversion "
"base can be greater than 10 (this requires you to use letters for numbers "
"past 9)."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1175
msgid ""
"Create a function that does the reverse of <literal>integer2string</literal> "
"called <literal>number2integer</literal> which takes a character string and "
"converts it to a register-sized integer.  Test it by running that integer "
"back through the <literal>integer2string</literal> function and displaying "
"the results."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1176
msgid ""
"Write a program that stores likes and dislikes into a single machine word, "
"and then compares two sets of likes and dislikes for commonalities."
msgstr ""

# type: Content of: <chapter><sect1><sect2><itemizedlist><listitem><para>
#: ../../CountingCh.xml:1177
msgid ""
"Write a program that reads a string of characters from STDIN and converts "
"them to a number."
msgstr ""
