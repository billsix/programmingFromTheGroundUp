<chapter id="countingchapter">

<!-- FIXME - See Dominique note -->
<title>Counting Like a Computer</title>
<!--

Copyright 2002 Jonathan Bartlett

Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation; with no Invariant Sections, with no Front-Cover Texts,
and with no Back-Cover Texts.  A copy of the license is included in fdl.xml

-->

<remark>I need to make sure I include explanation of stuff like
open flags here, and that I reference this chapter in the sections
that use open flags</remark>

<sect1>
<title>Counting</title>

<sect2>
<title>Counting Like a Human</title>

<para>
In many ways, computers count just like humans.  So, before we
start learning how computers count, let's take a deeper look at
how we count.
</para>

<para>
How many fingers do you have?  No, it's not a trick question.
Humans (normally) have ten fingers.  Why is that significant?
Look at our numbering system.  At what point does a one-digit
number become a two-digit number?  That's right, at ten.  Humans
count and do math using a base ten numbering system.  Base ten
means that we group everything in tens.  Let's say we're counting
sheep.  1, 2, 3, 4, 5, 6, 7, 8, 9, 10.  Why did we all of a sudden
now have two digits, and re-use the 1?  That's because we're grouping
our numbers by ten, and we have 1 group of ten sheep.  Okay, let's
go to the next number 11.  That means we have 1 group of ten sheep,
and 1 sheep left ungrouped.  So we continue - 12, 13, 14, 15, 16, 17,
18, 19, 20.  Now we have 2 groups of ten.  21 - 2 groups of ten, and
1 sheep ungrouped.  22 - 2 groups of ten, and 2 sheep ungrouped.   So,
let's say we keep counting, and get to 97, 98, 99, and 100.  Look, it
happened again!  What happens at 100?  We now have ten groups of ten.
At 101 we have ten groups of ten, and 1 ungrouped sheep.  So we can
look at any number like this.  If we counted 60879 sheep, that would
mean that we had 6 groups of ten groups of ten groups of ten groups of ten,
0 groups of ten groups of ten groups of ten, 8 groups of ten groups of ten,
7 groups of ten, and 9 sheep left ungrouped.  
</para>

<para>
So, is there anything significant about grouping things by ten?  No!  It's
just that grouping by ten is how we've always done it, because we have
ten fingers.  We could have grouped at nine or at eleven, in which case
we would have had to make up a new symbol.  The only difference between
the different groupings of numbers, is that we have to re-learn our
multiplication, addition, subtraction, and division tables.  The rules
haven't changed, just the way we represent them.  Also, some of our
tricks that we learned don't always apply, either.  For example, let's
say we grouped by nine instead of ten.  Moving the decimal point one
digit to the right no longer multiplies by ten, it now multiplies by nine.
In base nine, 500 is only nine times as large as 50.
</para>
</sect2>

<sect2>
<title>Counting Like a Computer</title>

<para>
The question is, how many fingers does the computer have to count with?
The computer only has two fingers.  So that means all of the groups are 
groups of two.  So, let's count in binary - 0 (zero), 1 (one), 10 (two - 
one group of two), 11 (three - one group of two and one left over), 
100 (four - two groups of two), 101 (five - two groups of two and one left 
over), 110 (six - two groups of two and one group of two), and so on.  
In base two, moving the decimal one digit to the right multiplies by two, and 
moving it to the left divides by two.  Base two is also referred to
as binary.
</para>

<para>
The nice thing about base two is that the basic math tables are very
short.  In base ten, the multiplication tables are ten columns wide,
and ten columns tall.  In base two, it is very simple:

<programlisting>
<!-- NOTE - these need to be converted to tables -->

Table of binary addition

+ |  0  |  1  
--+-----+-----
0 |  0  |  0  
--+-----+-----
1 |  1  | 10  

Table of binary multiplication

* |  0  |  1
--+-----+-----
0 |  0  |  0
--+-----+-----
1 |  0  |  1

</programlisting>

So, let's add the numbers 10010101 with 1100101:

<programlisting>
   10010101
+   1100101
-----------
   11111010
</programlisting>

Now, let's multiply them:

<programlisting>

        10010101
     *   1100101
     -----------
        10010101
       00000000
      10010101
     00000000
    00000000
   10010101
  10010101
 ---------------
  11101011001001
</programlisting>

</para>

</sect2>

<sect2>
<title>Conversions Between Binary and Decimal</title>

<para>
Let's learn how to convert numbers from binary (base two) to 
decimal (base ten).  This is actually a rather simple process.
If you remember, each digit stands for some grouping of two.  So,
we just need to add up what each digit represents, and we will have
a decimal number.  Take the binary number 10010101.  To find out
what it is in decimal, we take it apart like this:

<programlisting>
     1    0    0    1    0    1    0    1
     |    |    |    |    |    |    |    |
     |    |    |    |    |    |    |    Individual units (2^0)
     |    |    |    |    |    |    0 groups of 2 (2^1)
     |    |    |    |    |    1 group of 4 (2^2)
     |    |    |    |    0 groups of 8 (2^3)
     |    |    |    1 group of 16 (2^4)
     |    |    0 groups of 32 (2^5)
     |    0 groups of 64 (2^6)
     1 group of 128 (2^7)
</programlisting>

and then we add all of the pieces together, like this:

<programlisting>
1*128 + 0*64 + 0*32 + 1*16 + 0*8 + 1*4 + 0*2 + 1*1 =
128 + 16 + 4 + 1 = 
149
</programlisting>

So 10010101 in binary is 149 in decimal.  Let's look at 1100101.  It
can be written as

<programlisting>
1*64 + 1*32 + 0 * 16 + 0*8 + 1*4 + 0*2 + 1*1 =
64 + 32 + 4 + 1 =
101
</programlisting>

So we see that 1100101 in binary is 101 in decimal.  Let's look at
one more number, 11101011001001.  You can convert it to decimal by doing

<programlisting>
1*8192 + 1*4096 + 1*2048 + 0*1024 + 1*512 + 0*256 + 1*128 + 1*64 + 0*32 +
0*16 + 1*8 + 0*4 + 0*2 + 1*1 =
8192 + 4096 + 2048 + 512 + 128 + 64 + 8 + 1 =
15049
</programlisting>

Now, if you've been paying attention, you have noticed that the numbers
we just converted are the same ones we used to multiply with earlier.
So, let's check our results: 101 * 149 = 15049.  It worked!
</para>

<para>
Now let's look at going from decimal back to binary.  In order to do
the conversion, you have to <emphasis>divide</emphasis> the number
into groups of two.  So, let's say you had the number 17.  If you
divide it by two, you get 8 with 1 left over.  So that means there are
8 groups of two, and 1 ungrouped.  That means that the rightmost digit
will be 1.  Now, we have the rigtmost digit figured out, and 8 groups
of 2 left over.  Now, let's see how many groups of two groups of two we 
have, by dividing 8 by 2.  We get 4, with nothing left over.  That
means that all groups two can be further divided into more groups of
two.  So, we have 0 groups of only two.  So the next digit to the
left is 0.  So, we divide 4 by 2 and get two, with 0 left over, so
the next digit is 0.  Then, we divide 2 by 2 and get 1, with 0 left over.
So the next digit is 0.  Finally, we divide 1 by 2 and get 0 with 1
left over, so the next digit to the left is 1.  Now, there's nothing
left, so we're done.  So, the number we wound up with is 10001.
</para>

<para>
Previously, we converted to binary 11101011001001 to decimal 15049.  Let's
do the reverse to make sure that we did it right:

<programlisting>
15049 / 2 = 7524    Remaining 1
7524 / 2 = 3762     Remaining 0
3762 / 2 = 1881     Remaining 0
1881 / 2 = 940      Remaining 1
940 / 2 = 470       Remaining 0
470 / 2 = 235       Remaining 0
235 / 2 = 117       Remaining 1
117 / 2 = 58        Remaining 1
58 / 2 = 29         Remaining 0
29 / 2 = 14         Remaining 1
14 / 2 = 7          Remaining 0
7 / 2 = 3           Remaining 1
3 / 2 = 1           Remaining 1
1 / 2 = 0           Remaining 1
</programlisting>

Then, we put the remaining numbers back together, and we have the original
number!  Remember the first division remainder goes to the far right, so
from the bottom up you have 11101011001001.
</para>

<para>
Each digit in a binary number is called a <emphasis>bit</emphasis>, which
stands for <emphasis>binary digit</emphasis>.  Computers divide up
their memory into storage locations called bytes.  Each storage location 
on an IA32 computer (and most others) is 8 bits long.  Earlier we said
that a byte can hold any number between 0 and 255.  The reason for this
is that the largest number you can fit into 8 bits is 255.  You can
see this for yourself if you convert binary 11111111 into decimal:

<programlisting>
11111111 =
(1 * 2^7) + (1 * 2^6) + (1 * 2^5) + (1 * 2^4) + (1 * 2^3) + (1 * 2^2) + (1 * 2^1) + (1 * 2^0) = 
128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 =
255
</programlisting>

The largest number that you can hold in 16 bits is 65535.   The largest
number you can hold in 32 bits is 4294967295 (4 billion).  The largest
number you can hold in 64 bits is 18,446,744,073,709,551,615.  The
largest number you can hold in 128 bits is
340,282,366,920,938,463,463,374,607,431,768,211,456.  Anyway, you
see the picture.  For IA32, most of the time you will deal with 4-byte
numbers (32 bits), because that's the size of the registers.
</para>

</sect2>

</sect1>

<sect1 id="truthbinarynumbers">
<title>Truth, Falsehood, and Binary Numbers</title>

<para>
Now we've seen that the computer stores everything as sequences of
1's and 0's.  Let's look at some other uses of this.  What if, instead
of looking at a sequence of bits as a number, we instead looked at
it as a set of switches.  For example, let's say there are four switches
that control lighting in the house.  We have a switch for outside lights,
a switch for the hallway lights, a switch for the living room lights,
and a switch for the bedroom lights.  We could make a little table
showing which of these were on and off, like so:

<programlisting>
Outside  Hallway  Living Room  Bedroom
  On       Off        On         On
</programlisting>

It's obvious from looking at this that all of the lights are on except
the hallway ones.  Now, instead of using the words "On" and "Off",
let's use the numbers 1 and 0.  1 will represent on, and 0 will represent
off.  So, we could represent the same information as

<programlisting>
Outside  Hallway  Living Room  Bedroom
   1        0           1         1
</programlisting>

Now, instead of having labels on the light switches, let's say we just
memorized which position went with which switch.  Then, the same
information could be represented as

<programlisting>
1           0           1         1
</programlisting>

or as

<programlisting>
1011
</programlisting>

This is just one of many ways you can use the computers storage locations
to represent more than just numbers.  The computers memory just sees numbers,
but programmers can use these numbers to represent anything their imaginations
can come up with.  
</para>

<para>
Not only can you do regular arithmetic with binary numbers, they also have
a few operations of their own.  The standard binary operations are

<itemizedlist>
<listitem><para>AND</para></listitem>
<listitem><para>OR</para></listitem>
<listitem><para>NOT</para></listitem>
<listitem><para>XOR</para></listitem>
</itemizedlist>

Before we look at examples, I'll describe them for you.
AND takes two bits and returns one bit.  AND will return a 1 only if
both bits are 1, and a 0 otherwise.  For example, 1 AND 1 is 1, but
1 AND 0 is 0, 0 AND 1 is 0, and 0 AND 0 is 0.  OR takes two bits
and returns one bit.  It will return 1 if either of the original bits
is 1.  For example, 1 OR 1 is 1, 1 OR 0 is one, 0 OR 1 is 1, but 0 OR 0
is 0.  NOT only takes one bit, and returns it's opposite NOT 1 is 0 and
NOT 0 is 1.  Finally, XOR is like OR, except it returns 0 if both bits
are 1.  Computers can do these operations on whole registers at a time.
For example, if a register has 10100010101010010101101100101010 and
another one has 10001000010101010101010101111010, you can run any of
these operations on the whole registers.  For example, if we were to
AND them, the computer will run from the first bit to the 32nd and run
the AND operation on that bit in both registers.  In this case:

<programlisting>
10100010101010010101101100101010 AND
10001000010101010101010101111010
--------------------------------
10000000000000010101000100101010
</programlisting>

You'll see that the resulting set of bits only has a one where 
<emphasis>both</emphasis> numbers had a one, and in every other position
it has a zero.  Let's look at what an OR looks like:

<programlisting>
10100010101010010101101100101010 OR 
10001000010101010101010101111010
--------------------------------
10101010111111010101111101111010
</programlisting>

In this case, the resulting number has a 1 where either number has
a 1 in the given position.  Let's look at the NOT operation:

<programlisting>
NOT 10100010101010010101101100101010
------------------------------------
    01011101010101101010010011010101
</programlisting>

This just reverses each digit.  Finally, we have XOR, which is
like an OR, except if <emphasis>both</emphasis> digits are 1, it
returns 0.

<programlisting>
10100010101010010101101100101010 XOR 
10001000010101010101010101111010
--------------------------------
00101010111111000000111001010000
</programlisting>

This is the same two numbers used in the OR operation, so you can 
compare how they work.  Also, if you XOR a number with itself, you get 
0, like this:

<programlisting>
10100010101010010101101100101010 XOR 
10100010101010010101101100101010
--------------------------------
00000000000000000000000000000000
</programlisting>

</para>

<para>
These operations are useful for two reasons:

<itemizedlist>
<listitem><para>The computer can do them extremely fast</para></listitem>
<listitem><para>You can use them to compare many truth values at the same time</para></listitem>
</itemizedlist>

You may not have known that different instructions execute at different
speeds.  It's true, they do.  And these operations are pretty much the
fastest.  For example, you saw that XORing a number with itself produces
0.  Well, the XOR operation is faster than the loading operation, so
many programmers use it to load a register with zero.  For example, the
code

<programlisting>
	movl  $0, %eax
</programlisting>

is often replaced by

<programlisting>
	xorl  %eax, %eax
</programlisting>

We'll discuss speed more in the optimization chapter<!--XREF-->, but I want you
to see how programmers often do tricky things, especially with these
binary operators, to make things fast.  Now let's look at how we
can use these operators to manipulate true/false values.  Earlier
we discussed how binary numbers can be used to represent any number
of things.  Let's use binary numbers to represent what things my
Dad and I like.  First, let's look at the things I like:

<programlisting>
Food: yes
Heavy Metal Music: yes
Wearing Dressy Clothes: no
Football: yes
</programlisting>

Now, let's look at what my Dad likes:

<programlisting>
Food: yes
Heavy Metal Music: no
Wearing Dressy Clothes: yes
Football: yes
</programlisting>

Now, let's use a 1 to say yes we like something, and a 0 to say no we don't.
Now we have:

<programlisting>
Me
Food: 1
Heavy Metal Music: 1
Wearing Dressy Clothes: 0
Football: 1

Dad
Food: 1
Heavy Metal Music: 0
Wearing Dressy Clothes: 1
Football: 1
</programlisting>

Now, if we just memorize which position each of these are in, we have

<programlisting>
Me
1101

Dad
1011
</programlisting>

Now, let's see we want to get a list of things both my Dad and I like.
You would use the AND operation.  So

<programlisting>
1101 AND
1011
--------
1001
</programlisting>

Which translates to

<programlisting>
Things we both like
Food: yes
Heavy Metal Music: no
Wearing Dressy Clothes: no
Football: yes
</programlisting>

Remember, the computer has no idea what the ones and zeroes represent.
That's your job.  Obviously, later down the road you would examine
each bit and tell the user what it's for.  If you asked a computer
what two people agreed on and it answered 1001, it wouldn't be very
useful.  Anyway, let's say we want to know the things that we disagree
on.  For that we would use XOR, because it will return 1 only if one
or the other is 1, but not both.  So

<programlisting>
1101 XOR
1011
--------
0110
</programlisting>

And I'll let you translate that back out.  So you see how these work.
</para>

<para>
The previous operations: AND, OR, NOT, and XOR are called <emphasis>boolean
operator</emphasis> because they were first studied by a guy with the
last name of Boole.  So, if someone mentiones boolean operators or 
boolean algebra, you now know what they are talking about.  Anyway, there
are also two binary operators that aren't boolean, shift and rotate.
Shifts and rotates each do what their name implies, and can do so to
the right or the left.  A left shift moves each digit of a binary number
one space to the left, puts a zero in the ones spot, and chops off
the furthest digit to the left.  A left rotate does the same thing, but
takes the furthest digit to the left and puts it in the ones spot.  For
example,

<programlisting>
Shift left  10010111 = 00101110
Rotate left 10010111 = 00101111
</programlisting>

Notice that if you rotate a number for every digit it has, you wind up
with the same number.  However, if you shift a number for every digit 
you have, you wind up with 0.  So, what are these shifts useful for?
Well, if you have binary numbers representing things, you use shifts
to peek at each individual value.  Let's say, for instance, that
we had my Dad's likes stored in a register (32 bits).  It
would look like this:

<programlisting>
00000000000000000000000000001011
</programlisting>

Now, as we said previously, this doesn't work as program output.  So,
in order to do output, we would need to do shifting and 
<emphasis>masking</emphasis>.  Masking is the process of eliminating
everything you don't want.  In this case, for every value we are looking
for, we will shift the number so that value is in the ones place, and
then mask that digit so that it is all we see.  For example, let's say
we wanted to print out whether my Dad likes dressy clothes or not.  That
data is the second value from the right.  So, we have to shift the
number right 1 digit so it looks like this:

<programlisting>
00000000000000000000000000000101
</programlisting>

and then, we just want to look at that digit, so we mask it by ANDing
it with 00000000000000000000000000000001.

<programlisting>
00000000000000000000000000000101 AND
00000000000000000000000000000001
-----------------------------------
00000000000000000000000000000001
</programlisting>

This will make the value of the register 1 if my Dad likes dressy
clothes, and 0 if he doesn't.  Then we can do a comparison to 1
and print the results.  The code would look like this:

<programlisting>
	;;NOTE - assume that the register %ebx holds my Dad's preferences

	movl  %ebx, %eax ;;This copies the information into %eax so
	                 ;;we don't lose the original data

	sall  $1, %eax   ;;This is the shift operator.  It stands for
	                 ;;Shift Arithmatic Left Long.  This first
	                 ;;number is the number of positions to shift,
	                 ;;and the second is the register to shift

	andl  $0b00000000000000000000000000000001, %eax ;;This does the masking

	cmpl  $0b00000000000000000000000000000001, %eax ;;Check to see if the result is 1 or 0

	je    yes_he_likes_dressy_clothes

	jmp   no_he_doesnt_like_dressy_clothes
</programlisting>

And then we would have two labels which printed something about
whether or not he likes dressy clothes and then exits.
The <literal>0b</literal> notation means that what follows is a binary
number.  In this case it wasn't needed, because 1 is the same in any
numbering system.  We also didn't need the 31 zeroes, but I put them in
to make a point that the number you are using is 32 bits.
</para>

<para>
When a number represents a set of options for a function or system call,
the individual true/false elements are called <emphasis>flags</emphasis>.
Many system calls have numerous options that are all
set in the same register using a mechanism like we've described.
The <literal>open</literal> system call, for example, has as its
second parameter a list of flags to tell the operating system how
to open the file.  Some of the flags include:
</para>

<variablelist>


<varlistentry>
<term><literal>O_WRONLY</literal></term>
<listitem><para>
This flag is <literal>0b00000000000000000000000000000001</literal> in binary, or <literal>01</literal> in octal (or any number system for that matter).  This says to open the file in write-only mode.
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>O_RDWR</literal></term>
<listitem><para>
This flag is <literal>0b00000000000000000000000000000010</literal> in binary, or <literal>02</literal> in octal.  This says to open the file for both reading and writing.
</para></listitem>
</varlistentry>

<varlistentry>
<term><literal>O_CREAT</literal></term>
<listitem><para>
This flag is <literal>0b00000000000000000000000001000000</literal> in binary, or <literal>0100</literal> in octal.  It means to create the file if it doesn't already exist.
</para></listitem>
</varlistentry>


<varlistentry>
<term><literal>O_TRUNC</literal></term>
<listitem><para>
This flag is <literal>0b00000000000000000000001000000000</literal> in binary, or <literal>01000</literal> in octal.  It means to erase the contents of the file if the file already exists.
</para></listitem>
</varlistentry>


<varlistentry>
<term><literal>O_APPEND</literal></term>
<listitem><para>
This flag is <literal>0b00000000000000000000010000000000</literal> in binary, or <literal>02000</literal> in octal.  It means to start writing at the end of the file rather than at the beginning.
</para></listitem>
</varlistentry>

</variablelist>

<para>
To use these flags, you simply OR them together in the combination that you 
want.  For example, to open a file in write-only mode, and have it create the
file if it doesn't exist, I would use <literal>O_WRONLY</literal> (01) and 
<literal>O_CREAT</literal> (0100).  Or'd together, I would have 0101.
</para>

<para>
Note that if you don't set either <literal>O_WRONLY</literal> or <literal>O_RDWR</literal>, then the file is automatically opened in read-only mode (<literal>O_RDONLY</literal>, except that it isn't really a flag since it's zero).  There
are many other flags, but these are the important ones.
</para>

</sect1>

<sect1>
<title>The Program Status Register</title>

<para>
We've seen how bits on a register can be used to give the answers
of yes/no and true/false statements.  On your computer, there
is a register called the <emphasis>program status register</emphasis>.
This register holds a lot of information about what happens in a computation.
For example, have you ever wondered what would happen if you added
two numbers and the result was larger than would fit in a register?
The program status register has a flag called the overflow flag.
You can test it to see if the last computation overflowed the register.
There are flags for a number of different statuses.  In fact, when
you do a compare (<literal>cmpl</literal>) instruction, the result
is stored in this register.  The jump instructions (<literal>jge</literal>,
<literal>jne</literal>, etc) use these results to tell whether or not
they should jump.  <literal>jmp</literal>, the 
unconditional jump, doesn't care what is in the status register, since
it is unconditional.
</para>

<para>
Let's say you needed to store a number larger than 32 bits.  So, let's
say the number is 2 registers wide, or 64 bits.  How could you handle
this?  If you wanted to add two 64 bit numbers, you would add
the least significant registers first.  Then, if you detected an 
overflow, you could add 1 to the most significant register before
adding them.  In fact, this is probably the way you learned to
do decimal addition.  If the result in one column is more than 9, you
simply carried the number to the next most significant column.  If you
added 65 and 37, first you add 7 and 4 to get 12.  You keep the 2 in
the right column, and carry the one to the next column.   There you add
6, 3, and the 1 you carried.  This results in 10.  So, you keep the
zero in that column and carry the one to the next most significant column,
which is empty, so you just put the one there.  As you can see, most
computer operations are exactly like their human counterparts, except
you have to describe them in excruciating detail.
</para>

<para>
The program status register has many more useful flags, but they aren't
important for what we're doing here.
</para>
<!-- FIXME - Dominique thinks we should link to more information -->

</sect1>


<sect1>
<title>Other Numbering Systems</title>

<para>
What we have studied so far only applies to positive integers.  However,
real-world numbers are not always positive integers.  Negative numbers
and numbers with decimals are also used.  The explanations are not 
in-depth, because the concept is more important than the implementation.
If you wish to know implementation details, you can read further 
information on the subject.
</para>
 
<sect2>
<title>Floating-point Numbers</title>

<para>
So far, the only numbers we've dealt with are integers - numbers
with no decimal point.  Computers have a general problem with
numbers with decimal points, because computers can only store
fixed-size, finite values.  Decimal numbers can be any length, including
infinite length (think of a repeating decimal, like the result of
1 / 3).  The way a computer handles this is by storing decimals
at a fixed precision.  A computer stores decimal numbers in two
parts - the exponent and the mantissa.  The mantissa is the actually
numbers that will be used, and the exponent is what magnitude the number
is.  For example, 12345.2 is stored as 1.23452 * 10^4.  The mantissa
is 1.23452 and the exponent is 4.  All numbers are stored
as X.XXXXX * 10^XXXX.  The number 1 is stored as 1.00000 * 10^0.
Now, the mantissa and the exponent are only so long, which leads to some 
interesting problems.  For example, when a computer
stores an integer, if you add 1 to it, the resulting number is one larger.
This does not necessarily happen with floating point numbers.  If the
number is sufficiently big, like 5.234 * 10^5000, adding 1 to it might
not even register in the mantissa (remember, both parts are only so long).
This affects several things, especially order of operations.  Let's say
that I add 1 to 5.234 * 10^5000 a few billion or trillion times.  Guess
what, the number won't change at all.  However, if I add one to itself 
a few trillion or billion times, and then add it to the original number,
it might make a dent.   Note that I haven't actually computed this,
nor do I know the details of the representation.  I'm just trying to
let you in on how this works in the computer so it doesn't surprise you
later on.  You should note that it takes most computers a lot longer
to do floating-point arithmetic than it does integer arithmetic.  So,
for programs that really need speed, integers are mostly used.  
</para>

</sect2>

<sect2>
<title>Negative Numbers</title>

<para>
There has been much thought as to how to represent negative numbers
in a computer.  One thought might be to use the first digit of a number
as the sign, so <literal>00000000000000000000000000000001</literal> would
represent the number 1, and <literal>10000000000000000000000000000001</literal>
would represent -1.  This has a problem with the number 0, however.  In
this system, you could have both a negative and a positive 0.  This leads
to a lot of questions, like "should negative zero be equal to positive zero?",
"What should the sign of zero be in various circumstances?".  In addition
to questions that arose out of using a single sign bit, there was also
a problem of implementation.   Adding a negative and a positive number
would require totally different circuitry than adding two positive numbers.
Anyway, these problems were overcome by using a representation called
<emphasis>two's complement</emphasis> representation.  To get the negative
representation of a number in two's complement form, you must perform the
following steps:

<orderedlist>
<listitem><para>Perform a NOT operation on the number</para></listitem>
<listitem><para>Add one to the resulting number</para></listitem>
</orderedlist>

So, to get the negative of <literal>00000000000000000000000000000001</literal>,
you would first do a NOT operation, which gives 
<literal>11111111111111111111111111111110</literal>, and then add one, giving
<literal>11111111111111111111111111111111</literal>.  To get negative two,
first take <literal>00000000000000000000000000000010</literal>.  The NOT
of that number is <literal>11111111111111111111111111111101</literal>.  Adding
one gives <literal>11111111111111111111111111111110</literal>.  With this
representation, you can add numbers just as if they were positive, and
come out with the right answers.  For example, if you add one plus negative
one in binary, you will notice that all of the numbers flip to zero.  
The only thing you have to remember is to ignore any number carried to
far to the left (past the 32nd digit), and your answers should be fine.
This method still makes it easy to tell which numbers are negative and
positive, because negative numbers will always have a <literal>1</literal>
in the leftmost position.
</para>
</sect2>

</sect1>

<sect1>
<title>Octal and Hexadecimal Numbers</title>

<para>
The numbering systems discussed so far have been decimal and binary.
However, two others are used common in computing - octal and hexadecimal.
In fact, they are probably written more often than binary.  Octal is
a representation that only uses the numbers 0-7.  So, 10 is actually
the number 8 in octal (one group of eight).  121 is 81 (one group of
64 (8^2), two groups of 8, and one left over).  What makes octal nice
is that every 3 binary digits make one octal digit (there is no such grouping
of binary digits into decimal).  So 0 is 000, 1 is 001, 2 is 010, 3 is
011, 4 is 100, 5 is 101, 6 is 110, and 7 is 111.  Permissions in Linux
are done using octal.  This is because Linux permissions are based on the 
ability to read, write and execute.  The first digit is the read permission,
the second bit is the write permission, and the third bit is the execute
permission.  So, 0 (000) gives no permissions, 6 (110) gives read and
write permission, and 5 (101) gives read, write, and execute permissions.
These numbers are then used for the four different types of permissions.
The number 0644 means no permissions for the first type, read and write
for the second type, and read-only for the third and fourth type.  
The first type is for "elevated" permissions, which we won't discuss
here.  The second permission type is for the owner of the file.  The
third permission set is for the group owner of the file.  The last 
permission set is for everyone else.  So, <literal>0751</literal>
means that the owner of the file can read, write, and execute the
file, the group members can read and execute the file, and everyone
else can only execute the file.  There are no elevated permissions
on the file.
</para>

<para>
Anyway, as you can see, octal is used to group bits (binary digits)
into threes.  The way you write octal numbers in assembly is by
prefixing them with a zero.  For example 010 means 10 in octal, which
is 8 in decimal, while if you just write 10 that means 10 in decimal.
So, be careful not to put any leading zeroes in front of decimal
numbers, or they will be interepreted as octal numbers!
</para>

<para>
Hexadecimal numbers (also called just "hex") 
use the numbers 1-15 for each digit.  however,
since 10-15 don't have their own numbers, hexadecimal uses the
letters <literal>a</literal> through <literal>f</literal> to represent
them.  For example, the letter <literal>a</literal> represents 10, the
letter <literal>b</literal> represents 11, and so on.  10 in hexadecimal
is 16 in decimal.  In octal, each digit represented three bits.  In
hexadecimal, each digit represents four bits.  Every two digits is 
a full byte, and eight digits is a 32-bit register.  So you see, it
is considerably easier to write a hexadecimal number than it is
to write a binary number.  The most important number to remember in
hexadecimal is <literal>f</literal>, which means that all bits are
set.  So, if I want to set all of the bits of a register to 1, I
can just do

<programlisting>
	movl  $0xFFFFFFFF, %eax
</programlisting>

Which is considerably easier and less error-prone than writing

<programlisting>
	movl  $0b11111111111111111111111111111111, %eax
</programlisting>

Note also that hexadecimal numbers are prefixed with <literal>0x</literal>.
So, when we do 

<programlisting>
	int   $0x80
</programlisting>

We are calling interrupt number 128 (8 groups of 16), or interrupt
number 0b00000000000000000000000010000000.
</para>

<para>
Hexadecimal and octal numbers take some getting used to, but they
are heavily used in computer programming.  It might be worthwhile
to make up some numbers in hex and try to convert them back and forth
to binary, decimal, and octal.
</para>
</sect1>

<sect1>
<title>Converting Numbers for Display</title>

<para>
So far, we have been unable to display any number stored to the 
user, except by the extremely limitted means of passing it through
exit codes.  In this section, we will discuss converting positive
into strings for display.
</para>

<para>
The function will be called <literal>integer2string</literal>, and
it will take two parameters - an integer to convert and a string buffer 
filled with null characters (zeroes).  The buffer will be assumed to
be big enough to store the entire number as a string.(at least 11 characters
long, to include a trailing null character).
</para>

<para>
Remember that the way that we see numbers is in base 10.  Therefore, to access
the individual decimal digits of a number, we need to be dividing by 10
and displaying the remainder for each digit.  Therefore, the process will
look like this:
</para>

<itemizedlist>
<listitem><para>Divide the number by ten</para></listitem>
<listitem><para>The remainder is the current digit.  Convert it to a character and store it.</para></listitem>
<listitem><para>We are finished if we are at zero yet.</para></listitem>
<listitem><para>Otherwise, take the new number and the next location in the buffer and repeat the process.</para></listitem>
</itemizedlist>

<para>
The only problem is that since this process deals with the one's place first,
it will leave the number backwards.  Therefore, we will have to finish by 
reversing the characters.  We will do this by storing the characters on
the stack as we compute them.  This way, as we pop them back off to fill
in the buffer, it will be in the reverse order that we pushed them on.
</para>

<para>
The code for the function should be put in a file called 
<filename>integer-to-number.s</filename> and should be entered as follows:
</para>

<programlisting>
&integer-to-number;
</programlisting>

<para>
To show this used in a full program, use the following code, along
with the <literal>count_chars</literal> and <literal>write_newline</literal>
functions written about in previous chapters.  The code should be
in a file called <filename>conversion-program.s</filename>.
</para>

<programlisting>
&conversion-program;
</programlisting>

<para>
To build the program, issue the following commands:
</para>

<programlisting>
as integer-to-number.s -o integer-to-number.o
as count-chars.s -o count-chars.o
as write-newline.s -o write-newline.o
as conversion-program.s -o conversion-program.o
ld integer-to-number.o count-chars.o write-newline.o conversion-program.o -o conversion-program
</programlisting>

<para>
To run just type <literal>./conversion-program</literal> and the output
should say <literal>824</literal>.
</para>

</sect1>

<!-- FIXME - need a talk on floating point -->


<sect1>
<title>Review</title>

<sect2>
<title>Know the Concepts</title>

<itemizedlist>
<listitem><para>Convert the decimal number 5,294 to binary.</para></listitem>
<listitem><para>Add the binary numbers 10111001 and 101011.</para></listitem>
<listitem><para>Multiply the binary numbers 1100 1010110.</para></listitem>
<listitem><para>Convert the results of the previous two problems into decimal.</para></listitem>
<listitem><para>Describe how <literal>and</literal>, <literal>or</literal>, <literal>not</literal>, and <literal>xor</literal> work.</para></listitem>
<listitem><para>What is masking for?</para></listitem>
<listitem><para>What number would you use for the flags of the <literal>open</literal> system call if you wanted to open the file for writing, and create the file if it doesn't exist?</para></listitem>
<listitem><para>How would you represent -55 in a thirty-two bit register?</para></listitem>
</itemizedlist>

</sect2>

<sect2>
<title>Use the Concepts</title>

<itemizedlist>
<listitem><para>Go back to previous programs that returned numeric results through the exit status code, and rewrite them to print out the results instead.</para></listitem>
<listitem><para>Modify the <literal>integer2number</literal> code to return results in octal rather than decimal.</para></listitem>
<listitem><para>Modify the <literal>integer2number</literal> code so that the conversion base is a parameter rather than hardcoded.</para></listitem>
<listitem><para>Write a function called <literal>is_negative</literal> that takes a single integer as a parameter and returns 1 if the parameter is negative, and 0 if the parameter is positive.</para></listitem>
</itemizedlist>

</sect2>

<sect2>
<title>Going Further</title>

<itemizedlist>
<listitem><para>Modify the <literal>integer2number</literal> code so that the conversion base can be greater than 10 (this requires you to use letters for numbers past 9).</para></listitem>
<listitem><para>Create a function that does the reverse of <literal>integer2number</literal> called <literal>number2integer</literal> which takes a character string and converts it to a register-sized integer.  Test it by running that integer back through the <literal>integer2number</literal> function and displaying the results.</para></listitem>
</itemizedlist>

</sect2>
</sect1>

</chapter>
