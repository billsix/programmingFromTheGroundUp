<?xml version="1.0" ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN">
<chapter>
<title>Program-Generating Programs</title>

<sect1>
<title>Why Write Programs to Generate Programs</title>

<para>
One of the most under-utilized programming techniques is writing programs
that generate programs or program parts.  There are numerous applications 
to writing programs which themselves write programs.  Program-generating
programs are sometimes called <emphasis>meta-programs</emphasis> and 
writing such programs is called <emphasis>meta-programming</emphasis>.  
</para>

<para>
There are many different uses of meta-programming.
</para>

<para>
First of all, you can write programs that will pre-generate tables of data
for use at run-time.  For example, if you are writing a game and want a quick
lookup table for the sin of all 8-bit integers you have the options of
calculating each sin yourself and hand-coding it, having your program build
the table at startup at runtime, or write a program to build the hand-coded
table yourself.  While it may make sense to build the table at runtime for
such a small set of numbers, other such tasks may cause program startup to
be prohibitively slow.  In such cases, writing a program to build static 
data tables is usually your best answer.
</para>

<para>
Second, if you have a large application where many of the functions
include a lot of boilerplate
code, you can create a mini-language that will do the boilerplate code for
you and allow you to only code the important parts.  Now, if you can, it's best
to abstract out the boilerplate portions into a function.  However, often
the boilerplate code isn't so pretty.  Perhaps there's a list of variables
that need to be declared in every instance, perhaps you need to register 
error handlers, or perhaps there are several pieces of the boilerplate that
have to have code inserted into it in certain circumstances.  All of these
make a simple function call impossible.  In such cases, it is often a good
idea to create a mini-language which allows you to work with your boilerplate
code in an easier fashion.  This mini-language will then be converted into
your regular source code language before compiling.
</para>

<para>
Finally, a lot of programming languages make you write really verbose 
statements to do really simple things.  Program-generating programs allow
you to abbreviate such statements and save you a lot of typing.  This
will also save you from a lot of mistakes as well, since there is less
to mistype.
</para>

<para>
As languages get more features, program-generating programs get less and less
appealing.  What might be available as a standard feature of one language
may be only available through a program-generating program in another language.
However, the need for program-generating programs will not go away just through
better language design.  Program-generating programs allow you to write small,
domain-specific languages that are easier to write and maintain than writing
them in the target language.
</para>

<para>
The tools that are used to create these domain-specific languages are usually
referred to as <emphasis>macro languages</emphasis>.  This article will discuss
several kinds of macro languages, and show how they can be used to improve
your code.
</para>

</sect1>

<sect1>
<title>Basic Textual Macro Languages</title>

<sect2>
<title>The C Preprocessor, CPP</title>

<para>
The first kind of meta-programming we are going to look at are textual macros
languages.
Textual macros are macros that directly affect the text of the programming 
language without knowing anything about the meaning of the programming 
language.  The two most widely-used textual macro systems are the 
C pre-processor and the M4 macro processor.  If you've done C programming,
you have probably dealt with C's <literal>#define</literal> macro.  
Textual macro expansion is a decent way to do basic meta-programming.
Here is an example <literal>#define</literal> macro:
</para>

<programlisting>
#define SWAP(a, b, type) { type __tmp_c; c = b; b = a; a = c; }
</programlisting>

<para>
This macro allows you to swap the two values of the given type.  This is
best written as a macro for several reasons:
</para>

<itemizedlist>
<listitem><para>A function call would take way too much overhead for a simple operation</para></listitem>
<listitem><para>You would have to pass their addresses to the function, rather than their values.  This isn't too bad, but it makes it messier, and prevents the compiler from being able to keep the values in registers.</para></listitem>
<listitem><para>You would have to code a different function for each type of item you wanted to swap.</para></listitem>
</itemizedlist>

<para>
Here is an example of the macro being used:
</para>

<programlisting>
#define SWAP(a, b, type) { type __tmp_c; c = b; b = a; a = c; }
int main()
{
	int a = 3;
	int b = 5;
	printf("a is %d and b is %d\n", a, b);
	SWAP(a, b, int);
	printf("a is now %d and b is now %d\n", a, b);

	return 0;
}
</programlisting>

<para>
When the C pre-processor is run, it literally changes the text from 
<literal>SWAP(a, b, int)</literal> to 
<literal>{ int __tmp_c; __tmp_c = b; b = a; a = __tmp_c; }</literal>.  Textual substitutaion is a nice, but
fairly limitted feature.  This feature has the following problems:
</para>

<itemizedlist>
<listitem><para>Textual substitution can get very messy when used in combination with other expressions.</para></listitem>
<listitem><para>The C pre-processor only allows a fixed number of arguments to its macros.</para></listitem>
<listitem><para>Because of the C language's type system, we often have to have different macros for different kinds of arguments, or at least pass the type of the parameters as arguments.</para></listitem>
<listitem><para>Because we are only doing textual substitution, C is not smart enough to rename our temporary variable if it conflicts with one of the arguments passed to it.  Our macro would utterly fail if it were passed a variable called <literal>__tmp_c</literal></para></listitem>
</itemizedlist>

<para>
The problem of combining macros with expressions makes macro writing 
fairly difficult.  For example, let's say we had the following macro
called <literal>MIN</literal>, which returned the smaller of two values:
</para>

<programlisting>
#define MIN(x, y) ((x) > (y) ? (y) : (x))
</programlisting>

<para>
First of all, you may be wondering why we used so many parentheses.  The
reason is operator precedence.  For example, if you did 
<literal>MIN(27, b=32)</literal>, without those parentheses it would expand 
into <literal>27 > b = 32 ? b = 32 : 27</literal> which will get a compiler 
error because <literal>27 > b</literal> will bind closer together because of
operator precedence.  If you add the parentheses back in, it will work as
expected.
</para>

<para>
Unfortunately, there's still a second problem - any function that is called 
as a parameter will be called for every time it is listed on the right-hand
side.  Remember, the pre-processor knows nothing about the C language, and is
just doing text substitutions.  Therefore, if you do 
<literal>MIN(do_long_calc(), do_long_calc2())</literal>
then it will expand into <literal>( (do_long_calc()) > (do_long_calc2()) ? (do_long_calc2()) : (do_long_calc()))</literal>.  This will take a long time, since
at least one of the calculations will be performed twice.  It's even worse if
those one of those calculations has side effects (like printing, modifying a
global variable, etc.), because those side effects will happen twice.  This can
cause it to be even incorrect if the functions return different things each time.
</para>

<para>
More information about C pre-processor macro programming is available in the CPP
manual (distributed w/ GCC and available from gcc.gnu.org).
</para>

</sect2>

<sect2>
<title>The M4 Macro Processor</title>

<para>
The M4 macro processor is one of the most advanced textual macro processing 
systems.  It's main claim to fame is with the popular sendmail mailer 
configuration file.  sendmail configuration is not fun or pretty.  There is
an entire book just on sendmail's configuration file.  However, the makers
of sendmail wrote a set of M4 macros to make the process easier.  In the macros
you simply specify certain parameters, and the M4 processor applies boilerplate
that is specific to both your local installation and sendmail in general, and
comes up with a configuration file for you.
</para>

<para>
For example, this is the M4 macro version of a typical sendmail configuration file:
</para>

<programlisting>
divert(-1)
include(`/usr/share/sendmail-cf/m4/cf.m4')
VERSIONID(`linux setup for my Linux dist')dnl
OSTYPE(`linux')
define(`confDEF_USER_ID',``8:12'')dnl
undefine(`UUCP_RELAY')dnl
undefine(`BITNET_RELAY')dnl
define(`PROCMAIL_MAILER_PATH',`/usr/bin/procmail')dnl
define(`ALIAS_FILE', `/etc/aliases')dnl
define(`UUCP_MAILER_MAX', `2000000')dnl
define(`confUSERDB_SPEC', `/etc/mail/userdb.db')dnl
define(`confPRIVACY_FLAGS', `authwarnings,novrfy,noexpn,restrictqrun')dnl
define(`confAUTH_OPTIONS', `A')dnl
define(`confTO_IDENT', `0')dnl
FEATURE(`no_default_msa',`dnl')dnl
FEATURE(`smrsh',`/usr/sbin/smrsh')dnl
FEATURE(`mailertable',`hash -o /etc/mail/mailertable.db')dnl
FEATURE(`virtusertable',`hash -o /etc/mail/virtusertable.db')dnl
FEATURE(redirect)dnl
FEATURE(always_add_domain)dnl
FEATURE(use_cw_file)dnl
FEATURE(use_ct_file)dnl
FEATURE(local_procmail,`',`procmail -t -Y -a $h -d $u')dnl
FEATURE(`access_db',`hash -T&lt;TMPF&gt; -o /etc/mail/access.db')dnl
FEATURE(`blacklist_recipients')dnl
EXPOSED_USER(`root')dnl
DAEMON_OPTIONS(`Port=smtp,Addr=127.0.0.1, Name=MTA')
FEATURE(`accept_unresolvable_domains')dnl
MAILER(smtp)dnl
MAILER(procmail)dnl
Cwlocalhost.localdomain
</programlisting>

<para>
You don't need to understand it, but just know that this small file, after 
being run through the m4 macro processor, generates over 1,000 lines of
configuration.  
</para>

<para>
Similarly, autoconf uses m4 to produce shell scripts based on simple macros.
If you've ever installed a program where the first thing you did was type
in <literal>./configure</literal>, you probably used a program generated using
autoconf macros.  Here is a simple autoconf program which generates a 
<literal>configure</literal> program over 3,000 lines long:
</para>

<programlisting>
AC_INIT(hello.c)
AM_CONFIG_HEADER(config.h)
AM_INIT_AUTOMAKE(hello,0.1)
AC_PROG_CC
AC_PROG_INSTALL
AC_OUTPUT(Makefile)
</programlisting>

<para>
When run through the macro processor, this will create a shell script
that will do the standard configuration checks, look for the standard
paths and compiler commands, and build a <literal>config.h</literal>
and a <literal>Makefile</literal> for you from templates.
</para>

<para>
The details of the m4 macro processor are too in-depth to discuss 
here, but a link to more information about it is available in the
<ulink url="#references">references</ulink> section, as well
as information on these two applications of it -- sendmail and autoconf.
</para>

</sect2>

</sect1>

<sect1>
<title>Programs that Write Programs</title>

<para>
In the previous section, we dealt with the m4 macro system, and showed how 
using macros can turn a little bit of code into a whole lot.  The m4 system
is a generic textual substitution program.  In this section we are going to
look at highly specialized program generators.  
</para>

<sect2>
<title>A Survey of Program Generators</title>

<para>
GNU/Linux systems come with several program-writing programs.  The most popular
are probably:
<itemizedlist>
<listitem><para>Flex - a lexical analyzer generator</para></listitem>
<listitem><para>Bison - a parser generator</para></listitem>
<listitem><para>Gperf - a perfect hash function generator</para></listitem>
</itemizedlist>
</para>

<para>
These tools all generate output for the C language.  You may wonder, though, why
are these implemented as program-generators instead of as functions?  There are several
reasons, among them are:
</para>

<itemizedlist>
<listitem><para>The inputs to these functions are very complicated and not easily expressible in a form that is valid C code.</para></listitem>
<listitem><para>These programs compute and generate many static lookup tables to operate, and therefore it is better to do this once during pre-compile time than during every invocation of the program.</para></listitem>
<listitem><para>Many aspects of the functioning of these systems are customizable with arbitrary code placed in specific positions, which use variables and functions which are part of the structure built by the system.</para></listitem>
</itemizedlist>

<para>
These tools are each focused on building a particular type of program.  Bison is used to generate parsers, and Flex is used to generate
lexical analyzers.  Other tools are more focused on automating specific methods of programming.  For example, Embedded SQL is used to
easily combine database access with C.  While there are many libraries available that allow you to access databases in C, Embedded SQL
makes it much easier by combining SQL entities as part of the C language.  Many Embedded SQL implementations, however, are basically just
specialized macro processors that generate regular C programs as output.  Using the Embedded SQL, however, makes the database access much
more natural, intuitive, and error-free than doing so through the use of libraries.  With Embedded SQL, the intricacies of database programming
are masked by a sort of macro sublanguage.  
</para>

</sect2>

<sect2>
<title>An example use of a program generator</title>

<para>
To see how a program generator works, we'll look at a short Embedded SQL program.  PostgreSQL comes with an Embedded SQL compiler,
<literal>ecpg</literal>.  To run this program, you need to create a database in PostgreSQL called "test".  Then, in that database, issue
the following commands:
</para>

<programlisting>
create table people (id serial primary key, name varchar(50));
insert into people (name) values ('Tony');
insert into people (name) values ('Bob');
insert into people (name) values ('Mary');
</programlisting>

<para>
We will create a simple program to read and print out the contents of the database, sorted by the <literal>name</literal> field.
Here is the program:
</para>

<programlisting>
#include &lt;stdio.h&gt;
int main()
{
	/* Setup database connection -- replace postgres/password w/ the username/password on your system*/
	EXEC SQL CONNECT TO unix:postgresql://localhost/test USER postgres/password;

	/* These variables are going to be used for temporary storage w/ the database */
	EXEC SQL BEGIN DECLARE SECTION;
	int my_id;
	VARCHAR my_name[200];
	EXEC SQL END DECLARE SECTION;

	/* This is the statement we are going to execute */
	EXEC SQL DECLARE test_cursor CURSOR FOR
		SELECT id, name FROM people ORDER BY name;

	/* Run the statement */
	EXEC SQL OPEN test_cursor;

	EXEC SQL WHENEVER NOT FOUND GOTO close_test_cursor;
	while(1) /* our previous statement will handle exitting the loop */
	{
		/* Fetch the next value */
		EXEC SQL FETCH test_cursor INTO :my_id, :my_name;
		printf("Fetched ID is %d and fetched name is %s\n", my_id, my_name.arr);
	}

	/* Cleanup */
	close_test_cursor:
	EXEC SQL CLOSE test_cursor;
	EXEC SQL DISCONNECT;

	return 0;
}
</programlisting>

<para>
If you've done database programming in C before with a regular database library, you can tell that this is a lot more natural way to
code.  Normal C coding does not allow returning multiple return values of arbitrary type, 
but our <literal>EXEC SQL FETCH</literal> line does precisely that.  
</para>

<para>
To compile and run the program, just put it into a file called <literal>test.pgc</literal> and run the following commands:
</para>

<programlisting>
ecpg test.pgc
gcc test.c -lecpg -o test
./test
</programlisting>

</sect2>

<sect2>
<title>Building our own program generator</title>

<para>
Now that we've seen several types of program generators, and the types of things that they can do, we are now
going to write our own small program generator.  Probably the simplest useful program generator we could write
would be one to build static lookup tables.  In programming in C, often times to build fast functions you simply
create a lookup table of all of the answers.  This means that you either need to precompute them by hand (which
is wasteful of your time) or build them at runtime (which is wasteful of the user's time).  Here we will build
a generator that will take a function or set of functions on an integer, and build lookup tables for the answer.
</para>

<para>
To think of how to do this, let's start from the end and work backwards.  Let's say that we want a lookup table that 
will return square roots of numbers between 5 and 20.  Working this out by hand, it would probably look something like this:
</para>

<programlisting>
/* our lookup table */
double square_roots[21];

/* function to load the table at runtime */
void init_square_roots()
{
	int i;
	for(i = 5; i < 21; i++)
	{
		square_roots[i] = sqrt((double)i);
	}
}

/* program that uses the table */
int main ()
{
	init_square_roots();
	printf("The square root of 5 is %f\n", square_roots[5]);
	return 0;
}
</programlisting>

<para>
Now, if we were to convert this to a statically initialized array, we would remove the first part of the program and replace it with something like this:
</para>

<programlisting>
double square_roots[] = {
	/* these are the ones we skipped */ 0.0, 0.0, 0.0, 0.0, 0.0
	2.236068, /* Square root of 5 */
	2.449490, /* Square root of 6 */
	2.645751, /* Square root of 7 */
	2.828427, /* Square root of 8 */
	3.0, /* Square root of 9 */
	...
	4.472136 /* Square root of 20 */
};
</programlisting>

<para>
So, what we need is a program that will produce these values, and print them out like this so they are loaded in at compile-time.
</para>

<para>
Let's analyze the different pieces we have working here:
</para>
<itemizedlist>
<listitem><para>An array name</para></listitem>
<listitem><para>An array type</para></listitem>
<listitem><para>A start index</para></listitem>
<listitem><para>An end index</para></listitem>
<listitem><para>A default value for the skipped entries</para></listitem>
<listitem><para>An expression to compute the final value</para></listitem>
</itemizedlist>

<para>
Therefore, we can simply spell all of these out as a colon-separated list.  So we will probably want our macro 
to look something like this:
</para>

<programlisting>
/* sqrt.in */
/* Our macro invocation to build us the table.  The format is: */
/* TABLE:array name:type:start index:end index:default:expression */
/* VAL is used as the placeholder for the current index in the expression */
TABLE:square_roots:double:5:20:0.0:sqrt(VAL)

int main()
{
	printf("The square root of 5 is %f\n", square_roots[5]);
	return 0;
}
</programlisting>

<para>
Now we just need a program to convert one form into another.  For this
simple example I decided to use Perl, because it can evaluate user code
in a string, and its syntax is largely C-like.  This allows it to load
and process user code dynamically.
</para>

<para>
We want our program generator to pass through all non-templated portions unchanged.
Therefore, the basic organization is going to be this:
</para>

<orderedlist>
<listitem><para>Read in a line</para></listitem>
<listitem><para>Should the line be processed?</para></listitem>
<listitem><para>If so, process the line and generate output.</para></listitem>
<listitem><para>If not, simply copy the line directly to the output unchanged.</para></listitem>
</orderedlist>

<para>
Here is the Perl code to create our table generator:
</para>

<programlisting>
#!/usr/bin/perl
#
#tablegen.pl
#

##Puts each program line into $line
while(my $line = &lt;&gt;)
{
	#Is this a macro invocation?
	if($line =~ m/TABLE:/)
	{
		#If so, split it apart into its component pieces
		my ($dummy, $table_name, $type, $start_idx, $end_idx, $default, $procedure) = split(m/:/, $line, 7);

		#The main difference between C and Perl for mathematical expressions is that
		#Perl prefixes its variables with a dollar sign, so we will add that here
		$procedure =~ s/VAL/\$VAL/g;
	
		#Print out the array declaration
		print "${type} ${table_name} [] = {\n";

		#Go through each array element
		foreach my $VAL (0 .. $end_idx)
		{
			#Only process an answer if we have reached our starting index
			if($VAL &gt;= $start_idx)
			{
				#evaluate the procedure specified (this sets $@ if there are any errors)
				$result = eval $procedure;
				die("Error processing: $@") if $@;
			}
			else
			{
				#if we haven't reached the starting index, just use the default
				$result = $default;
			}

			#Print out the value
			print "\t${result}";

			#If there are more to be processed, add a comma after the value
			if($VAL != $end_idx)
			{ 
				print ","; 
			}

			print "\n"
		}

		#Finish the declaration
		print "};\n";
	}
	else
	{
		#If this is not a macro invocation, just copy the line directly to the output
		print $line;
	}
}
</programlisting>

<para>
To run this program do this:
</para>

<programlisting>
./tablegen.pl &lt; sqrt.in &gt; sqrt.c
gcc sqrt.c -o sqrt
./a.out
</programlisting>

<para>
So in just a few lines of code we created a simple program generator that can dramatically ease 
our programming tasks.  Just with that single macro we can take away a lot of work for any 
program that has to generate mathematical tables indexed by integer.  A little extra work
could also allow tables containing full struct definitions, and a little more would get 
the ability to not waste space at the front of the array with useless empty entries.
</para>

</sect2>


</sect1>

<sect1>
<title>Language-Sensitive Macro Programming with Scheme</title>

<para>
While program generators know a little bit about the target language, they are usually
not full parsers, and cannot fully take the target language into account without rewriting
a complete compiler.  However, this might be simplified if there was a language that was
already represented with a simple data structure.  In the Scheme programming language, 
the language itself is represented as a linked list, and 
<ulink url="http://www.ibm.com/developerworks/linux/library/l-listproc/">the Scheme programming language is built for list processing</ulink>!
This makes Scheme almost the ideal language for creating programs that are transformed -- no massive
parsing is needed to parse the program, and Scheme itself is a list-processing language.
</para>

<para>
In fact, Scheme's abilities to do transformation go even beyond that.  The Scheme standard defines
a macro language specifically built to make it easier to make additions to the language.  On top
of that, most Scheme implementations provide additional features to aid in building 
program-generating programs.
</para>

<para>
Let's re-examine the problems of our C macros.  Let's look first at the <literal>SWAP</literal>
macro.  The problem with this macro is that, first, you had to explicitly say what types of
values you were swapping, and second, you had to use a name for the temporary variable that
you were sure wasn't in use elsewhere.  Let's look at what the equivalent looks like in 
Scheme and how Scheme solves these issues:
</para>

<programlisting>
;;Define SWAP to be a macro
(define-syntax SWAP
	;;We are using the syntax-rules method of macro-building
	(syntax-rules ()
		;;Rule Group
		(
			;;This is the pattern we are matching
			(SWAP a b)
			;;This is what we want it to transform into
			(let
				(
					(c b))
				(set! b a)
				(set! a c)))))

(define first 2)
(define second 9)
(SWAP first second)
(display "first is: ")
(display first)
(newline)
(display "second is: ")
(display second)
(newline)
</programlisting>

<para>
This is a <literal>syntax-rules</literal> macro.  <literal>define-syntax</literal> is
used to define macro transformations in Scheme.  After the <literal>define-syntax</literal>
keyword comes the name of the macro we are defining.  After that comes the transformation.
<literal>syntax-rules</literal> is the type of transformation we are applying.  Within the
parentheses are any other macro-specific symbols we are keeping other than the macro
name itself (we aren't using any).  After that come a sequence of transforming rules.
The syntax transformer will go through each rule and try to find a matching pattern.
After it finds one, it runs the given transformation.  In our case we only have one
patten: <literal>(SWAP a b)</literal>.  <literal>a</literal> and <literal>b</literal> are
pattern variables and are kept as-is throughout the macro.
</para>

<para>
From the initial look of it, it may appear that this has the some of the same pitfalls of 
the C version.  However, since we're dealing with Scheme, the types are bound to the
values themselves, not the variable names, so we don't even have to worry about the type problems with the C version.
However, doesn't this have the same problem of variable naming that the original one had?
Namely, if one of our variables were named <literal>c</literal>, wouldn't that cause a 
conflict?
</para>

<para>
Actually, it wouldn't.  Macros in Scheme using <literal>syntax-rules</literal>
are <emphasis>hygienic</emphasis>.  This means that
all temporary variables used by a macro are automatically renamed 
<emphasis>before the substitution occurs</emphasis> in order to prevent them from having
conflicting names.  Therefore, in this macro, <literal>c</literal> will be renamed to something
else before substitutions if one of the substitution variables is named <literal>c</literal>.
In fact, it will likely be renamed anyway.  Here is a possible result of the macro 
transformation on the program:
</para>

<programlisting>
(define first 2)
(define second 9)
(let 
	(
		(__generated_symbol_1 second))
	(set! second first)
	(set! first __generated_symbol_1))
(display "first is: ")
(display first)
(newline)
(display "second is: ")
(display second)
(newline)
</programlisting>

<para>
As you can see, Scheme's hygienic macros can bring you the benefits of
other macro systems without many of their pitfalls.  However, sometimes
you want macros to not be hygienic.  For example, you may want to 
introduce bindings in your macro which are accessible to the code you
are transforming.  Simply declaring a variable will not do, as the 
<literal>syntax-rules</literal> system will simply rename the variable.
Therefore, most schemes also include a non-hygienic macro system called
<literal>syntax-case</literal>.  <literal>syntax-case</literal> macros
are harder to write, but they are much more powerful, as you have pretty
much the entire Scheme runtime available to you for transformation.  
<literal>syntax-case</literal> macros are not really standard, but they
are implemented on many Scheme systems.  Those that do not have <literal>syntax-case</literal>
usually have other, similar systems available.
</para>

<para>
Let's look at the basic form of a <literal>syntax-case</literal> macro.
Let's define a macro called <literal>at-compile-time</literal>
which will execute a given form during compilation.
</para>

<programlisting>
;;Define our macro
(define-syntax at-compile-time
	;;x is the syntax object to be transformed
	(lambda (x)
		(syntax-case x ()
			(
				;;Pattern just like a syntax-rules pattern
				(at-compile-time expression)

				;;with-syntax allows us to build syntax objects
				;;dynamically
				(with-syntax 
					(
						;this is the syntax object we are building
						(expression-value 
							;after computing expression, transform it into a syntax object
							(datum->syntax-object 
								;syntax domain
								(syntax k) 
								;quote the value so that its a literal value
								(list 'quote 
								;compute the value to transform 
									(eval 
										;;convert the expression from the syntax representation
										;;to a list representation
										(syntax-object->datum (syntax expression))
										;;environment to evaluate in
										(interaction-environment)
										)))))
					;;Just return the generated value as the result
					(syntax expression-value))))))

(define a 
	;;converts to 5 at compile-time
	(at-compile-time (+ 2 3)))
</programlisting>

<para>
This will perform the given operation at compile time (more specifically, this will perform
the given operation at macro-expansion time, which is not always the same as compile time
in Scheme systems).  Any expression that is allowed at compile-time on your Scheme system
will be available to use in this expression.  Now lets see how it works.
</para>

<para>
With <literal>syntax-case</literal>, you actually are defining a transforming function,
which is where the lambda comes in.  The <literal>x</literal> is the expression being
transformed.  <literal>with-syntax</literal> defines additional syntax elements that can
be used in the transforming expression.  <literal>syntax</literal> takes the syntax
elements and combines them back together, following the same rules as the transformer
in <literal>syntax-rules</literal>.  Let's look at what's happening a step at a time:
</para>

<orderedlist>
<listitem><para>The <literal>at-compile-time</literal> expression is matched.</para></listitem>
<listitem><para>In the innermost part of the transformation, <literal>expression</literal> is converted to a list representation, and is evaluated as normal scheme code.</para></listitem>
<listitem><para>The result is the combined with the symbol <literal>quote</literal> into a list, so that Scheme will treat it as a literal value when it becomes code.</para></listitem>
<listitem><para>This data is converted into a syntax object.</para></listitem>
<listitem><para>This syntax object is given the name <literal>expression-value</literal> for expressing it in the output.</para></listitem>
<listitem><para>The transformer <literal>(syntax expression-value)</literal> says that <literal>expression-value</literal> is the entirety of the output from this macro.</para></listitem>
</orderedlist>

<para>
Now that we've defined the ability to perform computations at compile time, we can
use this to make an even better version of the <literal>TABLE</literal> macro that
we defined for the C language.  Here is how you would do it in Scheme with our
<literal>at-compile-time</literal> macro:
</para>

<programlisting>
(define sqrt-table 
	(at-compile-time 
		(list->vector
			(let build
				(
					(val 0))
				(if (> val 20)
					'()
					(cons (sqrt val) (build (+ val 1))))))))

(display (vector-ref sqrt-table 5))
(newline)
</programlisting>

<para>
However, we can even make this easier for ourselves by making a further macro for
table-building that will be remarkably similar to our C language macro:
</para>

<programlisting>
(define-syntax build-compiled-table
	(syntax-rules ()
		(
			(build-compiled-table name start end default func)
			(define name
				(at-compile-time
					(list->vector
						(let build
							(
								(val 0))
							(if (> val end)
								'()
								(if (< val start)
									(cons default (build (+ val 1)))
									(cons (func val) (build (+ val 1))))))))))))

(build-compiled-table sqrt-table 5 20 0.0 sqrt)
(display (vector-ref sqrt-table 5))
(newline)
</programlisting>

<para>
Now we have a function that allows us to easily build whatever kind of tables we wish.
</para>

</sect1>

<sect1>
<title>Review</title>

<para>
This article has covered a large amount of territory, so lets take a moment to review.  First we discussed
which problems were best solvable with a program-generating program.  These included:
</para>

<itemizedlist>
<listitem><para>programs that need pre-generate data tables</para></listitem>
<listitem><para>programs that have a lot of boilerplate code that cannot be abstracted into functiosn</para></listitem>
<listitem><para>programs that use techniques that are overly verbose in the language you are writing them in</para></listitem>
</itemizedlist>

<para>
We then looked at several meta-programming systems and examples of their usage.  This included generic textual substitution systems,
as well as domain-specific program and function generators.  We then examined a specific instance of table-building, and went through
the motions of writing a code-generating program to build static tables in C.
</para>

<para>
Finally, we looked at Scheme, and saw how it was able to tackle the issues we faced in the C language using constructs that were 
part of the language itself.  We saw how Scheme itself was built to be a language and to be a program-generating language for itself.
Because these techniques are built into the language itself, it is both simpler to program and doesn't suffer from many of the same 
problems inherent in other techniques discussed.  This allows the programmer to simply and easily add domain-specific extensions to 
the Scheme language in the place that program generators have traditionally held.
</para>

<para>
In the next installment, we are going to focus more in detail on how Scheme macros are programmed, and how they can make life
significantly easier for large-scale programming tasks.
</para>

</sect1>

<!--- REFERENCES

Need that reference to intermediate macros

<ul>
<li></li>
</ul>


-->

</chapter>
