<?xml version="1.0" encoding="iso-1252" ?>
<chapter>
<title>Addressing Modes, Instruction Formats, and Position-independent Code</title>

<para>
In the previous article, we gave a short outline to assembly language programming and the PowerPC instruction set.  In this article, we are going to explore further the technicalities of PowerPC assembly language programming, focusing on data access methods and the most common PowerPC instruction formats.
</para>

<sect1>
<title>Adddressing Modes and Why They are Important</title>

<para>
Before discussing addressing modes, a review of computer memory concepts is warranted.  The following facts about computer memory and programming are probably already well-known to you, but as modern programming languages attempt to de-emphasize the physical aspects of the computer, they should serve as a good refresher:
</para>

<itemizedlist>
<listitem><para>Every location in main memory is numbered with a sequential numeric <emphasis>address</emphasis> by which the memory location is referred.</para></listitem>
<listitem><para>Every main memory location is one byte long.</para></listitem>
<listitem><para>Larger data types are made by simply treating multiple bytes as a single unit (using two memory locations together for a 16-bit number, for instance)</para></listitem>
<listitem><para>Registers are 4-bytes long on 32-bit platforms, and 64-bytes long on 64-bit platforms</para></listitem>
<listitem><para>Memory can be loaded into registers either 1, 2, 4, or 8 bytes at a time</para></listitem>
<listitem><para>Non-numeric data is stored as numeric data -- the only differences are what operations are used on it and how the data is used</para></listitem>
</itemizedlist>

<para>
It sometimes comes as a surprise to new assembly-language programmers how many different methods there are of accessing memory.  These different methods are called <emphasis>addressing modes</emphasis>.  Different people have different names for address modes, so in other literature the names of these modes may be different.  First we'll discuss the modes themselves, then we'll talk about how they relate to the PowerPC.  Some modes are logically equivalent, but differ in their purpose.  They are considered different addressing modes because they may be implemented differently based on the processor.  
</para>

<para>
There are actually two addressing modes that don't access memory at all.  In <emphasis>immediate mode</emphasis>, the data to be used is part of the instruction (for example, the <literal>li</literal> instruction stands for "load immediate", because the number to be loaded is <emphasis>part of the instruction itself</emphasis>).  In <emphasis>register mode</emphasis>, rather than accessing the contents of main memory, you access registers.
</para>

<para>
The most obvious addressing mode for accessing main memory is called <emphasis>direct addressing mode</emphasis>.  In this mode, the instruction itself contains the address to load the data from.  This mode is often used for accessing global variable access, branching, and subroutine calls.  A similar mode is <emphasis>relative addressing mode</emphasis>, which calculates the address based on the current program counter.  This is often used for short-range branches where the destination is near the current location, so specifying an offset rather than an absolute address makes more sense.  It is similar to direct addressing mode in that, in both types of addressing, the final address is known at either assemble or link time.
</para>

<para>
The <emphasis>indexed addressing mode</emphasis> makes most sense when thought of as a way to access array elements for global variables.  It has two parts - a memory address and an <emphasis>index register</emphasis>.  The index register is added to the specified address, and the result is used as the address to use for the memory access.  Some platforms allow programmers to specify a <emphasis>multiplier</emphasis> for the index register.   Therefore, if each array element is 8-bytes long, you can use 8 as a multiplier.  This allows the index register to be used exactly like an array index.  Otherwise, the index register would have to be increased/decreased in increments of the data size.
</para>

<para>
The <emphasis>register indirect addressing mode</emphasis> uses a register to specify the whole address for the memory access.  This is used for numerous situations, including, but not limitted to:
</para>

<itemizedlist>
<!-- FIXME - more? -->
<listitem><para>Dereferencing pointer variables</para></listitem>
<listitem><para>Any memory access which is not available by other modes (the address can be calculated by other means and store in the register, which is then used for the access)</para></listitem>
</itemizedlist>

<para>
<emphasis>Base-pointer addressing mode</emphasis> acts just like indexed addressing mode (the specified number and the register are added together for the final address), except that the function of the two components are switched.  In base-pointer addressing mode, the register has the base address and the literal number has the offset.  This is very useful for accessing members of a struct.  The register can hold the address of the whole struct, and the numeric portion can be modified depending on the structure member to be accessed.  For instance, let's say that we have a struct that has three fields -- the first is 8-bytes, the second is 4-bytes and the last is 8-bytes.  Then, let's say that the address of the struct itself is in a register we'll call register X.  If we want to access the second member of the structure, we'll need to add 8 to the value in the register.  So, using base-pointer addressing, we would specify register X as the base pointer and 8 as the offset.  To access the third field we would specify register X as the base pointer and 12 as the offset.  To access the first field we can actually use indirect addressing instead of base-pointer addressing since there is no offset (this is why on many platforms the first structure member is the fastest to access -- you can use a simpler addressing mode).
</para>

<para>
Finally, in <emphasis>indexed register indirect addressing mode</emphasis>, both the base and the index are stored in registers.  The memory address used is determined by adding the two registers together.
</para>

</sect1>

<sect1>
<title>Instruction Formats and Addressing Modes for PowerPC</title>

<para>
In order to discuss the details of how addressing modes work on PowerPC processors, we must first understand a little bit about PowerPC instruction format.  The PowerPC uses a load/store (also called RISC) architecture, which means that the <emphasis>only</emphasis> time it accesses main memory is for loading into registers or copying a register to memory.  All processing takes place between registers.  The other main type of processor architecture, CISC (the x86 processor being a popular CISC processor), allows for memory access in nearly every instruction.  The reason for the load/store architecture is that it allows the rest of the processor to be more efficient.  In fact, most modern CISC processors actually translate their instructions to an internalized RISC format for efficiency.
</para>

<para>
Each instruction on the PowerPC is exactly 32 bits long, with the instruction's <emphasis>opcode</emphasis> (the code telling the processor which instruction it is) taking the first six bits.  This length includes all immediate-mode values and explicit addresses.  This makes for a pretty small squeeze.  In fact, the largest length available to any instruction format is only 24 bits!  This would give you, at most, only 16MB of addressable space.  Don't worry -- there's lots of ways around this.  This is just to point out why instruction format matters on the PowerPC processor -- you need to know how much space you have to work with!
</para>

<para>
You don't need to memorize all of the instruction formats to make use of them.  However, knowing some of the basic ones will help you read PowerPC documentation and understand some of the general strategies and nuances used in the PowerPC instruction set.  There are 15 different PowerPC instruction formats, many with several subformats.  However, we only really need to be concerned with 5.  
</para>

<sect2>
<title>The D-Form and DS-Form</title>

<para>
The D-Form instruction is one of the primary memory-access instruction forms.  It looks like this:
</para>

<variablelist>
<varlistentry>
<term>Bits 0-5</term>
<listitem><para>Opcode</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 6-10</term>
<listitem><para>Source/Target Register</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 11-16</term>
<listitem><para>Address/Index Register/Operand</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 16-31</term>
<listitem><para>Numeric Address, Offset, or Immediate-mode Value</para></listitem>
</varlistentry>
</variablelist>

<para>
This form is used to perform loads and stores.  It can be used for the following addressing modes:
</para>

<itemizedlist>
<listitem><para>Immediate addressing mode</para></listitem>
<listitem><para>Direct addressing mode (by specifying zero for the address/index register)</para></listitem>
<listitem><para>Indexed addressing mode</para></listitem>
<listitem><para>Indirect addressing mode (by specifying zero for the address)</para></listitem>
<listitem><para>Base pointer addressing mode</para></listitem>
</itemizedlist>

<para>
As you can see, the D-Form instruction is very flexible, and is used for any register-plus-address memory access form.  However, it's usability for direct addressing and indexed addressing is extremely limitted, because it only has a 16-bit address field to work with!  This gives a maximum range of only 64K.  Therefore, direct and indexed addressing are only rarely used to fetch and store memory.  Immediate, indirect, and base-pointer addressing are the most common use of this form, in which cases the 64K limit is not nearly as problematic.
</para>

<para>
The DS-Form is only used in 64-bit instructions.  It is just like the D-Form, except that it uses the last two bits of the address for an extended opcode.  However, it pads the Value portion of the address to the right with two zeroes.  This gives it the same range as D-Form instructions (64K), but limits it to 32-bit aligned memory.  For the assembler, the value is specified normally -- it is simply condensed by the assembler.  For example, if you wanted an offset of 8, you would still enter 8, the assembler would just convert the value to the bit representation 0b000000000010 instead of 0b00000000001000.  if you entered a value that was not a multiple of 4, the assembler would give an error.
</para>

<para>
In D-Form and DS-Form instructions, note that if the source register is set to 0, instead of using register 0 it simply does not use the register parameter.  
</para>

<para>
Let's now look at instructions built from D-Forms and DS-Forms.
</para>

<para>
Immediate-mode instructions are specified in assembler like this:
</para>

<programlisting>
opcode dst, src, value
</programlisting>

<para>
Here <literal>dst</literal> is the destination register, <literal>src</literal> is a source register (used in computation) and <literal>value</literal> is the immediate-mode value used.  Immediate-mode instructions never use the DS-Form.  Here are some immediate-mode instructions:
</para>

<example>
<title>Immediate-mode instructions</title>
<programlisting>
#Add the contents of register 3 to the number 25 and store in register 2
addi 2, 3, 25    

#OR the contents of register 6 to the number 0b0000000000000001 and store in register 3
ori 3, 6, 0b00000000000001

#Move the number 55 into register 7 
#(remember, when 0 is the second register in D-Form instructions it means ignore the register)
addi 7, 0, 55
#Here is the extended mnemonics for the same instruction
li 7, 55
</programlisting>
</example>

<para>
In the non-immediate-mode uses of the D-Form, the second register is added to the value to give the final address of the memory to load from or store to.  These instructions have the general form:
</para>
<programlisting>
opcode dst, d(a)
</programlisting>

<para>
In this form, the address to load/store is specified as <literal>d(a)</literal> where <literal>d</literal> is the numeric address/offset and <literal>a</literal> is the number of the register to use for the address/offset.  They are added together to give the final effective address for the load/store.  Here are some example D-Form/DS-Form load/store instructions.
</para>

<example>
<title>Load/Store Instruction Examples using the D-Form and DS-Form</title>
<programlisting>
#load a byte from the address in register 2, store it in register 3, and zero out the remaining bits
lbz 3, 0(2)

#store the 64-bit contents (double-word) of register 5 into the address 32 bits past the address specified by register 23
std 5, 32(23)

#store the low-order 32 bits (word) of register 5 into the address 32 bits past the address specified by register 23
stw 5, 32(23)

#store the byte in the low-order 8 bits of register 30 into the address specified by register 4
stb 30, 0(4)

#load the 16 bits (half-word) at address 300 into register 4, and zero-out the remaining bits
lhz 4, 300(0)

#load the half-word (16 bits) that is 1 byte offset from the address in register 31 and store the result sign-extended into register 18
lha 18, 1(31)
</programlisting>
</example>

<para>
If you look carefully, you can see that there is sort of a "base opcode" that is being specified at the beginning of the instruction, with several modifiers following.  <literal>l</literal> or <literal>s</literal> are used for "load" and "store".  <literal>b</literal> gives you a byte, <literal>h</literal> gives you a halfword (16 bits), <literal>w</literal> gives you a word (32 bits), and <literal>d</literal> gives you a doubleword (64 bits).  After this, for loads, the <literal>a</literal> and <literal>z</literal> modifiers tell whether or not the value is sign-extended, or if it is simply zero-padded when loaded into the register.  Finally, a <literal>u</literal> can be attached which tells the processor to update the register used in address calculation with the final computed address of the instruction.
</para>

</sect2>

<sect2>
<title>The X-Form</title>

<para>
The X-Form has the following form:
</para>

<variablelist>
<varlistentry>
<term>Bits 0-6</term>
<listitem><para>Opcode</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 6-10</term>
<listitem><para>Source/Destination Register</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 11-15</term>
<listitem><para>Address Calculation Register A</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 16-20</term>
<listitem><para>Address Calculation Register B</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 21-30</term>
<listitem><para>Extended Opcode</para></listitem>
</varlistentry>
<varlistentry>
<term>Bit 31</term>
<listitem><para>Unused</para></listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
<title>The I-Form and B-Form</title>

</sect2>

<!--

A comprehensive list of instruction formats are listed in section 1.7 of Book 1 of the PowerPC Architecture Guide.  

<para>
</para>

-->

</sect1>

<sect1>
<title>Linkers, Instruction Format Limitations, and Position-independent Code</title>

<para>
</para>

</sect1>

<sect1>
<title>Additional Instruction Options</title>

<para>
</para>

</sect1>

<sect1>
<title>Putting it Together in Real Code</title>

<para>
</para>

</sect1>

</chapter>
