<chapter>
<title>Function Calls and the PowerPC 64-bit ABI</title>

<para>
The <emphasis>ABI</emphasis>, or Application Binary Interface, is the set of conventions that allow programs written in different languages or compiled by different compilers to call each other's functions.  In this article, we will discuss the PowerPC ABI for 64-bit ELF (UNIX-like) systems and how to write and call functions using it.  There is also a 32-bit ABI which is not covered in this article.
</para>

<sect1>
<title>The Simplified ABI</title>

<para>
In the previous article, we discussed the "simplified" ABI.  This allows the writing of functions which meet certain criteria with a minimum of fuss.  These are criteria that a function must meet to use the simplified ABI:
</para>

<itemizedlist>
<listitem><para>It must not call any other function.</para></listitem>
<listitem><para>It may only modify registers 3 through 12.</para></listitem>
<listitem><para>It may only modify condition register fields <literal>cr0</literal>, <literal>cr1</literal>, <literal>cr5</literal>, <literal>cr6</literal>, and <literal>cr7</literal>.</para></listitem>
<listitem><para>It must not alter the link register, unless it restores it before calling <literal>blr</literal> to return.</para></listitem>
</itemizedlist>

<para>
There are a few additional restrictions if your code works with the vector processor as well, but that is beyond the scope of this article.  
</para>

<para>
Interestingly, you need not declare in any way when you are using the simplified ABI, because it is a fully-compatible subset of the normal ABI for functions which do not need <emphasis>stack frames</emphasis> (which we will discuss shortly). 
</para>

<para>
When a function is called using the PowerPC ABI semantics, it passes the parameters to the function in registers.  Register 3 has the first fixed-point parameter, register 4 has the second, and so on through register 10.  Likewise, floating-point values are passed through the floating-point registers 1 through 13.  When the function is completed, the value is returned through register 3, and the function exits using the <literal>blr</literal> instruction.
</para>

<para>
In order to demonstrate the simplified PowerPC ABI, we will write a function that takes one parameter, squares it, and returns it.  Here is the function in assembly language (enter as <literal>my_square.s</literal>):
</para>

<example>
<title>Function to Square a Number Using the Simplified ABI</title>
<programlisting>
###FUNCTION ENTRY POINT DECLARATION###
.section .opd, "aw"
.align 3

.global my_square
my_square:   #this is the name of the function as seen 
	.quad .my_square, .TOC.@tocbase, 0

###FUNCTION CODE HERE###
.text 
.my_square:  #This is the label for the code itself (referenced in the "opd")
	#Parameter 1 -- number to be squared -- in register 3

	#Multiply it by itself, and store it back into register 3
	mulld 3, 3, 3

	#The return value is now in register 3, so we just need to leave
	blr
</programlisting>
</example>

<para>
Notice that previously we were using the <literal>.opd</literal> section for declaring the program's entry point, but here we are also using it to declare a function.  These are called <emphasis>official procedure descriptors</emphasis> and they contain the information the linker needs to put code from multiple sources together.  The most important field is the first one, which is the address of the start of the code for the procedure.  The other fields will be discussed later in the article.   Notice that the only global definition is for the official procedure description.  
</para>

<para>
The C language prototype for this function is:
</para>

<programlisting>
long long my_square(long long val);
</programlisting>

<para>
Here is the C code for using the function (enter as <literal>my_square_tester.c</literal>:
</para>

<example>
<title>C Code for Calling the my_square Function</title>
<programlisting>
#include <stdio.h>

/* make declarations easier to write */
typedef long long int64; 

int64 my_square(int64);

int main() {
    int a = 32;
    printf("The square of %lld is %lld.\n", a, my_square(a));
    return 0;
}
</programlisting>
</example>

<para>
The simple way to compile and run this code is to do the following:
</para>

<programlisting>
gcc -m64 my_square.s my_square_tester.c -o my_square_tester
./my_square_tester
</programlisting>

<para>
The <literal>-m64</literal> flag tells the compiler to use 64-bit instructions, compile using the 64-bit ABI, and use the 64-bit ABI for linking.  It then takes care of all of the linking issues for you (and there are several -- you can see the full list by appending <literal>-v</literal> to the command-line).  
</para>

<para>
As you can see, writing simple functions using the PowerPC ABI si very straightforward.  The issues come in when the functions aren't so simple.
</para>

</sect1>

<sect1>
<title>The Stack</title>

<para>
Now we will get into the more complicated parts of the ABI.
</para>

<sect2>
<title>The Need for a Stack</title>

<para>
Say we have a recursive function.  For simplicity, let's look at the recursive implementation of the factorial function:
</para>

<example>
<title>Factorial Function</title>
<programlisting>
int64 factorial(int64 num) {
      //BASE CASE    
      if (num == 0) {
      	 return 1;
      //RECURSIVE CASE
      } else {
	  return num * factorial(num - 1);
      }
}
</programlisting>
</example>

<para>
This may be easy enough to understand conceptually, but let's examine it concretely.  What is going on here?  What happens, for instance, if we try to find the value of the factorial of 4?  Let's follow the sequence:
</para>

<para>
First, the function will be called, and <literal>num</literal> will be set equal to 4.  Then, because <literal>num</literal> is greater than 0, <literal>factorial</literal> will be called again, this time with 3.  Now, in the new call to <literal>factorial</literal>, <literal>num</literal> is set to 3.  However, this is a <emphasis>different variable than the previous one of the same name</emphasis>.  Even though it is within the same scope, <literal>num</literal> is different this time.  This is because each time a function is called, it has an <emphasis>activation record</emphasis> (also called a <emphasis>stack frame</emphasis>) associated with it.  The activation record contains all of the call-specific data for the function, including parameters and local variables.  This is how recursive functions keep from trashing the values of the variables in other, active function calls.  Each call gets its own activation record, so each time it is called the variables get their own storage space.  <emphasis>Only when the function call is completely finished</emphasis> is the space for the activation record released for reuse.  We will talk about how the activation record is stored shortly.
</para>

<para>
So, with 3 as the value of <literal>num</literal>, we go through the function again, then with 2, then with 1, then with 0.  However, with 0 the function has reached its <emphasis>base case</emphasis>.  The base case is the point where it ceases to call itself, and instead returns.  So, with 0 as <literal>num</literal>, it returns 1 as the result.  The previous function call picks up where it left off (callling <literal>factorial(0)</literal>) and multiplies the result, 1, with the value in <literal>num</literal>, also 1.  This is returned, and the next one waiting is reactivated.  This multiplies the result with its value of <literal>num</literal>, which is 2.  The number 2 is then returned.  In the next function, the result is multiplied by the current value of <literal>num</literal>, which is 3, resulting in 6.  This number is returned to our original function, in which <literal>num</literal> is 4.  This is multiplied with the previous result to get 24.
</para>

<para>
As you can see, when each a function calls another function, its own values and state are suspended while the next function invocation occurs.  If that function again calls other functions, its state is likewise suspended.  When a function returns, the function that called it is revived and it continues from there.  So, as we progress, the "live" function calls look like this:
</para>

<orderedlist>
<listitem><para><literal>factorial(4)</literal> [active]</para></listitem>
<listitem><para><literal>factorial(4)</literal> [suspended], <literal>factorial(3)</literal> [active]</para></listitem>
<listitem><para><literal>factorial(4)</literal> [suspended], <literal>factorial(3)</literal> [suspended], <literal>factorial(2)</literal> [active]</para></listitem>
<listitem><para><literal>factorial(4)</literal> [suspended], <literal>factorial(3)</literal> [suspended], <literal>factorial(2)</literal> [suspended], <literal>factorial(1)</literal> [active]</para></listitem>
<listitem><para><literal>factorial(4)</literal> [suspended], <literal>factorial(3)</literal> [suspended], <literal>factorial(2)</literal> [suspended], <literal>factorial(1)</literal> [suspended], <literal>factorial(0)</literal> [active]</para></listitem>
<listitem><para><literal>factorial(4)</literal> [suspended], <literal>factorial(3)</literal> [suspended], <literal>factorial(2)</literal> [suspended], <literal>factorial(1)</literal> [active]</para></listitem>
<listitem><para><literal>factorial(4)</literal> [suspended], <literal>factorial(3)</literal> [suspended], <literal>factorial(2)</literal> [active]</para></listitem>
<listitem><para><literal>factorial(4)</literal> [suspended], <literal>factorial(3)</literal> [active]</para></listitem>
<listitem><para><literal>factorial(4)</literal> [active]</para></listitem>
</orderedlist>

<para>
As you can see, the suspended function activation records "stack up", and then on the return side, the last function gets taken off of the stack.  
</para>

</sect2>

<sect2>
<title>The Stack Layout</title>

<para>
To implement this, a range of memory is allocated for each program called the <emphasis>program stack</emphasis>.  All programs start off with a pointer to this stack in register 1.  In the PowerPC ABI, register 1 <emphasis>always points to the top of the stack</emphasis>.  This makes it easy for functions to know where their activation record is -- they are simply defined in terms of the stack pointer.  If a function is executing, then the stack pointer is pointing to the whole stack, which is also the top of that function's activation record.  Because activation records are implemented on a stack, they are often referred to as <emphasis>stack frames</emphasis>, but both terms are equivalent.
</para>

<para>
Now, when the "top of the stack" is referred to, that is a conceptual designation.  Physically, in memory, the stack grows downward (from large-numbered memory addresses to small-numbered ones).  So, register 1 will have a pointer to the top of the stack, and references to stack positions which are positive will actuallly be <emphasis>below</emphasis> the top of the stack conceptually, and negative numbers conceptually above.  So, <literal>0(1)</literal> refers to the top of the stack, <literal>4(1)</literal> refers to four bytes down from the top (conceptually), <literal>24(1)</literal> is even lower conceptually, and <literal>100(1)</literal> is lower still.
</para>

<para>
Now that we understand how the stack looks conceptually and physically, let's look at what exactly the individual stack frames hold.  Let's think about the kind of things a stack might need to hold:
</para>

<itemizedlist>
<listitem><para>Function parameters</para></listitem>
<listitem><para>Local variables</para></listitem>
<listitem><para>Saved versions of volatile memory</para></listitem>
<listitem><para>The return address</para></listitem>
</itemizedlist>

<para>
So any function-invocation-specific information might be in a stack frame.  However, the PowerPC ABI actually puts the storage space for the function parameters in the <emphasis>calling function's stack space</emphasis>.  Now, as we saw earlier, function calls actually pass their parameters through registers.  However, space must still be reserved for parameters in order to save their values (the functions may want to use the registers for something else) or for overflow (if there are more parameters than registers available for use, then they need to go in the stack space).  So, when a function sets up its stack space, it has to reserve space for the largest number of parameters it will use in a function call.
</para>

<para>
So, here is the layout of the stack, from a physical memory standpoint (stack offsets, where given, refer to the <emphasis>beginnning</emphasis> of this location in memory):
</para>

<table>
<title>Stack Frame Layout</title>
<tr><th>Contains</th><th>Size</th><th>Beginning Stack Offset</th></tr>
<tr><td>Floating point non-volatile register save area</td><td>Varies</td><td>Varies</td></tr>
<tr><td>General non-volatile register save area</td><td>Varies</td><td>Varies</td></tr>
<tr><td>VRSAVE</td><td>4 bytes</td><td>Varies</td></tr>
<tr><td>Alignment padding</td><td>4 or 12 bytes</td><td>Varies</td></tr>
<tr><td>Vector non-volatile register save area</td>Varies</td><td>Varies (must be quadword-aligned)</td></tr>
<tr><td>Local variable storage</td><td>Varies</td><td>Varies</td></tr>
<tr><td>Parameters for function calls</td><td>Varies (minimum 64 bytes)</td><td><literal>48(1)</literal></td></tr>
<tr><td>TOC save area</td><td>8</td><td><literal>40(1)</literal></td></tr>
<tr><td>Link editor area</td><td>8</td><td><literal>32(1)</literal></td></tr>
<tr><td>Compiler area</td><td>8</td><td><literal>24(1)</literal></td></tr>
<tr><td>Link Register save area</td><td>8</td><literal>16(1)</literal></td></tr>
<tr><td>Condition Register save area</td><td>8</td><literal>8(1)</literal></td></tr>
<tr><td>Pointer to top of previous stack frame</td><td>8</td><td><literal>0(1)</literal></td></tr>
</table>

<para>
We will not be concerned with the floating point, VRSAVE, Vector, or alignment space.  Those topics are outside the scope of this article, and deal with floating point and vector processing.  The TOC, compiler area, and linker area, are all reserved for system use.  All stack values must be doubleword (4-byte) aligned, and the whole frame should be quadword aligned.  All parameters must be quadword-aligned.  The link register save area is used by functions that are called by the one that set up the stack frame.
</para>

<para>
In order that a function can know where its parameters are, parameters are stored from the bottom of memory to the top.  So the first parameter is in <literal>48(1)</literal>, while the second parameter is in <literal>56(1)</literal>.  This way, the function being called can know the exact offset of each parameter, no matter how big the parameter list area is.  Remember, the parameter list area is defined for <emphasis>all</emphasis> of the calls made by a function, and therefore will likely be bigger than necessary on any individual function call.  
</para>

<para>
However, when a function establishes its own stack frame, the offsets to the parameter list now have to be adjusted to account for the function's own stack frame.  So, let's say that function <literal>func1</literal> calls function <literal>func2</literal> with three parameters, and function 2 has a 112-byte stack frame.  If <literal>func2</literal> wants to access the memory for its first parameter, it would refer to it as <literal>160(1)</literal>, because it has to go past its own stack frame (112 bytes) and reach the first parameter in the last frame (48 bytes).  Thankfully, functions rarely have to access their parameter save area because most parameters are passed by register, not in the parameter save area.  However, space must be allocated for them <emphasis>even if there is nothing stored there</emphasis>.  Functions must assume that for the first eight parameters, they are <emphasis>only</emphasis> passed by register, but they will still have a save area available if they need to be stored by the program.
</para>

</sect2>

<sect2>
<title>Writing a Function that Uses the Stack</title>

<para>
Functions create the stack during the beginning of the function, called the function <emphasis>prologue</emphasis>, and tear it down at the end of a function, called its <emphasis>epilogue</emphasis>.  
</para>

<para>
A function's prologue usually follows the following sequence:
</para>

<orderedlist>
<listitem><para>Reserve stack space and save the old stack pointer, using <literal>stdu 1, -SIZE_OF_STACK(1)</literal>.  This will save the old stack pointer and move it atomically.</para></listitem>
<listitem><para>If this function will call another function, or use the link register in any way, it will be saved by the instruction <literal>mflr 0</literal> followed by a store into the link register save area of the function that called this one, using the instruction <literal>std 0, SIZE_OF_STACK+16(1)</literal>.</para></listitem>
<listitem><para>Save all non-volatile registers which will be used during this function (including the condition register, if any of its non-volatile fields will be used).</para></listitem>
</orderedlist>

<para>
The function's epilogue follows the reverse sequence, restoring what had been saved, and then destroying the stack frame using <literal>stdu 1, 0(1)</literal>.
</para>

<para>
Now let's return to the function that we originally implemented without a stack, and as an example, look and see what it would look like with a stack (enter as <literal>my_square.s</literal>):
</para>

<example>
<title>Function to Square a Number Using a Stack</title>
<programlisting>
###FUNCTION ENTRY POINT DECLARATION###
.section .opd, "aw"
.align 3

.global my_square
my_square:   #this is the name of the function as seen
        .quad .my_square, .TOC.@tocbase, 0

###FUNCTION CODE HERE###
.text
.my_square:  #This is the label for the code itself (Referenced in the "opd")
        ##PROLOGUE##
        #Set up stack frame & back pointer (112 bytes -- minimum stack)
        stdu 1, -112(1)
        #Save LR (optional)
        mflr 0
        std 0, 128(1)
        #Save non-volatile registers (we don't have any)

        ##FUNCTION BODY##
	#Parameter 1 -- number to be squared -- in register 3
        mulld 3, 3, 3

	#The return value is now in register 3, so we just need to leave

        ##EPILOGUE##
        #Restore non-volatile registers (we don't have any)
        #Restore LR (not needed in this function, but here anyway)
        std 0, 128(1)
        mtlr 0
        #Restore stack frame atomically
        stdu 1, 0(1)
        #Return
   	blr
</programlisting>
</example>

<para>
That's the exact same code as before, just wrapped with prologue and epilogue code.  But, as mentioned, this code is simple enough that it doesn't need prologue and epilogue code, but is perfectly fine using the simplified ABI.  However, for any function that calls other functions, that function must set up a stack frame.  So, for a simple function that uses a stack frame, let's look at how the factorial function would work in assembly language (enter as <literal>factorial.s</literal>):
</para>

<example>
<title>The Factorial Function in Assembly Language</title>
<programlisting>
###ENTRY POINT###
.section .opd, "aw"
.align 3

.global factorial
factorial:
         .quad .factorial, .TOC.@tocbase, 0

###CODE###
.text
.factorial:
        #Prologue
	stdu 1, -112(1)
	mflr 0
        std 0, 128(1)

	#Function body
	cmpd 

<para>
If there are a lot of registers to save and restore, you can optionally use special the special functions <literal>_savegpr0_XX</literal>, <literal>_savegpr1_XX</literal>, <literal>_restgpr0_XX</literal>, <literal>_restgpr1_XX</literal>, <literal>_savefpr_XX</literal>, and <literal>_restfpr_XX</litereal> described on pages 32-39 of the ABI specification version 1.9 (see Resources).  However, these are not described here.
</para>

<para>




<!--
NOTE - while a function is running, the 288 bytes below the stack pointer is available as volatile storage which is not preserved across function calls.  Interrupt handlers must take care to reserve this region.
-->






So far the programs we have created do not interact with any other programming language or environment, or indeed any other code.  The PowerPC 64-bit ELF ABI defines the calling conventions used for calling functions written by third parties either in assembly language or in other languages on ELF platforms (this covers most UNIX-based systems).  The ABI defines how parameters are passed, what registers are reserved for special use, what happens to registers during function calls, and how return addresses are handled.
</para>

<sect2>
<title>Register Usage</title>

<para>
Since the PowerPC defines 32 registers, the ELF ABI has separated them out into three groups -- <emphasis>dedicated</emphasis>, <emphasis>volatile</emphasis>, and <emphasis>non-volatile</emphasis> registers.
</para>

<para>
The dedicated registers have a specific, continuing function within the ABI.  These are:
</para>

<variablelist>

<varlistentry>
<term>Register 1</term>
<listitem><para>Stack Pointer</para></listitem>
</varlistentry>

<varlistentry>
<term>Register 2</term>
<listitem><para>Table of Contents (TOC) Pointer</para></listitem>
</varlistentry>

</variablelist>

<para>
We talked about register 2 and the TOC in the last article.  It is used primarily to load global variable addresses in position-independent code. Register 1, however, is new.  Register 1 is the <emphasis>stack pointer</emphasis>.  The <emphasis>stack</emphasis> is an area of memory used by functions to hold data that is needed through the life of the function.  The area of the stack used by a specific function invocation is called a <emphasis>stack frame</emphasis>.  If a function is called recursively, each currently-active invocation will have its own stack frame.
</para>

<para>
<emphasis>Volatile</emphasis> registers are registers that a function is free to change without saving a copy of the previous contents.  These are also known as <emphasis>caller-save</emphasis> registers, because if a function that uses these registers wishes to call another function, it must save any of these registers that it wants to preserve.  In the ABI, registers 3 through 10 are volatile, and also contain the function's parameters.  Register 3 holds the first parameter, register 4 the second, and so on.  Register 11 is a volatile register which holds an environment pointer for certain languages (not C or C++).  Register 12 is used for exception handling.  Register 0 is also volatile, but is rarely used.  <!-- FIXME - special exception handling or glink code? -->
</para>

<para>
Register 13-31 are considered <emphasis>non-volatile</emphasis>.  These are also called <emphasis>callee-save</emphasis> registers, becuase if a function wishes to use these registers, it must first save the current contents, and then restore them before return.
</para>

<para>
The separation of volatile and non-volatile registers allows the handling of registers to be optimized based on how they are used.  Volatile registers are often used as a "scratch space" with minimal overhead, especially as a place to save intermediate results of calculations.  Non-volatile registers have a little more overhead for use, but are used for the more permament members of functions.  Non-volatile registers are used starting from the end.  That is, if only two non-volatile registers are used, it should be registers 30 and 31.  If five are used, it should be 27 through 31.  
</para>

</sect2>

<sect2>
<title>Simple Functions</title>
<para>
Now let's look at some a simple program containing functions.  Here is a simple C language program:
<para>

<example>
<title>Simple C Language Program</title>
<programlisting>
int main() {
     return addone(square(5));
}

long square(long val) {
     return val * val;
}

long addone(long val) {
     return val + 1;
}
</programlisting>
</example>

<para>
Here is the code for the same program in assembly language:
</para>

<example>
<title>Simple Program Translated to Assembly Language</title>
<programlisting>

### FUNCTION DESCRIPTORS ###
.section .opd, "aw"
.align 3

#Every function and the entry point has a descriptor

.globl _start
_start:
	.quad ._start, .TOC.@tocbase, 0

.globl square
square:
	.quad ._square, .TOC.@tocbase, 0

.globl addone
addone:
	.quad ._addone, .TOC.@tocbase, 0


### CODE ###
.text
._start:
	#First parameter, 5, is in register 3
	li 3, 5
	#Call the function
	bl square
	#Extra space for the linker
	nop
	#Return value is in register 3

	#Register 3 already has the value we want
	#Call the function
	bl addone
	#Extra space for the linker
	nop
	#Return value is in register 3

	#Register 3 already has the value we want
	#Exit system call
	li 0, 1
	sc

._square:
	#Multiply (32-bit) register 3 by register 3 into register 3
	mullw 3, 3, 3

	#Return (using link register)
	blr

._addone:
	#Add one to register 3
	addi 3, 3, 1

	#Return (using link register)
	blr
</programlisting>
</example>

<para>
As you can see, since we only made use of the volatile registers and never called other functions, we never had to even set up a stack frame.  In addition, because we never made use of the link register, at the end of the function it still had the return address so we could return with a simple <literal>blr</literal>.  The functions' return values are stored in register 3.  Finally, each procedure was described in the <literal>.opd</literal> section just like the <literal>_start</literal> entry point is described.
</para>

<para>
There are three interesting things to note about the way that the functions are called as well.  First of all, the <literal>bl</literal> instruction was used in order to put the return address in the link register.  Second of all, the target address of the branch was <emphasis>not</emphasis> the function itself, but rather the functions procedure declaration!  The linker will resolve this to actually point to the code.  However, in some cases, the linker will actually branch to some auto-generated code if it needs to do anything fancy like change out the TOC pointer in register 2.  Finally, each function call is immediately followed by a <literal>nop</literal> (no operation) instruction.  This is again for the linker, so that it can insert an instruction here to do any necessary clean-up code with the TOC pointer.
</para>

<para>
Now that we know what the code does, let's try combining C and assembly language code in one program.
</para>

<para>
Start by removing the <literal>._start</literal> code from the assembly language listing, as well as the <literal>_start</literal> function descriptor in the <literal>.opd</literal> section.  Call this file <literal>math.s</literal>.  In the C language program, remove the <literal>square</literal> and <literal>addone</literal> functions and put it in a file called <literal>mathdriver.c</literal>.  Now compile them all together using the following command:
</para>

<programlisting>
gcc math.s mathdriver.c -o mathdriver
./mathdriver
echo $?
</programlisting>

<para>
The program should give you <literal>25</literal>.
</para>

</sect2>


<sect2>
<title>Calling C Functions from Assembly Language</title>
<para>
Calling C functions from assembly language is just as easy.  Here is the assembly code for opening a file specified on the command line and writing "Hello World!" into it:
</para>

<example>
<title>Using C Functions from Assembly Language</title>
<programlisting>
.section .data
.align 3
hello_world_str:
	.ascii "Hello World!\n\0"
.align 3
write_mode_str:
	.ascii "w\0"

.section .opd, "aw"
.align 3
.globl _start
_start:
	.quad ._start, .TOC.@tocbase, 0

.section .text
._start:
	#Register 4 has char **argv
	#Grab argument #1
	ld 3, 8(4)
	#Grab argument #2
	ld 4, write_mode_str@got(2)
	#Call the C function fopen
	bl fopen
	nop

	#Register 3 has the file pointer
	#Move it into register 31 to be saved after function calls
	#(note -- we don't need to save register 31 ourselves because
	#this is the top-level function).
	rm 31, 3

	#Argument #1 is already loaded in register 3
	#Move the pointer to the string into register 4 (argument #2)
	ld 4, hello_world_str@got(2)
	bl fprintf
	nop

	#Now we need to run fclose.  The first parameter is the file pointer,
	#which is saved in register 31
	rm 3, 31
	bl fclose
	nop

	#Run the exit system call
	li 0, 1
	li 3, 0
	sc
</programlisting>
</example>
	
<para>
You can either assemble your program using <literal>gcc</literal> like this:
</para>

<programlisting>
gcc -m64 hello.s -o hello -nostartfiles
</programlisting>

<para>
Or you can do it manually using the assembler, like this:
</para>

<programlisting>
as -a64 hello.s -o hello.o
ld -melf64ppc -dynamic-linker /lib64/ld64.so.1 -L/usr/lib64 -lc hello.o -o hello
</programlisting>

<para>
This assembles using the 64-bit ABI into an object file.  That object file is then linked using the 64-bit ABI using the dynamic linker at <literal>/lib64/ld64.so.1</literal>.  It is linked to the C library using <literal>-lc</literal>.
</para>

<para>
The code itself does not quite follow the ABI, as we will see shortly, but it works well enough for a demonstration.  Function arguments are put into registers 3 through 10.  The function itself is called using the <literal>bl</literal> instruction, which sets the link register to the return address after branching.  The target for the instruction, when specified in assembly language, actually isn't the branch target code itself, but the address of the procedure descriptor in the <literal>.opd</literal> section.  The linker will take care of making sure that when the file is linked the instruction branches to the correct address.  Immediately following the branch instruction should be a <literal>nop</literal> instruction, which essentially leaves space for the linker to add in a clean-up instruction after the function call if it is necessary.
</para>
	
</sect2>

<sect2>
<title>Setting Up Stack Frames</title>

<para>
Since PowerPC uses registers as the primary mechanism for passing arguments, the way that it sets up stack frames (also known as activation records) is a little different.  In general, stack frames are used to hold values that are valid for the current function.  This includes things like parameters and local variables that a function uses for processing, but also record-keeping oriented data such as the return address of the caller and the location of the previous stack frame.  It is called a stack because each frame is allocated new at each function call, and stacked upon the rest of the stack frames.  This allows functions to be called recursively -- each activation of the function receives its own frame, and therefore has its own copy of local variables.
</para>

<para>
The structure of the PowerPC stack frame is a little different, because a function allocates stack space for use by both itself and the functions it calls.  Register 2 always holds the current stack pointer.  The stack actually grows downward, from high memory locations to lower ones.
</para>

<para>
The stack is layed out like this in memory:
</para>

<variablelist>

<varlistentry>

<varlistentry>
<term>Floating Point Save Area</term>
<listitem><para>This is a variable-sized location which can hold old values for non-volatile floating point registers.</para></listitem>
</varlistentry>

<varlistentry>
<term>General Register Save Area</term>
<listitem><para>This is a variable-sized location which can hold old values for non-volatile general-purpose registers.</para></listitem>
</varlistentry>

<varlistentry>
<term>VRSAVE Save Word</term>
<listitem><para>This is a 32-bit location used for vector processing.</para></listitem>
</varlistentry>

<varlistentry>
<term>Alignment Padding</term>
<listitem><para>????</para></listitem>
</varlistentry>

<varlistentry>
<term>Vector Register Save Area</term>
<listitem><para>This is a quadword aligned, variable-lenghth area, used for vector processing.</para></listitem>
</varlistentry>

<varlistentry>
<term>Local Variables</term>
<listitem><para>This is a variable-length area which can be used for storing local variables.</para></listitem>
</varlistentry>

<varlistentry>
<term>Parameter Save Area</term>
<listitem><para>This is a variable-length area which is used to store parameters for <emphasis>functions that the current function will call</emphasis>.  This means that the size should be based on the largest parameter list for any function call, but it must also be a minimum of eight doublewords (64 bytes).  It is located 48 bytes above the current stack pointer (remember, the stack grows downward), and the first entry is accessed as <literal>40(2)</literal></para></listitem>
</varlistentry>

<varlistentry>
<term>TOC save area</term>
<listitem><para>This can be used to save the TOC, if needed</para></listitem>
</varlistentry>

<varlistentry>
<term>Link Editor Doubleword</term>
<listitem><para>This 64-bit space is reserved by the linker its own use.  It can be accessed with <literal>32(2)</literal>.</para></listitem>
</varlistentry>

<varlistentry>
<term>Compiler Doubleword</term>
<listitem><para>This 64-bit space is reserved by the compiler for its own use.  It can be accessed with <literal>24(2)</literal></para></listitem>
</varlistentry>

<varlistentry>
<term>LR Save Area</term>
<listitem><para>This is where to save the return address (sent in the link register) of the current function call.  It can be accessed with <literal>16(2)</literal>.</para></listitem>
</varlistentry>


<varlistentry>
<term>CR Save Area</term>
<listitem><para>This is where the old value of the condition register can be stored if the function uses a non-volatile field of this register (we will talk about register fields in a later article -- for now this can be considered unused).  It can be accessed with <literal>8(2)</literal>.</para></listitem>
</varlistentry>

<term>Back Chain Pointer</term>
<listitem><para>The stack pointer points to this value in memory.  It contains the address of the previous stack frame.  It can be accessed with <literal>0(2)</literal>.</para></listitem>
</varlistentry>

</variablelist>

<para>
For functions which do not call other functions, setting up a stack frame is often not necessary.  However, every function which does call other functions requires a stack frame to do so in order to hold the return address, parameters for functions, and other information needed in the function.  A fairly standard <emphasis>function prologue</emphasis> and <emphasis>function epilogue</emphasis> has been established for setting up and tearing down stack frames in functions.
</para>

<para>
The typical function prologue does the following:
</para>

<itemizedlist>
<listitem><para>Reserves stack space and saves the back chain pointer atomically with <literal>stdu 2, -SIZE_OF_STACK(2)</literal> (<literal>SIZE_OF_STACK</literal> should be rounded up to the nearest 16 bytes)</para></listitem>
<listitem><para>Saves the link register</para></listitem>
<listitem><para>Saves the condition register if necessary</para></listitem>
<listitem><para>Saves any necessary non-volatile registers</para></listitem>
</itemizedlist>

<para>
The code for doing that looks like this:
</para>

<example>
<title>Function Prologue</title>
<programlisting>
### Allocate Stack Frame and Store Back Chain Pointer ###
stdu 2, -SIZE_OF_STACK(2)

### Save LR and CR ###
#register 0 is often used for loading and unloading parameters 
#in prologues and epilogues
mflr 0
std 0, 16(2)
mfcr 0
std 0 8(2)

### Save Non-Volatile Registeres ###
#We will save registers 25-31 in this example





</sect2>

<sect2>
<title>How a Process Starts</title>

<para>
When the loader first loads a program into memory, it loads the following registers:
</para>

<variablelist>

<varlistentry>
<term>Register 1</term>
<listitem><para>Stack pointer</para></listitem>
</varlistentry>

<varlistentry>
<term>Register 2</term>
<listitem><para>TOC Pointer</para></listitem>
</varlistentry>

<varlistentry>
<term>Register 3</term>
<listitem><para>The command-line argument count (<literal>int argc</literal> in C)</para></listitem>
</varlistentry>

<varlistentry>
<term>Register 4</term>
<listitem><para>A pointer to the array of argument pointers in the stack (<literal>char **argv</literal> in C)</para></listitem>
</varlistentry>

<varlistentry>
<term>Register 5</term>
<listitem><para>A pointer to the array of environment variables in the stack</para></listitem>
</varlistentry>

<varlistentry>
<term>Register 6</term>
<listitem><para>A pointer to operating-system-specific information</para></listitem>
</varlistentry>

<varlistentry>
<term>Register 7</term>
<listitem><para>If not zero, it is a pointer to a function to call before exitting</para></listitem>
</varlistentry>

</variablelist>

<para>
<!-- FIXME - write more about this here -->
</para>

</sect2>

<sect2>
<title>Calling Other Functions</title>

</sect2>


<para>
The first thing to think about in the ABI is the use of registers.  As mentioned in the previous article, 

</sect1>

<!--
http://www.busybox.net/cgi-bin/viewcvs.cgi/trunk/docs/crt.txt?rev=15718
-->

