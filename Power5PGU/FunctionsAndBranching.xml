<chapter>
<title>Branching, Functions, and the PowerPC ABI</title>

<para>
In the last two articles, we have discussed the outline of how programs on the POWER5 work using the PowerPC instruction set, how the PowerPC instruction set addresses memory, and how to do position-independent code.  This article focuses on the very powerful branch instructions available in the PowerPC instruction set, as well as the details of the PowerPC 64-bit ABI, which can be used to integrate PowerPC assembly language with high-level languages.
</para>

<sect1>
<title>Branching Registers</title>

<para>
Branches in PowerPC make use of three special-purpose registers -- the <emphasis>condition register</emphasis>, the <emphasis>count register</emphasis> and the <emphasis>link register</emphasis>.  
</para>

<sect2>
<title>The Condition Register</title>

<!-- FIXME -- information on fields is WRONG -->
<!-- FIXME -- move non-comparison conditions to advanced -->

<para>
The condition register is broken up conceptually into three <emphasis>fields</emphasis>.  The first field (called <literal>CR0</literal>) is used for the results of computation instructions which use non-immediate operands (with a few exceptions).  The result of the computation is compared with zero, and the appropriate bits are set (negative, zero, or positive).  To indicate to an instruction that you want it to set <literal>CR0</literal>, you simply add a period (<literal>.</literal>) to the end of the instruction.  For example, <literal>add 4, 5, 6</literal> adds register 5 to register 6 and store the result in register 4, without setting any status bits in <literal>CR0</literal>.  However, <literal>add. 4, 5, 6</literal> does the same thing, but sets the bits in <literal>CR0</literal> based on the value stored in register 4.  
</para>

<para>
The second field (called <literal>CR1</literal>) is used by floating point instructions using the period after the instruction name.  Floating point is outside the scope of this article.
</para>

<para>
The third field (called <literal>CR2</literal>) is set as the result of comparison instructions.  This has fields for less-than, greater-than, and equal-to, and is used for both integer and floating point comparisons.
</para>

</sect2>

<sect2>
<title>The Count and Link Registers</title>

<para>
The link register (called <literal>LR</literal>) is a special-purpose register which holds return addresses from branch instructions.  All branch instructions can be told to set the link register, which, if the branch is taken, sets it to the address of the instruction immediately following the current instruction.  Branch instructions set the link register by appending the letter <literal>l</literal> to the end of the instruction.  For instance, <literal>b</literal> is an unconditional branch instruction, and <literal>bl</literal> is an unconditional branch instruction which sets the link register.
</para>

<para>
The count register (called <literal>CTR</literal>) is a special-purpose register designed to hold loop counters.  Special branch instructions can decrement the count register and/or conditionally branch depending on whether <literal>CTR</literal> has reached zero.  These instructions are outside of the scope of this article.
</para>

<para>
Both the link and count registers can be used as a branch destination.  <literal>bctr</literal> branches to the address specified in the count register and <literal>blr</literal> branches to the address specified in the link register.
</para>

<para>
The link and count registers can also be loaded and copied from general purpose registers. For the link register, <literal>mtlr</literal> moves a given register value <emphasis>to</emphasis> the link register and <literal>mflr</literal> moves a value <emphasis>from</emphasis> the link register to a general-purpose register.  <literal>mtctr</literal> and <literal>mfctr</literal> do the same for the count register.
</para>

</sect2>

</sect1>

<sect1>
<title>Unconditional Branching</title>

<para>
Unconditional branching on PowerPC instruction sets uses the I-Form instruction format:
</para>

<variablelist>
<title>I-Form Instruction Format</title>
<varlistentry>
<term>Bits 0-5</term>
<listitem><para>Opcode</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 6-29</term>
<listitem><para>Absolute or Relative Branch Address</para></listitem>
</varlistentry>
<varlistentry>
<term>Bit 30</term>
<listitem><para>Absolute Address Bit -- If this field is set, the instruction is interpretted as an absolute address, otherwise it is interpretted as a relative address</para></listitem>
</varlistentry>
<varlistentry>
<term>Bit 31</term>
<listitem><para>Link Bit -- If this field is set, the instruction sets the link register with the address of the next instruction.</para></listitem>
</varlistentry>
</variablelist>

<para>
As mentioned earlier, adding the letter <literal>l</literal> onto a branch instruction causes the link bit to be set, so that the "return address" (the instruction after the branch) is stored in the link register.  If you affix the letter <literal>a</literal> at the end (it comes after the <literal>l</literal> if that is used), then the address specified is an absolute address (this is not often used in user-level code, because it limits the branch too much).
</para>

<para>
Here is an example program which illustrates unconditional branches, and then exits:
</para>

<example>
<title>Unconditional Branching Examples</title>
<programlisting>
### ENTRY POINT DECLARATION ###
.section .opd, "aw"
.align 3
.globl _start
_start:
        .quad ._start, .TOC.@tocbase, 0

### PROGRAM CODE ###
.text
#branch to target t2
._start:
        b t2

t1:
#branch to target t3, setting the link register
        bl t3
#This is the instruction that it returns to
        b t4

t2:
#branch to target t1 as an absolute address
        ba t1

t3:
#branch to the address specified in the link register
#(i.e. the return address)
        blr

t4:
        li 0, 1
        li 3, 0
        sc
</programlisting>
</example>

<para>
Notice that the targets for both <literal>b</literal> and <literal>ba</literal> are specified the same way.  The assembler and linker take care of converting the target address into a relative or absolute address for you.
</para>

</sect1>

<sect1>
<title>Conditional Branching</title>

<sect2>
<title>Comparing Registers</title>

<para>
The <literal>cmp</literal> instruction is used to compare registers with other registers or immediate operands, and set the appropriate status bits in the condition register.  Compare instructions are written like the following:
</para>

<example>
<title>Examples of Compare Instructions</title>
<programlisting>
#Compare register 3 and register 4 as doublewords (64 bits)
cmpd 3, 4

#Compare register 5 and register 10 as unsigned doublewords (64 bits)
cmpld 5, 10

#Compare register 6 with the number 12 as words (32 bits)
cmpwi 6, 12
</programlisting>
</example>

<para>
As you can see, the <literal>d</literal> specifies the operands as doublewords while the <literal>w</literal> specifies the operands as words.  The <literal>i</literal> indicates that the last operand is an immediate value instead of a register, and the <literal>l</literal> tells the processor to do unsigned (also called <emphasis>logical</emphasis> comparisons instead of signed comparisons.
</para>

<para>
Each of these instructions set the appropriate bits in the condition register, which can then be used by a conditional branch instruction.
</para>

</sect2>

<sect2>
<title>Basics of Conditional Branching</title>

<para>
Conditional branches are a lot more flexible than unconditional branches, but it comes at a cost of branchable distance.  Conditional branches use the B-Form instruction format:
</para>

<variablelist>
<title>The B-Form Instruction Format</title>
<varlistentry>
<term>Bits 0-5</term>
<listitem><para>Opcode</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 6-10</term>
<listitem><para>Specifies the options used regarding how the bit is tested, whether and how the counter register is involved, and any branch prediction hints (called the <literal>BO</literal> field)</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 11-15</term>
<listitem><para>Specifies the bit in the condition register to test (called the <literal>BI</literal> field)</para></listitem>
</varlistentry>
<varlistentry>
<term>Bits 16-29</term>
<listitem><para>Absolute or Relative Address</para></listitem>
</varlistentry>
<varlistentry>
<term>Bit 30</term>
<listitem><para>Addressing Mode -- when set to 0 the specified address is considered a relative address; when set to 1 the address is considered an absolute address</para></listitem>
</varlistentry>
<varlistentry>
<term>Bit 31</term>
<listitem><para>Link Bit -- when set to 1 the <emphasis>link register</emphasis> is set to the address following the current instruction; when set to 0 the link register is not set</para></listitem>
</varlistentry>
</variablelist>

<para>
As you an see, a full 10 bits are used to specify the branch condition, which limits the address size to only 14 bits, or a 16K range.  This is usable for small jumps within a function, but not much else.  To conditionally call a function outside of this 16K range, the code would need to do a conditional branch to an instruction containing an unconditional branch.
</para>

<para>
The basic forms of the conditional branch look like this:
</para>

<programlisting>
bc BO, BI, address
bcl BO, BI, address
bca BO, BI, address
bcla BO, BI, address
</programlisting>

<para>
In this basic form, <literal>BO</literal> and <literal>BI</literal> are numbers.  Thankfully, we don't have to memorize all the numbers.  The extended mnemonics of the PowerPC come to the rescue again, and we can avoid having to memorize all of the field numbers.  The <literal>l</literal> sets the link register and the <literal>a</literal> uses absolute addressing instead of relative addressing.
</para>

<para>
For a simple compare and branch if equal, the basic form looks like this:
</para>

<example>
<title>Basic form of the conditional branch</title>
<programlisting>
#compare register 4 and 5
cmpd 4, 5
#branch if they are equal
bc 12, 10 address
</programlisting>
</example>

<para>
<literal>bc</literal> stands for "branch conditionally".  The <literal>12</literal> means to branch if the given condition register field is set, with no branch prediction hint, and <literal>10</literal> is the bit of the condition register to test (it is the equal bit).  Now, very few people, especially beginners, are going to be able to remember all of the branch codes and condition register bit numbers.  Therefore, the extended mnemonics can help out in the majority of cases.  Here are the extended mnemonics for the simplest cases:
</para>

<variablelist>
<title>Extended Mnemonics for Simple Branches</title>
<varlistentry>
<term>beq</term>
<listitem><para>Branch if equal</para></listitem>
</varlistentry>
<varlistentry>
<term>bne</term>
<listitem><para>Branch if not equal</para></listitem>
</varlistentry>
<varlistentry>
<term>blt</term>
<listitem><para>Branch if less than</para></listitem>
</varlistentry>
<varlistentry>
<term>ble</term>
<listitem><para>Branch if less than or equal to</para></listitem>
</varlistentry>
<varlistentry>
<term>bgt</term>
<listitem><para>Branch if greater than</para></listitem>
</varlistentry>
<varlistentry>
<term>bge</term>
<listitem><para>Branch if greater than or equal to</para></listitem>
</varlistentry>
</variablelist>

<para>
So the previous example would be rewritten as:
</para>

<example>
<title>Example Conditional Branch with Extended Mnemonics</title>
<programlisting>
#compare register 4 and 5
cmp 4, 5
#branch if they are equal
beq address
</programlisting>
</example>

</sect2>

<para>
As you can see this is much easier to read and write.
</para>

</sect1>


</sect1>

<sect1>
<title>Function Calls Using the PowerPC ABI</title>

<para>
</para>

</sect1>

<sect1>
<title>Putting it all Together</title>

<para>
</para>

</sect1>

</chapter>
