<?xml version="1.0" encoding="utf-8" ?>
<chapter>
<title>Introduction to Playstation 3 / CBE Programming</title>
<para>
In the previous parts of the series, we covered programming using the PowerPC 64-bit instruction set.  This instruction set is used on numerous processors, including the POWER4, POWER5, and the Cell Broadband Engine -- the chip used in the new Playstation 3.  However, the PowerPC is only one element of the Cell Broadband Engine.  The Cell actually consists of 9 elements -- a single dual-core Power Processing Element (PPE), and eight Synergistic Processing Elements (SPE), which are essentially general-purpose vector processing elements.  Vector processing elements can operate on multiple values simultaneously.   Like the PPE, the SPE can be programmed in a number of programming languages, including C and assembly language.  However, even more so than with the PPE, SPEs give the programmer a lot more control to squeeze every ounce of processing power out of it.  Therefore, while not strictly necessary, learning to program the SPE in assembly language will train your mind to program more efficiently for this processor in any language, and especially in C.  This article assumes that the reader has an understanding of PowerPC assembly language, as many concepts will be introduced in relation to their PowerPC counterparts.  This first article will not cover much of the vector aspects of the SPU, but rather it starts with the scalar (one value at a time)  aspects to make your first dive into SPU programming more familiar.
</para>

<sect1>
<title>What is an SPE?</title>
<para>
The Synergistic Processing Element (SPE), is a general-purpose vector processor with some unusual characteristics which help it to operate at high speeds with low memory consumption.  For starters, it does not have the interrupt facilities available on the PowerPC.  This means that it is incapable of performing operating-system tasks or time-sharing.  Those features have been sacrificed for the ability to go at high speeds with low power consumptions.  Even more importantly, they do not have any virtual memory features, and in fact can only reference a small 256K local store, which must hold both the program and data.  Memory is transferred between the local store and main memory using DMA.  Other differences between the the PPE and the SPE are listed below:
</para>
<table>
<title>Some Differences Between PPEs and SPEs</title> 
<tr><th></th><th>PPE</th><th>SPE</th></tr>
<tr><th># General-Purpose Registers</th><td>32 fixed-point and 32 floating-point</td><td>128 general-purpose (capable of either floating or fixed)</td></tr>
<tr><th>Register Size</th><td>64 bits</td><td>128 bits</td></tr>
<tr><th>Maximum Memory Size</th><td>Practically Unlimited</td><td>256K</td></tr>
<tr><th>Virtual Memory?</th><td>Yes</td><td>No</td></tr>
<tr><th>Interrupt Facilities?</th><td>Yes</td><td>No</td></tr>
<tr><th>Capable of Direct File I/O?</th><td>Yes</td><td>No</td></tr>
</table>
<para>
As you can see, the differences between the PPE and the SPE means that they will be used and programmed much differently.  The PPE is used for most general-purpose operating system tasks, timesharing, and maintaining system resources.  The SPEs are used for specialized numeric processing of small batches of data, which are shuffled in and out of local store from main memory using DMA operations.  Also note that the term SPE and PPE refer to the elements in their entirety - the processor, cache (if it has one), memory store, and buses.  When referring just to the processor itself, the term SPU and PPU are used instead.  
</para>
<para>
More information about the architecture of the Cell Broadband Engine is available in the resources section.
</para>

</sect1>

<sect1>
<title>A Simple Example Program</title>

<para>
To begin with, we will enter in a simple program for calculating the factorial of a 32-bit number using a recursive algorithm.  Unfortunately, it will only return the result as the exit code, so the result must be less than 256.
</para>

<para>
For reference, here is the C code which would perform the same function:
</para>

<example>
<title>C Version of Factorial Program</title>
<programlisting>
int number = 4;
int main() {
	return factorial(4);
}
int factorial(int num) {
	if(num == 0) {
		return 1;
	} else {
		return num * factorial(num - 1);
	}
}
</programlisting>
</example>

<sect2>
<title>Entering and Running the Program</title>

<para>
Enter the following as <filename>factorial.s</filename>:
</para>

<example>
<title>First SPE Program</title>
<programlisting>
###DATA SECTION###
.data
#Alignment is _critical_ in SPU applications.
#This aligns to a 16-byte (128-bit) boundary
.align 4
#This is the number
number:
        .long 4


###CODE SECTION###
.text

##MAIN ENTRY POINT
.global main
.type main,@function
main:
        ##NOTE -- some special tricks are in use here to reduce
        #         the size of this function, because we are
        #         concentrating on the factorial function
        #Load number as the first parameter (relative addressing)
        lqr $3, number
        #Branch to factorial
        br factorial

##FACTORIAL FUNCTION
#Define frame size as 48 bytes
#  - 16 bytes for the back pointer
#  - 16 bytes for the link register
#  - 16 bytes for a local variable
.equ FRAME_SIZE, 48
#Offset in the stack frame of the link register
.equ LR_OFFSET, 16
#Offset in the stack frame of the local "num" variable
.equ LCL_NUM_VALUE, 32

factorial:
        ##PROLOGUE##
        #Before we set up our stack frame,
        #store link register in caller's frame
        stqd $lr, LR_OFFSET($sp)
        #Store back pointer before reserving the stack space
        stqd $sp, -FRAME_SIZE($sp)
        #Move stack pointer to reserve stack space
        ai $sp, $sp, -FRAME_SIZE
        ##END PROLOGUE##

        #Save arg 1 in local variable space
        stqd $3, LCL_NUM_VALUE($sp)
        #Compare to 0, and store comparison in reg 4
        ceqi $4, $3, 0
        #Do we jump? (note that the "zero" we are comparing
        #to is the result of the above comparison)
        brnz $4, case_zero

case_not_zero:
        #remove 1, and use it as the function argument
        ai $3, $3, -1
        #call factorial function (return value in reg 3)
        brsl $lr, factorial
        #Load in the value of the current number
        lqd $5, LCL_NUM_VALUE($sp)
        #multiply the last factorial answer with the current number
        #store the answer in register 3 (the return value register)
        mpyu $3, $3, $5

        #Restore previous stack frame
        ai $sp, $sp, FRAME_SIZE
        #Restore link register
        lqd $lr, LR_OFFSET($sp)
        #Return
        bi $lr

case_zero:
        #Put 1 in reg 3 for the return value
        il $3, 1
        #Restore previous stack frame
        ai $sp, $sp, FRAME_SIZE
        #Return
        bi $lr
</programlisting>
</example>

<para>
To build the program, we will just use the C compiler:
</para>

<programlisting>
spu-gcc -o factorial factorial.s
</programlisting>

<para>
Now, the Cell does not run SPE programs directly.  It actually requires that the main code be written for the PPE to manage resources.  However, Linux will, if given an SPE-only program, create a skeleton PPE process to manage the SPE program for you.  So you can just run the program as normal:
</para>

<programlisting>
./factorial
echo $?
</programlisting>

<para>
Don't be taken back by the size of the code -- it's mostly comments and declarations.  The factorial function itself only has 16 instructions.
</para>

</sect2>

<sect2>
<title>Analyzing the Program</title>

<para>
Now let's take a look at what each instruction does, and how programming on the SPE differs from programming on the PPE which we have done in previous articles.
</para>

<para>
The program starts off with a typical data declaration which holds the value we want to compute the factorial of in a space labelled <literal>number</literal>.  However, note that before we define <literal>number</literal>, we align it using <literal>.align 4</literal>.  This aligns the next memory location to a 16-byte (2^4) boundary.  This is critical, as the SPU can only load exactly 16 bytes at a time, aligned to exactly a 16-byte boundary.  If it is given an address that is not at a 16-byte boundary, it simply zeroes out the last four bits of the address before loading to do the alignment.  Therefore, if our value is not properly aligned, it will be loaded somewhere in the register that we probably don't expect.  By aligning it to a 16-byte boundary, we know that it will load into the first four bytes of the register.
</para>

<para>
In the code section, notice that unlike for the PPE, we do not need function descriptors.  We simply declare each function name as being global and tell the assembler that it is a function.  The SPE does not need function descriptors because it is statically linked.  Therefore, global references are done simply as relative offsets rather than going through a table of contents or a global offset table.  
</para>

<para>
The first real instruction we hit is <literal>lqr $3, number</literal>.  This stands for "load quadword relative".  The "quadword" part is a bit redundant, as only quadword loads and stores are allowed on the SPU.  This loads the value in the address <literal>number</literal> into register 3.  Notice that unlike the PPE, in SPE assembly language registers are always prefixed with a dollar sign.  This makes it much easier to spot registers in the code.  Since all registers on the SPU are 16-bytes long, this will load a full 16-byte quadword into the register, even though we are only really concerned with the first 4 bytes of it.
</para>

<para>
The value is loaded into register 3, which happens to also be the register which, like in the PPU ABI, is used to pass the first parameter of a function.  In fact, the register layout of the SPU ABI is very similar conceptually to the PPU ABI.  Here is how the registers are used:
</para>

<table>
<title>Register Usage in the SPU ABI</title>
<tr><th>Register Range</th><th>Type</th><th>Purpose</th></tr>
<tr><td>0</td><td>Dedicated</td><td>Link Register</td></tr>
<tr><td>1</td><td>Dedicated</td><td>Stack Pointer</td></tr>
<tr><td>2</td><td>Volatile</td><td>Environment Pointer (for languages that need one)</td></tr>
<tr><td>3-79</td><td>Volatile</td><td>Function arguments, return values, and general usage.</td></tr>
<tr><td>80-127</td><td>Non-volatile</td><td>Used for local variables.  Must be preserved across function calls.</td></tr>
</table>

<para>
A few things to notice.  First, the SPU has a lot more registers.  Second, the SPU doesn't use a special-purpose register for the link register.  Instead, it just uses register 0 and provides a generic indirect branch utility that can use any register  (we'll get to that later).  Volatile and non-volatile registers are used just like in the PPU ABI.  Volatile registers don't need to be saved, but should also be assumed to be overwritten on any function call.  Non-volatile registers have to be saved on the stack before use, and restored before the function returns.  We will discuss the stack shortly.
</para>

<para>
Therefore, since we want the factorial of the number 4, it goes into register 3, the register used for the first parameter.  We then branch to the function use <literal>br factorial</literal>.  This isn't the instruction normally used for function calls, but it keeps us from having to set up a stack frame for <literal>main</literal>.  <literal>br</literal> stands for <emphasis>branch relative</emphasis>, and it is an unconditional branch to an address relative to the address of the current instruction.  
</para>

<para>
For the <literal>factorial</literal> function itself, the program sets up several definitions.  First of all, it defines the size of its stack frame in the symbol <literal>FRAME_SIZE</literal>.  Because SPEs are statically linked and have many more memory constraints than PPEs, the SPE stack frame is both simpler and typically smaller.  The layout of the stack frame looks like this:
</para>

<table>
<tr><th>Contains</th><th>Size</th><th>Beginning Stack Offset</th></tr>
<tr><td>Register Save Area</td><td>Varies (multiple of 16 bytes)</td><td>Varies</td></tr>
<tr><td>Local Variable Space</td><td>Varies (multiple of 16 bytes)</td><td>Varies</td></tr>
<tr><td>Parameter List</td><td>Varies (multiple of 16 bytes)</td><td>32($sp)</td></tr>
<tr><td>Link Register Save Area</td><td>16 bytes</td><td>16($sp)</td></tr>
<tr><td>Back Chain Pointer</td><td>16 bytes</td><td>0($sp)</td></tr>
</table>

<para>
The stack areas work just as they did on the PPE.  The back chain pointer points to the back chain pointer of the previous stack frame.  The link register save area holds the link register contents of the function being called, rather than for the current function.  The parameter list is for parameters that this function sends to other function calls, not for its own parameters.  However, unlike the PPE, no space is reserved for parameters passed through registers.  This is purely an overflow area for functions requiring more than 77 registers to hold their parameters.  The local variable space is used as a general storage area for the function, and the register save area is used to save the values of non-volatile registers that the function uses.
</para>

<para>
So, in our function, we are using the back chain pointer, the link register save area, and one local variable.  That gives us a frame size of 16 * 3 = 48 bytes.  <literal>LR_OFFSET</literal> is the offset from the top of the stack to the link register save area.  <literal>LCL_NUM_VALUE</literal> is the offset from the top of the stack to our local variable <literal>num</literal>.
</para>

<para>
In the prologue, the first thing we do is to save the link register.  Since we have not yet defined our own stack frame, the offset is from the calling function's stack frame.  Remember, the link register is stored in the calling function's stack frame, not the function's own stack frame.  Therefore, it makes most sense to save it before reserving the stack space.  This is done using a D-Form store: <literal>stqd $lr, LR_OFFSET($sp)</literal>.  Now, this looks like we are using special registers, but in fact <literal>$lr</literal> and <literal>$sp</literal> are just aliases for <literal>$0</literal> and <literal>$1</literal>, respectively.  <literal>stqd</literal> stands for "store quadword d-form".  The SPU has the same basic addressing options as the PPU: d-form for register+constant addressing, x-form for register+register addressing, relative addressing, absolute addressing, and immediate mode.  For more information on these addressing modes, see the PPU article on the subject.(FIXME -- ref!)  So, this stores the link register (which is usually set in the function-call instruction) into the appropriate place in the stack.  Next, the current stack frame pointer is stored as the back pointer for the next stack frame, even though we haven't established the stack frame yet (this is done through negative offsets).  The SPU does not have an atomic store/update instruction like the PPU, so in order to make sure that the back pointers are always consistent, storing the back pointer must be done <emphasis>before</emphasis> the stack pointer is moved.  Finally, the stack pointer is moved to reserve all the needed stack space using the instruction <literal>ai $sp, $sp, -FRAME_SIZE</literal>.  <literal>ai</literal> stands for "add immediate", and it adds an immediate-mode value to a register and stores it back into a register.  Just like the PPU, SPU computation instructions have a destination register that can be specified.
</para>

<para>
One more note needs to be made about the "add immediate" instruction.  Remember that the SPU registers are 128 bits wide, but our value is only 32 bits long.  The reason for this is that the SPU is geared towards SIMD (single instruction multiple data) execution.  The register is treated logically as multiple values, which are operated on all-at-once.  The "add immediate" instruction actually treats the register as four separate 32-bit values, each of which are added independently and then they are all stored back into the destination register.  What this means is that, for example, a carry from one part of the add instruction will not affect the rest of the computations.  It treats them all as separate computations.  The preferred value is a 32 bit word, but others are supported, including bytes, halfwords, and doublewords.  If the size of the operand is not specified in the instruction, that means either that the size doesn't matter (as in logical instructions, for instance) or that it is using a 32-bit value size.  Bytes are indicated by including the letter <literal>b</literal> in the instruction, halfwords have an <literal>h</literal>, and doublewords have a <literal>d</literal>, though doublewords are usually only used in floating-point instructions.  Usually, however, a <literal>d</literal> in an instruction refers to the d-form of addressing, not a doubleword.
</para>

<para>
Next, we will copy the first parameter to a local variable with <literal>stqd $3, LCL_NUM_VALUE($sp)</literal>.  We need to do this because our parameter will get clobbered on the recursive call, and we need access to it afterwards.
</para>

<para>
Next, we will do an immediate-mode compare of register 3 with the number 0 and store the result in register 4 with <literal>ceqi $4, $3, 0</literal>.  Note that with the PPU, there is a special-purpose register to hold condition results.  However, with the SPU, the results are stored in a general-purpose register -- register 4 in this case.  Remember, this is a vector processor.  So we are not actually comparing register 3 with the number 0.  Instead, we are comparing each word of register 3 with the number 0.  So we actually have four answers, even though we only care about one of them (because we only have one value loaded in).  The way that the result is stored is that if the condition for the word is true, then all of the bits on the destination word will be set.  If the condition for the word is false, then all of the bits on the destination word will be unset.  So for this instruction there will be four results.
</para>

<para>
The next instruction is <literal>brnz $4, case_zero</literal>.  <literal>brnz</literal> stands for "branch relative if not zero".  Remember, this is checking the result register for zero or not-zero.  The result register will be non-zero (i.e., true, all bits set to one) if the check for zero is true.  The previous two instructions could have been conflated into one instruction (<literal>brz $3, case_zero</literal>) since we were testing for zero, but they were separated out into two instructions so that you can better see how compares and branches work in general.
</para>

<para>
So what happens if some of the comparisons have a result of true and others false?  Since we are dealing with four 32-bit values rather than one 128-bit value, we could have different results for the different values.  So if the results are different do we branch or do we not?  It turns out that several SPU instructions deal with only one of the register's values.  In these cases, the value that is used is the one in the register's <emphasis>preferred slot</emphasis>.  For 32-bit values the preferred slot is the first word of the register; for 16-bit values the preferred slot is the second halfword of the register; and for 8-bit values the preferred slot is the fourth byte of the register.  Basically, the first word is the preferred word, and then the other alignments are on the least-significant byte or halfword of that word.  When doing conditional branching, passing values to functions, returning a value from a function, and several other scenarios, the value in the preferred slot is the one that matters.  In our case, we are to assume that the value passed in the function is in the register's preferred slot.  And, if you look at the alignment of <literal>number</literal> in the <literal>.data</literal> section, you can see that this will be loaded into the preferred slot.
</para>

<para>
Now let's assume that the number we are working with in register 3 is not zero.  This means that we need to do a recursive step.  The recursive C code is <literal>return num * factorial(num - 1)</literal>.  The innermost computation requires us decrementing <literal>num</literal> and passing it as a parameter to the next invocation of <literal>factorial</literal>.  <literal>num</literal> is already in register 3, so we just need to decrement it.  So we will do an immediate-mode add like this: <literal>ai $3, $3, -1</literal>.  Now we just need to invoke the next <literal>factorial</literal>.  To call a function according to the SPU ABI, all you need to do is put the parameters into registers, and then call <literal>brsl $lr, function_name</literal>.  In our case, the first and only parameter is already loaded into register 3.  So, we issue a <literal>brsl $lr, factorial</literal>.  <literal>brsl</literal> stands for "branch relative set link".  This means that the destination address will be a relative address, the return address will be stored in the preferred slot of the specified register, and control will go to the destination address, which in this case is back to the beginning of the <literal>factorial</literal> function.
</para>
<para>
When control comes back to this point, the factorial result should be in register 3.  Now we want to multiply this result by the current value under consideration.  Therefore, we have to load it back in because it was clobbered in the function call.  <literal>lqd</literal> stands for "load quadword d-form".  The first operand is the destination register and the second is the d-form address to load.  So <literal>lqd $5, LCL_NUM_VALUE($sp)</literal> will pull read the value that we saved on the stack earlier into register 5.
</para>
<para>
Now we need to multiply register 3 and register 5.  This is done with the <literal>mpyu</literal> instruction (multiply unsigned).  <literal>mpyu$3, $3, $5</literal> multiplies register 3 with register 5 and stores the result in the first register listed, register 3.  Now, the integer multiply instructions on the SPU are somewhat problematic, especially signed multiplication (using the <literal>mpy</literal> instruction).  The problem is that the result of a multiply instruction can be twice as long as its operands.  The result of multiplying two 32-bit values is actually a 64-bit value!  If it did this, then the destination register would have to be twice as large as the source register.  In order to combat the problem, multiplication instructions only use the least-significant 16 bits of every thirty-two bit value so that the result will fit in the full 32-bit register.  So, while the multiply treats the source registers as 32 bits wide, it only uses 16 bits of them.  So, your value may be truncated if it is longer than 32 bits.  And, if it is a signed multiply, the sign could even change on truncation!  Therefore, to execute multiply instructions successfully, the source values need to be 16 bits wide, but stored in a 32-bit register (it doesn't matter for the multiplication if it is sign-extended to the rest of the 32 bits or not).  This limits greatly the possible range of our factorial function.  Note that floating-point multiplication doesn't have these issues.
</para>
<para>
So now we have the result, and it is in register 3, which is where it needs to be for the return value.  All that is left to do is to restore the previous stack frame and return.  So we simply need to move the stack pointer by adding the stack frame size to the stack pointer using <literal>ai $sp, $sp, FRAME_SIZE</literal>.  We then restore the link register using <literal>lqd $lr, LR_OFFSET($sp)</literal>.  Finally, we branch to the address specified in the link register.
</para>
<para>
The base case (what to do if the function's parameter is zero) is much easier.  The result of factorial(0) is 1, so we simply load in the number one into register 3 using <literal>il $3, 1</literal>.  Then we restore the stack frame and return.  However, since the base case doesn't call any other functions, we don't need to load the link register from the stack frame - the value is still there.
</para>
<para>
And that's how the function works!
</para>
</sect2>
</sect1>

<sect1>
<title>Non-aligned Loads and Stores</title>

<para>
Because the SPU is focused on vector, not scalar processing, it only is able to load and store 16 bytes at a time (the size of a register) from local store locations which are aligned on 16 byte boundaries.  Therefore, you cannot just load a word from memory location 12.  In order to get that word, you would need to load a quadword from memory location 0, and then shift the bits into the preferred slot.  To load a full 128 bits (16 bytes) into a register from a non-aligned location, you would actually have to load it into two registers, shift them, and then mask and combine them.  In order to store non-aligned values, it is even more difficult.  The original quadword must be loaded, the appropriate value inserted into the right location in the quadword, and then the result stored back.  Because of these issues, it is usually advisable to store all data aligned to 16 bytes.  
</para>

<para>
The loading and storing technique, while it will allow us to use data that is not aligned to 16-byte boundaries, will require that the data be <emphasis>naturally aligned</emphasis>.  That means that words will be 4-byte aligned, halfwords will be 2-byte aligned, and bytes don't have to be aligned at all.  It's possible to do completely unaligned data loads and stores, but they require lots of extra instructions, so we're not going to cover it here.  
</para>

<para>
Doing an unaligned load requires two or three instructions, depending on the size of the data.  The reason for this is that if you are loading a single value, you probably want it in the preferred slot of the register.  The first instruction does the load, the second instruction rotates the value so that the requested address is at the beginning of the register, and then, if the data is smaller than a word, a shift is needed to move it away from the beginning into the preferred slot.  Here is the code for a byte load, which takes an address in the preferred slot of register 3 and uses it to load a byte into the preferred slot of register 4:
</para>

<example>
<title>Load from Non-Aligned Memory</title>	
<programlisting>
###Load address $3 into register $4###

#Loads from nearest quadword boundary
lqd $4, 0($3)
#Rotate value to the beginning of the register
rotqby $4, $4, $3
#Rotate value to the preferred slot (-3 for bytes, -2 for halfwords, and nothing for words or doublewords)
rotqbyi $4, $4, -3
</programlisting>
</example>

<para>
Remember, the <literal>lqd</literal> instruction only loads from 16-byte boundaries.  It will therefore ignore the 4 least significant bits during the load, and just load an aligned quadword from memory.  Therefore, for arbitrary addresses, we have no idea where in the loaded quadword the value we wanted is. The <literal>rotqby</literal> instruction, "rotate (left) quadword by bytes", uses the address you loaded from to indicate how far to rotate the register.  It only treats the least 4 significant bits of the address register to rotate. This will always be the number of bytes it needs to shift left to move the address specified to the beginning of the register.  Finally, for bytes, the preferred slot is <emphasis>not</emphasis> at the beginning of the register, but three bytes to the right.  So the instruction <literal>rotqbyi</literal> we will do a shift using an immediate-mode value to shift by.  Word- and doubleword-sized transfers do not need this last instruction, because their preferred slot is at the beginning of the register anyway.  At the end of this, register 4 has the final value, with the byte shifted into the preferred slot.  
</para>

<para>
Storing is more difficult.  Here is the code to store a byte in the preferred slot of register $4 into the address specified by register $3:
</para>

<example>
<title>Store to Non-Aligned Address</title>
###Store $4 into address $3

#Load the data into a temporary register
lqd $5, 0($3)
#Generate the controls for a byte insertion
cbd $6, 0($3)
#Shuffle the data in
shufb $7, $4, $5, $6
#Store it back
stqd $7, 0($3)
</programlisting>
</example>

<para>
To understand this cryptic-looking sequence, we need to again keep in mind that the SPU only does loads and stores a quadword at a time, on quadword aligned addresses.  Therefore, if we want to store only one byte, if we tried to do it directly on an unaligned address, it would both go into the wrong location and clobber the remaining addresses in the quadword.  To avoid this, we need to first load the quadword from memory, insert the value into the appropriate byte in the quadword, and then store it back.  The hard part is inserting it into the proper location based only on the address.  Thankfully, there are two instructions to help out, <literal>cbd</literal> ("generate control for byte insertion") and <literal>shufb</literal> ("shuffle bytes").  The <literal>cbd</literal> instruction takes an address, and generates a control word that can be used by <literal>shufb</literal> to insert a byte at the proper location in the quadword for that address.  <literal>cbd $6, 0($3)</literal> uses the address in register 3 to generate the control quadword, and then stores it in register 6.  The instruction <literal>shufb $7, $4, $5, $6</literal> uses the control quadword in register 6 to generate a new value into register 7 which consists of the original quadword that was in memory (now in register 5) and a byte from register 4 in the preferred slot, and stores the result in register 7.  Once the byte is shuffled in, the value is stored back into memory.
</para>

<para>
To illustrate the technique, we're going to write a function that takes the address of an ASCII character, loads it, converts it to uppercase, and stores it back.  Here is the code (save it as toupper.s):
</para>

<example>
<title>Converting to Uppercase</title>
<programlisting>
.data

string_start:
.ascii "We will convert the following letter, "
letter_to_convert:
.ascii "q"
remaining:
.ascii ", to uppercase\0"

.text
.global main
.type main, @function

main:
	.equ MAIN_FRAME_SIZE, 32
	.equ LR_OFFSET, 16
	#PROLOGUE
	stdq $lr, LR_OFFSET($sp)
	stqd $sp, -MAIN_FRAME_SIZE($sp)
	ai $sp, $sp, -MAIN_FRAME_SIZE

	#MAIN FUNCTION
	il $3, letter_to_convert
	brsl convert_to_upper
	il $3, string_start
	brsl printf

	#EPILOGUE
	ai $sp, $sp, MAIN_FRAME_SIZE
	lqd $lr LR_OFFSET($sp)
	bi $lr


convert_to_upper:
	#Register usage
	# $3 -- parameter 1 -- address of byte to be converted
	# $4 -- byte value to be converted
	# $5 -- $4 greater than 'a' - 1?
	# $6 -- $4 greater than 'z'?
	# $7 -- $4 less than or equal to 'z'?
	# $8 -- $4 between 'a' and 'z' (inclusive)?
	# $9 through $12 -- temporary storage for final store

	#address of letter stored in unaligned address in $3
	#UNALIGNED LOAD
	lqd $4, 0($3)
	rotqby $4, $4, $3
	rotqbyi $4, $4, -3
	#IS IN RANGE 'a'-'z'?
	cgtbi $5, $4, 'a' - 1
	cgtbi $6, $4, 'z'
	nand $7, $6
	and $8, $5, $7
	brz $8 is_lowercase
is_not_lowercase:
	b store_back
is_lowercase:
	ai $4, 'A' - 'a'
store_back:
	#UNALIGNED STORE
	lqd $9, 0($3)
	cbd $10, 0($3)
	shufb, $11, $4, $9, $10
	stqd $11

	#no stack frame, no return value, just return
	bi $lr
</programlisting>
</example>

</sect1>

<sect1>
<title>Communication with the PPU</title>

<sect2>
<title>Invoking SPU Code from the PPU</title>

</sect2>

<sect2>
<title>Copying Data with DMA</title>

</sect2>

<sect2>
<title>Mailbox Delivery</title>

</sect2>

<sect2>
<title>Sharing Data with EARs

</sect1>

<sect1>
<title>Conclusion</title>

</sect1>
</chapter>


<!--
<sect1>
<title>Basic SPE Layout</title>
<para>
The SPE consists of 128 general-purpose registers, each 128 bits long.  
 - what they can be used for
 - dedicated, non-volatile, and volatile registers
 - 


The instruction sequence for a scalar load on the SPE is:lqd     $5, 0($2)rotqby  $2, $5, $2where $2 starts with the EA of the word you want to load into the preferred slot and ends with the scalar in the preferred slot.The code sequence for a non-quadword aligned scalar store is:cwd    $2, 0($5)lqd    $6, 0($5)shufb  $2, $3, $6, $2stqb   $2, 0($5)where :$3 = scalar to store, located in preferred slot of the register$5 = EA of the target scalar in memory$6 = quadword containing the scalar in memoryOf course the compiler generates these sequences and schedules them for you so as a C/C++ programmer you are unaware of all this stuff.Message was edited by: neuron (corrected last line of code: stqb $2, 0($5))

http://www-128.ibm.com/developerworks/power/library/pa-celltips1/

-->





