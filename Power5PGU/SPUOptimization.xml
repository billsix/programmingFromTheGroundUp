<chapter>
<title>Programming the SPU for Performance</title>

<para>
In the last article we covered the basics of SPU programming.  This article will help you learn to write optimal code for it, and have your programs running like greased lightning.  This tutorial covers SIMD vector programming, branch-free programming, loop unrolling, instruction scheduling, and multibuffering techniques.
</para>

<sect1>
<title>Programming a Buffer at a Time</title>

<para>
In the last article, we ended with a function called <literal>convert_to_upper</literal> which operated one byte at a time to convert a string to uppercase.  The functions in these programs will operate on whole buffers at a time.  The SPU is built to deal with data in batches, so moving to a buffer-at-a-time model will make future enhancements easier.  The first version will simply wrap a loop around the code developed in the previous article.
</para>

<para>
Here is the naive version of a buffer-at-a-time function for converting to uppercase (enter as <literal>convert_buffer.s</literal>):
</para>

<example>
<title>First Example Program</title>
<programlisting>
.text

.global convert_buffer_to_upper
.type convert_buffer_to_upper, @function
convert_buffer_to_upper:
	##REGISTER USAGE:
	#   3) buffer address / current address
	#   4) buffer size 
	#   5) end_address
	#   6) current quadword
	#   7) current quadword with byte in first position
	#   8, 9, & 10) Determine if byte is in range
	#   11) byte insertion control
	#   12) current quadword with byte properly inserted
	#   13) true if we need to branch, false otherwise
	#   14) conversion factor

	#Calculate end address
	a $5, $4, $3
	
loop_start:
	#UNALIGNED LOAD
	lqd $6, 0($3)
	rotqby $7, $6, $3
	rotqbyi $7, $7, -3

	#IS IN RANGE 'a'-'z'
	cgtbi $8, $7, 'a' - 1
	cgtbi $9, $7, 'z'
	xor $10, $8, $9
	andi $10, $10, 255

	brz $10, finish_loop

is_lowercase:
	il $14, 'a' - 'A'
	absdb $7, $7, $14

finish_loop:
	#Unaligned Store ($6 already has current word)
	cbd $11, 0($3)
	shufb $12, $7, $6, $11
	stqd $12, 0($3)

	#Increment pointer
	ai $3, $3, 1

	#Exit if needed
	cgt $13, $3, $5
	brnz $13, end_function

	#end loop
	br loop_start

end_function:
	bi $lr
</programlisting>
</example>

<para>
The function which drives this is now a little bit simpler (enter as <literal>convert_driver.s</literal>):
</para>

<example>
<title>Uppercase Conversion Main Function</title>
<programlisting>
.data

.align 4
conversion_info:
conversion_length:
	.octa 0
conversion_data:
	.octa 0
.equ CONVERSION_STRUCT_SIZE, 32

.section .bss #Uninitialized Data Section
.align 4
.lcomm conversion_buffer, 16384

.text

#MFC Constants
.equ MFC_GET_CMD, 0x40
.equ MFC_PUT_CMD, 0x20

.equ LR_OFFSET, 16

.global main
.type main, @function
.equ MAIN_FRAME_SIZE, 32
main:
	#Prologue
	stqd $lr, LR_OFFSET($sp)
	stqd $sp, -MAIN_FRAME_SIZE($sp)
	ai $sp, $sp, -MAIN_FRAME_SIZE

	##COPY IN CONVERSION INFORMATION##
	ila $3, conversion_info         #Local Store Address
	#register 4 already has address #64-bit Effective Address
	il $5, CONVERSION_STRUCT_SIZE   #Transfer size
	il $6, 0                        #DMA Tag
	il $7, MFC_GET_CMD              #DMA Command
	brsl $lr, perform_dma

	#Wait for DMA to complete
	il $3, 0
	brsl $lr, wait_for_dma_completion

	##COPY STRING IN TO BUFFER##
	#Load buffer data pointer 
	ila $3, conversion_buffer #Local Store
	lqr $4, conversion_data   #64-bit Effective Address
	lqr $5, conversion_length #SIZE
	il $6, 0                  #DMA Tag
	il $7, MFC_GET_CMD        #DMA Command
	brsl $lr, perform_dma

	#Wait for DMA to complete
	il $3, 0
	brsl $lr, wait_for_dma_completion

	#Perform Conversion
	ila $3, conversion_buffer
	lqr $4, conversion_length
	brsl $lr, convert_buffer_to_upper

	#Copy data back
	ila $3, conversion_buffer   #Local Store Address
	lqr $4, conversion_data     #64-bit effective address
	lqr $5, conversion_length   #Size
	il $6, 0                    #DMA Tag
	il $7, MFC_PUT_CMD          #DMA Command
	brsl $lr, perform_dma

	#Wait for DMA to complete
	il $3, 0
	brsl $lr, wait_for_dma_completion

	#Return Value
	il $3, 0

	#Epilogue
	ai $sp, $sp, MAIN_FRAME_SIZE
	lqd $lr, LR_OFFSET($sp)
	bi $lr
</programlisting>
</example>

<para>
You will also need the <literal>dma_utils.s</literal> and the <literal>ppu_dma_main.c</literal> files from the previous article.
</para>

<para>
To build and run, perform these steps:
</para>

<programlisting>
spu-gcc convert_buffer.s convert_driver.s dma_utils.s -o spe_convert
embedspu -m64 convert_to_upper_handle spe_convert spe_convert_csf.o
gcc -m64 spe_convert_csf.o ppu_dma_main.c -lspe -o dma_convert
./dma_convert
</programlisting>



<example>
<title>Buffer Conversion -- Vectorized and Branches Removed</title>
<programlisting>
.data 
.equ CONVERSION, 'a' - 'A'
.align 4
conversion_bytes:
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
		
.text

.global convert_buffer_to_upper
.type convert_buffer_to_upper, @function
convert_buffer_to_upper:
	##REGISTER USAGE:
	#   3) buffer address / current address
	#   4) buffer size 
	#   5) end_address
	#   6) current quadword
	#   8, 9, & 10) Determine if bytes are in range
	#   11) Conversion bytes
	#   12) Conversion bytes (masked)
	#   13) true if we need to branch, false otherwise

	#Calculate end address
	a $5, $4, $3

	#Load conversion bytes
	lqr $11, conversion_bytes
	
loop_start:
	#ALIGNED LOAD
	lqd $6, 0($3)

	#IS IN RANGE 'a'-'z'
	cgtbi $8, $6, 'a' - 1
	cgtbi $9, $6, 'z'
	xor $10, $8, $9

	#Create conversion quadword
	and $12, $10, $11

	#Convert data
	absdb $6, $6, $12 

	#Aligned Store 
	stqd $6, 0($3)

	#Increment pointer
	ai $3, $3, 16

	#Exit if needed
	cgt $13, $3, $5
	brnz $13, end_function

	#end loop
	br loop_start

end_function:
	bi $lr
</programlisting>
</example>

<example>
<title>Buffer Conversion -- Loop Unrolled</title>
<programlisting>
.data 
.equ CONVERSION, 'a' - 'A'
.align 4
conversion_bytes:
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
		
.text

.global convert_buffer_to_upper
.type convert_buffer_to_upper, @function
convert_buffer_to_upper:
	##REGISTER USAGE:
	###Global Regs
	.equ BUFFER_REG, 3             #Buffer address / current address
	.equ BUFFER_SZ_REG, 4          #Buffer size
	.equ BUFFER_END_REG, 5         #End address
	.equ CONVERSION_BYTES_REG, 6   #Conversion data
	.equ NEED_FINISH_REG, 7        #Finished conversion?

	###Per-Iteration Regs
	.equ CURRENT_VAL_REG, 8  #Current quadword
	.equ BOOL_TMP1_REG, 9
	.equ BOOL_TMP2_REG, 10
	.equ IN_RANGE_REG, 11    #Value in range?
	.equ CONV_REG, 12        #Conversion bytes, properly masked
	.equ NUMREGS, 5          #Number of per-iteration registers

	.equ REGBYTES, 16        #Number of bytes in a register

	#Calculate end address
	a $BUFFER_END_REG, $BUFFER_SZ_REG, $BUFFER_REG
	#Load conversion bytes
	lqr $CONVERSION_BYTES_REG, conversion_bytes
	
loop_start:
	####ITERATION 0####
	lqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
	cgtbi $(BOOL_TMP1_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'a' - 1
	cgtbi $(BOOL_TMP2_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'z'
	xor $(IN_RANGE_REG+0*NUMREGS), $(BOOL_TMP1_REG+0*NUMREGS), $(BOOL_TMP2_REG+0*NUMREGS)
	and $(CONV_REG+0*NUMREGS), $(IN_RANGE_REG+0*NUMREGS), $CONVERSION_BYTES_REG
	absdb $(CURRENT_VAL_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), $(CONV_REG+0*NUMREGS)
	stqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)

	####ITERATION 1####
	lqd $(CURRENT_VAL_REG+1*NUMREGS), 1*REGBYTES($BUFFER_REG)
	cgtbi $(BOOL_TMP1_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), 'a' - 1
	cgtbi $(BOOL_TMP2_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), 'z'
	xor $(IN_RANGE_REG+1*NUMREGS), $(BOOL_TMP1_REG+1*NUMREGS), $(BOOL_TMP2_REG+1*NUMREGS)
	and $(CONV_REG+1*NUMREGS), $(IN_RANGE_REG+1*NUMREGS), $CONVERSION_BYTES_REG
	absdb $(CURRENT_VAL_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), $(CONV_REG+1*NUMREGS)
	stqd $(CURRENT_VAL_REG+1*NUMREGS), 1*REGBYTES($BUFFER_REG)

	####ITERATION 2####
	lqd $(CURRENT_VAL_REG+2*NUMREGS), 2*REGBYTES($BUFFER_REG)
	cgtbi $(BOOL_TMP1_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), 'a' - 1
	cgtbi $(BOOL_TMP2_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), 'z'
	xor $(IN_RANGE_REG+2*NUMREGS), $(BOOL_TMP1_REG+2*NUMREGS), $(BOOL_TMP2_REG+2*NUMREGS)
	and $(CONV_REG+2*NUMREGS), $(IN_RANGE_REG+2*NUMREGS), $CONVERSION_BYTES_REG
	absdb $(CURRENT_VAL_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), $(CONV_REG+2*NUMREGS)
	stqd $(CURRENT_VAL_REG+2*NUMREGS), 2*REGBYTES($BUFFER_REG)

	####ITERATION 3####
	lqd $(CURRENT_VAL_REG+3*NUMREGS), 3*REGBYTES($BUFFER_REG)
	cgtbi $(BOOL_TMP1_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), 'a' - 1
	cgtbi $(BOOL_TMP2_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), 'z'
	xor $(IN_RANGE_REG+3*NUMREGS), $(BOOL_TMP1_REG+3*NUMREGS), $(BOOL_TMP2_REG+3*NUMREGS)
	and $(CONV_REG+3*NUMREGS), $(IN_RANGE_REG+3*NUMREGS), $CONVERSION_BYTES_REG
	absdb $(CURRENT_VAL_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), $(CONV_REG+3*NUMREGS)
	stqd $(CURRENT_VAL_REG+3*NUMREGS), 3*REGBYTES($BUFFER_REG)

	#Increment pointer
	ai $BUFFER_REG, $BUFFER_REG, 4*REGBYTES

	#Exit if needed
	cgt $13, $3, $5
	brnz $13, end_function

	#end loop
	br loop_start

end_function:
	bi $lr
</programlisting>
</example>

<!-- page 687-688 BE Handbook -->
<!-- 18 clock cycles per QWORD, 0 dual-issues, ~1.125 cycles per conversion -->
<example>
<title>Loop Body -- Annotated Scheduling Info</title>
<programlisting>
	####ITERATION 0####
	nop
	lqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
	#stall (waiting on CURRENT_VAL_REG to load)
	#stall
	#stall
	#stall
	#stall
	cgtbi $(BOOL_TMP1_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP2_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'z'
	lnop
	#stall (waiting on BOOL_TMP2_REG)
	xor $(IN_RANGE_REG+0*NUMREGS), $(BOOL_TMP1_REG+0*NUMREGS), $(BOOL_TMP2_REG+0*NUMREGS)
	lnop
	#stall (waiting on IN_RANGE_REG)
	and $(CONV_REG+0*NUMREGS), $(IN_RANGE_REG+0*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	#stall (waiting on CONV_REG)
	absdb $(CURRENT_VAL_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), $(CONV_REG+0*NUMREGS)
	lnop
	#stall (waiting on CURRENT_VAL_REG)
	#stall
	#stall
	nop
	stqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
</programlisting>
</example>


<!-- 30 cycles (7.5 cycles / QWORD), 64 bytes processed, 1 dual-issue (~0.47 clock cycles per conversion) -->
<!-- needs .align 2 -->
<example>
<title>Main Loop Interleaved for Scheduling</title>
<programlisting>
	.align 2
	nop
	lqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
	nop
	lqd $(CURRENT_VAL_REG+1*NUMREGS), 1*REGBYTES($BUFFER_REG)
	nop
	lqd $(CURRENT_VAL_REG+2*NUMREGS), 2*REGBYTES($BUFFER_REG)
	nop
	lqd $(CURRENT_VAL_REG+3*NUMREGS), 3*REGBYTES($BUFFER_REG)
	#stall (waiting on CURRENT_VAL_REG to load)
	#stall
	cgtbi $(BOOL_TMP1_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP1_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP1_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP1_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP2_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'z'
	lnop
	cgtbi $(BOOL_TMP2_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), 'z'
	lnop
	cgtbi $(BOOL_TMP2_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), 'z'
	lnop
	cgtbi $(BOOL_TMP2_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), 'z'
	lnop
	xor $(IN_RANGE_REG+0*NUMREGS), $(BOOL_TMP1_REG+0*NUMREGS), $(BOOL_TMP2_REG+0*NUMREGS)
	lnop
	xor $(IN_RANGE_REG+1*NUMREGS), $(BOOL_TMP1_REG+1*NUMREGS), $(BOOL_TMP2_REG+1*NUMREGS)
	lnop
	xor $(IN_RANGE_REG+2*NUMREGS), $(BOOL_TMP1_REG+2*NUMREGS), $(BOOL_TMP2_REG+2*NUMREGS)
	lnop
	xor $(IN_RANGE_REG+3*NUMREGS), $(BOOL_TMP1_REG+3*NUMREGS), $(BOOL_TMP2_REG+3*NUMREGS)
	lnop
	and $(CONV_REG+0*NUMREGS), $(IN_RANGE_REG+0*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	and $(CONV_REG+1*NUMREGS), $(IN_RANGE_REG+1*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	and $(CONV_REG+2*NUMREGS), $(IN_RANGE_REG+2*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	and $(CONV_REG+3*NUMREGS), $(IN_RANGE_REG+3*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	absdb $(CURRENT_VAL_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), $(CONV_REG+0*NUMREGS) 
	lnop
	absdb $(CURRENT_VAL_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), $(CONV_REG+1*NUMREGS) 
	lnop
	absdb $(CURRENT_VAL_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), $(CONV_REG+2*NUMREGS)
	lnop 
	absdb $(CURRENT_VAL_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), $(CONV_REG+3*NUMREGS)
	lnop
	nop
	stqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
	nop
	stqd $(CURRENT_VAL_REG+1*NUMREGS), 1*REGBYTES($BUFFER_REG)
	nop
	stqd $(CURRENT_VAL_REG+2*NUMREGS), 2*REGBYTES($BUFFER_REG)
	nop
	stqd $(CURRENT_VAL_REG+3*NUMREGS), 3*REGBYTES($BUFFER_REG)
</programlisting>
</example>

<!-- branch hints -->
<!-- optimize function call and return -->

<example>
<title>Multibuffering the Main Function</title>
<programlisting>
.data

.align 4
conversion_info:
conversion_length:
	.octa 0
conversion_data:
	.octa 0
.equ CONVERSION_STRUCT_SIZE, 32

.section .bss #Uninitialized Data Section
.align 4
.lcomm conversion_buffer_1, 16384
.lcomm conversion_buffer_2, 16384

.equ CONVERSION_TRANSFER_SIZE, 128
.text

#MFC Constants
.equ MFC_GETB_CMD, 0x41
.equ MFC_PUTB_CMD, 0x21

.equ LR_OFFSET, 16

.global main
.type main, @function
.equ MAIN_FRAME_SIZE, 64
.equ REGSAVE_OFFSET, 32

#Name our registers
	.equ PARAM_1, 3
	.equ PARAM_2, 4
	.equ PARAM_3, 5
	.equ PARAM_4, 6
	.equ PARAM_5, 7

	.equ TMP_1, 8
	.equ TMP_SZ_NEXT_XFER, 9
	.equ TMP_SZ_NEXT_XFER_64, 10

	.equ DATA_REMAINING, 127
	.equ CURRENT_PTR, 126
	.equ BUF1_EA, 125
	.equ BUF1_SIZE, 124	
	.equ BUF2_EA, 123
	.equ BUF2_SIZE, 122
	.equ TRANSFER_SIZE, 121
main:
	#Prologue
	stqd $lr, LR_OFFSET($sp)
	stqd $sp, -MAIN_FRAME_SIZE($sp)
	ai $sp, $sp, -MAIN_FRAME_SIZE

	il $TRANSFER_SIZE, CONVERSION_TRANSFER_SIZE

	##COPY IN CONVERSION INFORMATION##
	ila $PARAM_1, conversion_info         #Local Store Address
	#register 4 already has address #64-bit Effective Address
	il $PARAM_3, CONVERSION_STRUCT_SIZE   #Transfer size
	il $PARAM_4, 0                        #DMA Tag
	il $PARAM_5, MFC_GETB_CMD              #DMA Command
	brsl $lr, perform_dma

conversion_loop:
	
	#Wait for DMA to complete
	il $PARAM_1, 0
	brsl $lr, wait_for_dma_completion

	lqr $DATA_REMAINING, conversion_length
	lqr $CURRENT_PTR, conversion_data

	#Is there a full transfer left?
	cgt $TMP_1, $TRANSFER_SIZE, $DATA_REMAINING
	selb $TMP_SZ_NEXT_XFER, $TRANSFER_SIZE, $DATA_REMAINING, $TMP_1
	
	#Save Buffer 1 Info
	lr $BUF1_EA, $CURRENT_PTR
	lr $BUF1_SIZE, $TMP_SZ_NEXT_XFER

	#Move Pointer and size
	sf $DATA_REMAINING, $DATA_REMAINING, $TMP_SZ_NEXT_XFER
	#MISMATCH!!! 64-bit and 32-bit
	a $CURRENT_PTR, $CURRENT_PTR, $TMP_SZ_NEXT_XFER

	#Start Copy Buffer 1
	ila $PARAM_1, conversion_buffer_1 #Local Store
	lr $PARAM_2, $BUF1_EA             #64-bit Effective Address
	lr $PARAM_3, $BUF1_SIZE           #SIZE
	il $PARAM_4, 0                    #DMA Tag
	il $PARAM_5, MFC_GETB_CMD          #DMA Command
	brsl $lr, perform_dma

	#Is there a full transfer left?
	cgt $TMP_1, $TRANSFER_SIZE, $DATA_REMAINING
	selb $TMP_SZ_NEXT_XFER, $TRANSFER_SIZE, $DATA_REMAINING, $TMP_1

	#Save Buffer 2 Info
	lr $BUF2_EA, $CURRENT_PTR
	lr $BUF2_SIZE, $TMP_SZ_NEXT_XFER

	#Move pointer and size
	sf $DATA_REMAINING, $DATA_REMAINING, $TMP_SZ_NEXT_XFER
	#MISMATCH!!! 64-bit and 32-bit
	a $CURRENT_PTR, $CURRENT_PTR, $TMP_SZ_NEXT_XFER

	#Start Copy Buffer 2
	ila $PARAM_1, conversion_buffer_2 #Local Store
	lr $PARAM_2, $BUF2_EA             #64-bit Effective Address
	lr $PARAM_3, $BUF2_SIZE           #SIZE
	il $PARAM_4, 1                    #DMA Tag
	il $PARAM_5, MFC_GETB_CMD          #DMA Command
	brsl $lr, perform_dma
	
	#Wait for First DMA to complete
	il $PARAM_1, 0
	brsl $lr, wait_for_dma_completion

	#Perform Conversion on buffer 1
	ila $PARAM_1, conversion_buffer_1
	lr $PARAM_2, $BUF1_SIZE
	brsl $lr, convert_buffer_to_upper

	#Start Copy Data Back on Buffer 1
	ila $PARAM_1, conversion_buffer_1   #Local Store Address
	lr $PARAM_2, $BUF1_EA     #64-bit effective address
	lr $PARAM_3, $BUF1_SIZE   #Size
	il $PARAM_4, 0                    #DMA Tag
	il $PARAM_5, MFC_PUTB_CMD          #DMA Command
	brsl $lr, perform_dma

	#Queue Up Next Copy on Buffer 1
	#Is there a full transfer left?
	cgt $TMP_1, $TRANSFER_SIZE, $DATA_REMAINING
	selb $TMP_SZ_NEXT_XFER, $TRANSFER_SIZE, $DATA_REMAINING, $TMP_1
	
	#Save Buffer 1 Info
	lr $BUF1_EA, $CURRENT_PTR
	lr $BUF1_SIZE, $TMP_SZ_NEXT_XFER

	#Move Pointer and size
	sf $DATA_REMAINING, $DATA_REMAINING, $TMP_SZ_NEXT_XFER
	#MISMATCH!!!
	a $CURRENT_PTR, $CURRENT_PTR, $TMP_SZ_NEXT_XFER

	#Start Copy Buffer 1
	ila $PARAM_1, conversion_buffer_1 #Local Store
	lr $PARAM_2, $BUF1_EA             #64-bit Effective Address
	lr $PARAM_3, $BUF1_SIZE           #SIZE
	il $PARAM_4, 0                    #DMA Tag
	il $PARAM_5, MFC_GETB_CMD          #DMA Command
	brsl $lr, perform_dma


	#Wait for Data on Buffer 2
	il $PARAM_1, 1
	brsl $lr, wait_for_dma_completion

	#Perform Conversion on Buffer 2
	ila $PARAM_1, conversion_buffer_2
	lr $PARAM_2, $BUF2_SIZE
	brsl $lr, convert_buffer_to_upper

	#Start Copy Data Back on Buffer 2
	ila $PARAM_1, conversion_buffer_2
	lr $PARAM_2, BUF2_EA
	lr $PARAM_3, BUF2_SIZE
	il $PARAM_4, 1
	il $PARAM_5, MFC_PUTB_CMD
	brsl $lr, perform_dma

	#Queue Up Next Copy on Buffer 2
	#Is there a full transfer left?
	cgt $TMP_1, $TRANSFER_SIZE, $DATA_REMAINING
	selb $TMP_SZ_NEXT_XFER, $TRANSFER_SIZE, $DATA_REMAINING, $TMP_1
	
	#Save Buffer 2 Info
	lr $BUF2_EA, $CURRENT_PTR
	lr $BUF2_SIZE, $TMP_SZ_NEXT_XFER

	#Move Pointer and size
	sf $DATA_REMAINING, $DATA_REMAINING, $TMP_SZ_NEXT_XFER
	##MISMATCH!!!
	a $CURRENT_PTR, $CURRENT_PTR, $TMP_SZ_NEXT_XFER

	#Start Copy Buffer 2
	ila $PARAM_1, conversion_buffer_2 #Local Store
	lr $PARAM_2, $BUF2_EA             #64-bit Effective Address
	lr $PARAM_3, $BUF2_SIZE           #SIZE
	il $PARAM_4, 0                    #DMA Tag
	il $PARAM_5, MFC_GETB_CMD          #DMA Command
	brsl $lr, perform_dma
	
	#Branch if there is data remaining
	# (FIXME -- should skip some steps if $DATA_REMAINING is 0)
	# (FIXME -- should do branch hints to help out the loop)
	brnz  $DATA_REMAINING, conversion_loop

main_end:

	#Return Value
	il $3, 0

	#Epilogue
	ai $sp, $sp, MAIN_FRAME_SIZE
	lqd $lr, LR_OFFSET($sp)
	bi $lr
</programlisting>
</example>