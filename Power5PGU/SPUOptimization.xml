<chapter>
<title>Programming the SPU for Performance</title>

<para>
In the last article we covered the basics of SPU programming.  This article will help you learn to write optimal code for it, and have your programs running like greased lightning.  This tutorial covers SIMD vector programming, branch-free programming, loop unrolling, instruction scheduling, and multibuffering techniques.
</para>

<para>
This article dives into the depths of instruction-cycle-counting, bit manipulation, and other nuances that assembly language has typically been notorious for.  By the end of it you may be convinced never to program in assembly language.  However, the point of it all is not to be an assembly language programmer (though you might be into that sort of thing!) but rather to understand what the processor and the compiler are needing to do to optimize your code for the SPU.  Knowing how the SPU's assembly language works will enable you to exploits this knowledge to write C code which takes advantage of the features of the processor.  In subsequent articles we will switch to C and show how to use this knowledge in real-world examples.
</para>

<sect1>
<title>Our Starting Program</title>

<para>
In the last article, we ended with a function called <literal>convert_to_upper</literal> which operated one byte at a time to convert a string to uppercase.  The functions in these programs will operate on whole buffers at a time.  The SPU is built to deal with data in batches, so moving to a buffer-at-a-time model will make future enhancements easier.  The first version will simply wrap a loop around the code developed in the previous article. Because it is based on code and concepts developed in the previous articles, we will not do a step-by-step explanation of the code.
</para>

<para>
Here is the naive version of a buffer-at-a-time function for converting to uppercase (enter as <literal>convert_buffer.s</literal>):
</para>

<example>
<title>First Example Program</title>
<programlisting>
.text

.global convert_buffer_to_upper
.type convert_buffer_to_upper, @function
convert_buffer_to_upper:
	##REGISTER USAGE:
	#   3) buffer address / current address
	#   4) buffer size 
	#   5) end_address
	#   6) current quadword
	#   7) current quadword with byte in first position
	#   8, 9, & 10) Determine if byte is in range
	#   11) byte insertion control
	#   12) current quadword with byte properly inserted
	#   13) true if we need to branch, false otherwise
	#   14) conversion factor

	#Calculate end address
	a $5, $4, $3
	
loop_start:
	#UNALIGNED LOAD
	lqd $6, 0($3)
	rotqby $7, $6, $3
	rotqbyi $7, $7, -3

	#IS IN RANGE 'a'-'z'?
	cgtbi $8, $7, 'a' - 1
	cgtbi $9, $7, 'z'
	xor $10, $8, $9
	andi $10, $10, 255

	#If no, exit
	brz $10, finish_loop

is_lowercase:
	#If yes, perform conversion
	il $14, 'a' - 'A'
	absdb $7, $7, $14

finish_loop:
	#Unaligned Store ($6 already has current word)
	cbd $11, 0($3)
	shufb $12, $7, $6, $11
	stqd $12, 0($3)

	#Increment pointer
	ai $3, $3, 1

	#Are we at the end?  If so skip the loop iteration 
	cgt $13, $3, $5
	brnz $13, end_function

	#perform next loop iteration
	br loop_start

end_function:
	#Return
	bi $lr
</programlisting>
</example>

<para>
The function which drives this is now a little bit simpler since it only has to load the data, run the function, and copy it back.  Here is the code (enter as <literal>convert_driver.s</literal>):
</para>

<example>
<title>Uppercase Conversion Main Function</title>
<programlisting>
.data

#This is the struct we will copy from the main PPE process
.align 4
conversion_info:
conversion_length:
	.octa 0
conversion_data:
	.octa 0
.equ CONVERSION_STRUCT_SIZE, 32

.section .bss #Uninitialized Data Section

#This is the buffer we will store the string in
.align 4
.lcomm conversion_buffer, 16384

.text

#MFC Constants
.equ MFC_GET_CMD, 0x40
.equ MFC_PUT_CMD, 0x20

.equ LR_OFFSET, 16

.global main
.type main, @function
.equ MAIN_FRAME_SIZE, 32
main:
	#Prologue
	stqd $lr, LR_OFFSET($sp)
	stqd $sp, -MAIN_FRAME_SIZE($sp)
	ai $sp, $sp, -MAIN_FRAME_SIZE

	##COPY IN CONVERSION INFORMATION##
	ila $3, conversion_info         #Local Store Address
	#register 4 already has address #64-bit Effective Address
	il $5, CONVERSION_STRUCT_SIZE   #Transfer size
	il $6, 0                        #DMA Tag
	il $7, MFC_GET_CMD              #DMA Command
	brsl $lr, perform_dma

	#Wait for DMA to complete
	il $3, 0
	brsl $lr, wait_for_dma_completion

	##COPY STRING IN TO BUFFER##
	#Load buffer data pointer 
	ila $3, conversion_buffer #Local Store
	lqr $4, conversion_data   #64-bit Effective Address
	lqr $5, conversion_length #SIZE
	il $6, 0                  #DMA Tag
	il $7, MFC_GET_CMD        #DMA Command
	brsl $lr, perform_dma

	#Wait for DMA to complete
	il $3, 0
	brsl $lr, wait_for_dma_completion

	##PERFORM CONVERSION##
	ila $3, conversion_buffer
	lqr $4, conversion_length
	brsl $lr, convert_buffer_to_upper

	##COPY DATA BACK##
	ila $3, conversion_buffer   #Local Store Address
	lqr $4, conversion_data     #64-bit effective address
	lqr $5, conversion_length   #Size
	il $6, 0                    #DMA Tag
	il $7, MFC_PUT_CMD          #DMA Command
	brsl $lr, perform_dma

	#Wait for DMA to complete
	il $3, 0
	brsl $lr, wait_for_dma_completion

	##EXIT PROGRAM##
	#Return Value
	il $3, 0

	#Epilogue
	ai $sp, $sp, MAIN_FRAME_SIZE
	lqd $lr, LR_OFFSET($sp)
	bi $lr
</programlisting>
</example>

<para>
You will also need the <literal>dma_utils.s</literal> and the <literal>ppu_dma_main.c</literal> files from the previous article.
</para>

<para>
To build and run, perform these steps:
</para>

<programlisting>
spu-gcc convert_buffer.s convert_driver.s dma_utils.s -o spe_convert
embedspu -m64 convert_to_upper_handle spe_convert spe_convert_csf.o
gcc -m64 spe_convert_csf.o ppu_dma_main.c -lspe -o dma_convert
./dma_convert
</programlisting>

<para>
Now, as far as performance goes, the current code is terrible.  So we will work on it a step at a time to improve the performance. 
</para>

</sect1>

<sect1>
<title>Vectorizing the Code</title>

<para>
The most obvious optimization to make on a vector process is to vectorize the code.  On the SPUs, most instructions can operate on registers as if they contained multiple, independent values.  Each 128-bit register can be treated as 16 independent bytes, 8 half-words, 4 words, 2 doublewords, or as a single unit.  The instruction set is primarily geared around dividing it into four 32-bit words, but there is enough support to handle any of these situations.
</para>

<para>
If we vectorize this code, since we are treating the values as bytes, that means that each instruction will operate on 16 values at once!  However, the problem is that vector processing assumes that each and every instruction will be applied to all elements of the vector.  However, in our main loop, we have a conditional branch.  This means that vector elements which match the criteria go through a different set of instructions than those that do not.  Therefore, at least the way the code presently stands, it cannot be vectorized.
</para>

<para>
What we need to do first is <emphasis>eliminate the branch</emphasis> so that the code uses the exact same instructions whether it matches our condition or not (as will be shown later, eliminating branches helps in other ways as well).  So how is this done?  The key is that the SPU has several conditional instructions, such as <literal>selb</literal>, <literal>shufb</literal> and the bit operations, which allow conditional statements to occur without branching.  What the program will end up doing is <emphasis>calculating both answers</emphasis>, and then using the conditional instructions to to select which answer we want.
</para>

<para>
Here is the conversion code as it currently stands:
</para>

<programlisting>
	#IS IN RANGE 'a'-'z'
	cgtbi $8, $7, 'a' - 1
	cgtbi $9, $7, 'z'
	xor $10, $8, $9
	andi $10, $10, 255

	brz $10, finish_loop

is_lowercase:
	#lowercase condition
	il $14, 'a' - 'A'
	absdb $7, $7, $14

finish_loop:
	#non-lowercase condition
	#all code winds up here
</programlisting>

<para>
In our case, the two answers we are computing are:
</para>

<itemizedlist>
<listitem><para>Uppercase-converted letter (if lowercase)</para></listitem>
<listitem><para>Original input letter (if not lowercase)</para></listitem>
</itemizedlist>

<para>
Our code starts with the original value in <literal>$7</literal>.  The first thing we need to do is to move the code which calculates the converted value <emphasis>before the condition</emphasis>, and then store it in a different register (<literal>$15</literal> in this case).  So the code will look like this:
</para>

<programlisting>
	#$7 has our original value
	il $14, 'a' - 'A'
	absdb $15, $7, $14
	#$7 has the original, and $15 has the converted value
	#Choose between the value in $7 and $14 and put it in $7

	##...rest of loop...
</programlisting>

<para>
So now we need to figure out which value we want to use.  The first thing we need to do is to use our original instructions to check the condition:
</para>

<programlisting>
	cgtbi $8, $7, 'a' - 1
	cgtbi $9, $7, 'z'
	xor $10, $8, $9
</programlisting>

<para>
The previous <literal>andi</literal> is no longer needed because it was used to mask out unwanted values within the branch.  Since we aren't branching we don't care!  So now, <literal>$10</literal> has all ones in the preferred slot if it is in range, and all zeroes if it is out of range.    Now all we need is to choose <literal>$7</literal> or <literal>$15</literal> based on the value in <literal>$10</literal>.  The instruction <literal>selb</literal> (select bits) is perfect for this.  <literal>selb</literal> has four operands:
</para>

<itemizedlist>
<listitem><para>destination register</para></listitem>
<listitem><para>source value 1</para></listitem>
<listitem><para>source value 2</para></listitem>
<listitem><para>selector</para></listitem>
</itemizedlist>

<para>
<literal>selb</literal> operates by taking going through the selector bit-by-bit.  For each bit position, if the bit is 0, the same bit position in the destination register uses the bit from source value 1.  If the bit is 1, it uses the bit from source value 2.  If you imagine each register as an array of bits, <literal>selb</literal> has the following meaning:
</para>

<programlisting>
//imaginary representation of selb for those more familiar with C than assembly language:
for(i = 0; i < 128; i++) {
	destination[i] = selector[i] == 0 ? source_1[i] : source_2[i]
}
</programlisting>

<para>
Now hopefully you are seeing why the condition statements set all of the corresponding bits in the destination register to 1 if the condition is true - it makes it easier to use that value for <literal>selb</literal>.  In our case, we can simply add the following line of code:
</para>

<programlisting>
	selb $7, $7, $15, $10
</programlisting>

<para>
Now, all of our values, whether they are lowercase or not, will be processed through the following code sequence:
</para>

<example>
<title>Branch-free conversion code</title>
<programlisting>
	#Original value starts in $7

	#Perform conversion and store in $15
	il $14, 'a' - 'A'
	absdb $15, $7, $14
	
	#Is it lowercase ('a'-'z')?
	cgtbi $8, $7, 'a'-1
	cgtbi $9, $7, 'z'
	xor $10, $8, $9
	#$10 has all 1s for lowercase and all 0s for non-lowercase

	#Select value into $7 based on condition
	selb $7, $7, $15, $10

	#$7 now has the correct value
</programlisting>
</example>

<para>
In our case, the choice was between the original value and a processed value, but the code would have been similar if the choice was between two processed values.  In that case, we would have just had two sets of processing instructions, with each set using a different register for its result, and the <literal>selb</literal> instruction choosing between them.  Likewise, if there were more than two possible directions for the code to go, multiple <literal>selb</literal>s could be used to choose between them.  However, at that point, you probably need to look and see if the cost of calculating all of the different possibilities for every input is worth the benefit of eliminating branches.
</para>

<para>
Remember that the point of removing the branch was so that we can vectorize the code.  The problem was that in order to vectorize the code, the code must follow the same set of instructions for each member of the vector.  Now that we have eliminated the branches this is possible.
</para>

<para>
In fact, the core conversion code <emphasis>is actually almost already vectorized</emphasis>.  All of the instructions operate on the whole register anyway.  The problem before was threefold:
</para>

<itemizedlist>
<listitem><para>The branch was causing either the whole register to be converted or not converted.</para></listitem>
<listitem><para>The register holding the conversion factor was geared to a single byte usage rather than a whole register (<literal>il</literal> loads the given value into each <emphasis>word</emphasis> but we need it in each <emphasis>byte</emphasis>).</para></listitem>
<listitem><para>The load/store instructions and the loop counter were geared for processing a single byte at a time.</para></listitem>
</itemizedlist>

<para>
We've eliminated the branch.  Now we need to load our conversion factor appropriately.  The easiest way to do this is to put the conversion factor in the <literal>.data</literal> section manually and load it directly in.  We should also move it outside of the loop since its value is invariant.  So, in the <literal>.data</literal> section, we should add:
</para>

<programlisting>
.equ CONVERSION_FACTOR, 'a' - 'A'
conversion_bytes:
	.fill 16, 1, CONVERSION_FACTOR
</programlisting>

<para>
And in the function before the loop, we need to add:
</para>

<programlisting>
	lqr $14, conversion_bytes
</programlisting>

<para>
With these additions, all values in register 7 will be processed appropriately.  Here is the code again, with a possible starting value to demonstrate what is happening:
</para>
	
<example>
<title>Following a set of values through the conversion</title>
<programlisting>
	#$7 starts with 'Hello There!    '
	#In hex, that's   0x48656c6c6f2054686572652120202020
	#$14 is the conversion factor in each byte
	#In hex, that's   0x20202020202020202020202020202020

	absdb $15, $7, $14
	#  -> $15 now has 0x28454c4c4f0034484552450100000000
	cgtbi $8, $7, 'a'-1
	#  -> $8 now has  0xffffffffff00ffffffffff0000000000
	cgtbi $9, $7, 'z'
	#  -> $9 now has  0xff0000000000ff000000000000000000
	xor $10, $8, $9
	#  -> $10 now has 0x00ffffffff0000ffffffff0000000000
	selb $7, $7, $15, $10
	#  -> $7 now has  0x48454c4c4f2054484552452120202020
	#     which is hex for 'HELLO THERE!    '
</programlisting>
</example>

<para>
So now, all we need to do is change the loop so that it will utilize this.  It needs to load a full quadword (16 bytes) at once, and store it back at once, and increment the pointer by 16 instead of 1.  This, interestingly, will require <emphasis>fewer</emphasis> instructions because we are no longer having to mess with the preferred slot.  So, here is the complete function with the new loop skeleton:
</para>

<example>
<title>Loop skeleton for vectorized code</title>
<programlisting>
##Store Conversion Factor##
.data
.equ CONVERSION_FACTOR, 'a' - 'A'
conversion_bytes:
	.fill 16, 1, CONVERSION_FACTOR

.text
.global convert_buffer_to_upper
.type convert_buffer_to_upper, @function
convert_buffer_to_upper:
	#Calculate end address
	a $5, $4, $3

	lqr $14, conversion_bytes

loop_start:
	#Aligned Load
	lqd $7, 0($3)

	##CONVERSION##
	absdb $15, $7, $14
	cgtbi $8, $7, 'a'-1
	cgtbi $9, $7, 'z'
	xor $10, $8, $9
	selb $7, $7, $15, $10
	##END CONVERSION##

	#Aligned Store
	stqd $7, 0($3)

	#Increment Pointer
	ai $3, $3, 16

	#Exit if needed ($5 has the ending address)
	cgt $13, $3, $5
	brz $13, loop_start

end_function:
	bi $lr
</programlisting>
</example>

<para>
As you can see, the code is much simpler - it has fewer branches and fewer instructions.  However, this new code now assumes that the starting address is 16-byte aligned, and also that it has enough padding on the end that the next data element in memory is also 16-byte aligned.  Otherwise, we might end up converting something besides letters!  As you can see, for vector processing, <emphasis>alignment and padding are both critically important</emphasis>.  If you wind up having to waste a few bytes, it is trivial compared to the amount of time and code needed to special-case the beginning and end of unaligned data.  By keeping keeping the data aligned and padded to 16-byte boundaries, vector operations can be performed effortlessly.
</para>

</sect1>

<sect1>
<title>Unrolling Loops and Scheduling Instructions</title>

<para>
Loop unrolling has been an optimization technique since the dawn of computer programming.  We will cover it here for two purposes:
</para>

<itemizedlist>
<listitem><para>Demonstrate how to unroll loops in assembly language and still keep track of which register holds what.</para></listitem>
<listitem><para>Use the unrolled loops to help understand and optimize instruction scheduling.</para></listitem>
</itemizedlist>

<para>
Probably by this point you have already been having trouble keeping up with which register holds what value.  After all, the register names are essentially arbitrary numbers, which are nearly impossible to make sense of.  However, because the registers are only numbers, we can use <literal>.equ</literal> to give our registers descriptive names.  For example, we can rewrite our conversion program as follows (note that registers have been renumbered):
</para>

<example>
<title>Uppercase conversion with named registers</title>
<programlisting>
.data
.equ CONVERSION_FACTOR, 'a' - 'A'
conversion_bytes:
	.fill 16, 1, CONVERSION_FACTOR

.text
.global convert_buffer_to_upper
.type convert_buffer_to_upper, @function
	##REGISTER DEFINITIONS##
	#Loop/function control registers
	.equ BUFFER_REG, 3             #Buffer address / current address
	.equ BUFFER_SZ_REG, 4          #Buffer size
	.equ BUFFER_END_REG, 5         #End address
	.equ CONVERSION_BYTES_REG, 6   #Conversion data
	.equ IS_FINISHED_REG, 7        #Finished conversion?

	#Conversion-oriented registers
	.equ CURRENT_VAL_REG, 8  #Current quadword
	.equ BOOL_TMP1_REG, 9    #used for computing IN_RANGE_REG
	.equ BOOL_TMP2_REG, 10   #used for computing IN_RANGE_REG
	.equ IN_RANGE_REG, 11    #Value in range?
	.equ PROCESSED_VALS_REG, 12   #Conversion bytes, properly masked

	#Other information
	.equ NUMREGS, 5          #Number of per-iteration registers
	.equ REGBYTES, 16        #Number of bytes in a register
convert_buffer_to_upper:
	#Calculate end address
	a $BUFFER_END_REG, $BUFFER_SZ_REG, $BUFFER_REG

	lqr $CONVERSION_BYTES_REG, conversion_bytes

loop_start:
	#Aligned Load
	lqd $CURRENT_VAL_REG, 0($BUFFER_REG)

	##CONVERSION##
	absdb $PROCESSED_VALS_REG, $CURRENT_VAL_REG, $CONVERSION_BYTES_REG
	cgtbi $BOOL_TMP1_REG, $CURRENT_VAL_REG, 'a'-1
	cgtbi $BOOL_TMP2_REG, $CURRENT_VAL_REG, 'z'
	xor $IN_RANGE_REG, $BOOL_TMP1_REG, $BOOL_TMP2_REG
	selb $CURRENT_VAL_REG, $CURRENT_VAL_REG, $PROCESSED_VALS_REG, $IN_RANGE_REG
	##END CONVERSION##

	#Aligned Store
	stqd $CURRENT_VAL_REG, 0($BUFFER_REG)

	#Increment Pointer
	ai $BUFFER_REG, $BUFFER_REG, REGBYTES

	#Exit if needed
	cgt $IS_FINISHED_REG, $BUFFER_REG, $BUFFER_END_REG
	brz $IS_FINISHED_REG, loop_start

end_function:
	bi $lr
</programlisting>
</example>

<para>
It's a lot more verbose, but it also makes it easier to browse through the code.  It also makes it much easier to do instruction scheduling for unrolled loops.  We'll get to that in a minute.  For the present, let's look at how we might unroll this loop four times, using different registers for each iteration (using different registers will help when we optimize instruction scheduling).

NOTE -- I'm HERE

<example>
<title>Buffer Conversion -- Loop Unrolled</title>
<programlisting>
.data 
.equ CONVERSION, 'a' - 'A'
.align 4
conversion_bytes:
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
	.byte CONVERSION
		
.text

.global convert_buffer_to_upper
.type convert_buffer_to_upper, @function
convert_buffer_to_upper:
	##REGISTER USAGE:
	###Global Regs
	.equ BUFFER_REG, 3             #Buffer address / current address
	.equ BUFFER_SZ_REG, 4          #Buffer size
	.equ BUFFER_END_REG, 5         #End address
	.equ CONVERSION_BYTES_REG, 6   #Conversion data
	.equ NEED_FINISH_REG, 7        #Finished conversion?

	###Per-Iteration Regs
	.equ CURRENT_VAL_REG, 8  #Current quadword
	.equ BOOL_TMP1_REG, 9
	.equ BOOL_TMP2_REG, 10
	.equ IN_RANGE_REG, 11    #Value in range?
	.equ CONV_REG, 12        #Conversion bytes, properly masked
	.equ NUMREGS, 5          #Number of per-iteration registers

	.equ REGBYTES, 16        #Number of bytes in a register

	#Calculate end address
	a $BUFFER_END_REG, $BUFFER_SZ_REG, $BUFFER_REG
	#Load conversion bytes
	lqr $CONVERSION_BYTES_REG, conversion_bytes
	
loop_start:
	####ITERATION 0####
	lqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
	cgtbi $(BOOL_TMP1_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'a' - 1
	cgtbi $(BOOL_TMP2_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'z'
	xor $(IN_RANGE_REG+0*NUMREGS), $(BOOL_TMP1_REG+0*NUMREGS), $(BOOL_TMP2_REG+0*NUMREGS)
	and $(CONV_REG+0*NUMREGS), $(IN_RANGE_REG+0*NUMREGS), $CONVERSION_BYTES_REG
	absdb $(CURRENT_VAL_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), $(CONV_REG+0*NUMREGS)
	stqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)

	####ITERATION 1####
	lqd $(CURRENT_VAL_REG+1*NUMREGS), 1*REGBYTES($BUFFER_REG)
	cgtbi $(BOOL_TMP1_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), 'a' - 1
	cgtbi $(BOOL_TMP2_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), 'z'
	xor $(IN_RANGE_REG+1*NUMREGS), $(BOOL_TMP1_REG+1*NUMREGS), $(BOOL_TMP2_REG+1*NUMREGS)
	and $(CONV_REG+1*NUMREGS), $(IN_RANGE_REG+1*NUMREGS), $CONVERSION_BYTES_REG
	absdb $(CURRENT_VAL_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), $(CONV_REG+1*NUMREGS)
	stqd $(CURRENT_VAL_REG+1*NUMREGS), 1*REGBYTES($BUFFER_REG)

	####ITERATION 2####
	lqd $(CURRENT_VAL_REG+2*NUMREGS), 2*REGBYTES($BUFFER_REG)
	cgtbi $(BOOL_TMP1_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), 'a' - 1
	cgtbi $(BOOL_TMP2_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), 'z'
	xor $(IN_RANGE_REG+2*NUMREGS), $(BOOL_TMP1_REG+2*NUMREGS), $(BOOL_TMP2_REG+2*NUMREGS)
	and $(CONV_REG+2*NUMREGS), $(IN_RANGE_REG+2*NUMREGS), $CONVERSION_BYTES_REG
	absdb $(CURRENT_VAL_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), $(CONV_REG+2*NUMREGS)
	stqd $(CURRENT_VAL_REG+2*NUMREGS), 2*REGBYTES($BUFFER_REG)

	####ITERATION 3####
	lqd $(CURRENT_VAL_REG+3*NUMREGS), 3*REGBYTES($BUFFER_REG)
	cgtbi $(BOOL_TMP1_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), 'a' - 1
	cgtbi $(BOOL_TMP2_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), 'z'
	xor $(IN_RANGE_REG+3*NUMREGS), $(BOOL_TMP1_REG+3*NUMREGS), $(BOOL_TMP2_REG+3*NUMREGS)
	and $(CONV_REG+3*NUMREGS), $(IN_RANGE_REG+3*NUMREGS), $CONVERSION_BYTES_REG
	absdb $(CURRENT_VAL_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), $(CONV_REG+3*NUMREGS)
	stqd $(CURRENT_VAL_REG+3*NUMREGS), 3*REGBYTES($BUFFER_REG)

	#Increment pointer
	ai $BUFFER_REG, $BUFFER_REG, 4*REGBYTES

	#Exit if needed
	cgt $13, $3, $5
	brnz $13, end_function

	#end loop
	br loop_start

end_function:
	bi $lr
</programlisting>
</example>

<!-- page 687-688 BE Handbook -->
<!-- 18 clock cycles per QWORD, 0 dual-issues, ~1.125 cycles per conversion -->
<example>
<title>Loop Body -- Annotated Scheduling Info</title>
<programlisting>
	####ITERATION 0####
	nop
	lqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
	#stall (waiting on CURRENT_VAL_REG to load)
	#stall
	#stall
	#stall
	#stall
	cgtbi $(BOOL_TMP1_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP2_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'z'
	lnop
	#stall (waiting on BOOL_TMP2_REG)
	xor $(IN_RANGE_REG+0*NUMREGS), $(BOOL_TMP1_REG+0*NUMREGS), $(BOOL_TMP2_REG+0*NUMREGS)
	lnop
	#stall (waiting on IN_RANGE_REG)
	and $(CONV_REG+0*NUMREGS), $(IN_RANGE_REG+0*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	#stall (waiting on CONV_REG)
	absdb $(CURRENT_VAL_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), $(CONV_REG+0*NUMREGS)
	lnop
	#stall (waiting on CURRENT_VAL_REG)
	#stall
	#stall
	nop
	stqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
</programlisting>
</example>


<!-- 30 cycles (7.5 cycles / QWORD), 64 bytes processed, 1 dual-issue (~0.47 clock cycles per conversion) -->
<!-- needs .align 2 -->
<example>
<title>Main Loop Interleaved for Scheduling</title>
<programlisting>
	.align 2
	nop
	lqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
	nop
	lqd $(CURRENT_VAL_REG+1*NUMREGS), 1*REGBYTES($BUFFER_REG)
	nop
	lqd $(CURRENT_VAL_REG+2*NUMREGS), 2*REGBYTES($BUFFER_REG)
	nop
	lqd $(CURRENT_VAL_REG+3*NUMREGS), 3*REGBYTES($BUFFER_REG)
	#stall (waiting on CURRENT_VAL_REG to load)
	#stall
	cgtbi $(BOOL_TMP1_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP1_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP1_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP1_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), 'a' - 1
	lnop
	cgtbi $(BOOL_TMP2_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), 'z'
	lnop
	cgtbi $(BOOL_TMP2_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), 'z'
	lnop
	cgtbi $(BOOL_TMP2_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), 'z'
	lnop
	cgtbi $(BOOL_TMP2_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), 'z'
	lnop
	xor $(IN_RANGE_REG+0*NUMREGS), $(BOOL_TMP1_REG+0*NUMREGS), $(BOOL_TMP2_REG+0*NUMREGS)
	lnop
	xor $(IN_RANGE_REG+1*NUMREGS), $(BOOL_TMP1_REG+1*NUMREGS), $(BOOL_TMP2_REG+1*NUMREGS)
	lnop
	xor $(IN_RANGE_REG+2*NUMREGS), $(BOOL_TMP1_REG+2*NUMREGS), $(BOOL_TMP2_REG+2*NUMREGS)
	lnop
	xor $(IN_RANGE_REG+3*NUMREGS), $(BOOL_TMP1_REG+3*NUMREGS), $(BOOL_TMP2_REG+3*NUMREGS)
	lnop
	and $(CONV_REG+0*NUMREGS), $(IN_RANGE_REG+0*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	and $(CONV_REG+1*NUMREGS), $(IN_RANGE_REG+1*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	and $(CONV_REG+2*NUMREGS), $(IN_RANGE_REG+2*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	and $(CONV_REG+3*NUMREGS), $(IN_RANGE_REG+3*NUMREGS), $CONVERSION_BYTES_REG
	lnop
	absdb $(CURRENT_VAL_REG+0*NUMREGS), $(CURRENT_VAL_REG+0*NUMREGS), $(CONV_REG+0*NUMREGS) 
	lnop
	absdb $(CURRENT_VAL_REG+1*NUMREGS), $(CURRENT_VAL_REG+1*NUMREGS), $(CONV_REG+1*NUMREGS) 
	lnop
	absdb $(CURRENT_VAL_REG+2*NUMREGS), $(CURRENT_VAL_REG+2*NUMREGS), $(CONV_REG+2*NUMREGS)
	lnop 
	absdb $(CURRENT_VAL_REG+3*NUMREGS), $(CURRENT_VAL_REG+3*NUMREGS), $(CONV_REG+3*NUMREGS)
	lnop
	nop
	stqd $(CURRENT_VAL_REG+0*NUMREGS), 0*REGBYTES($BUFFER_REG)
	nop
	stqd $(CURRENT_VAL_REG+1*NUMREGS), 1*REGBYTES($BUFFER_REG)
	nop
	stqd $(CURRENT_VAL_REG+2*NUMREGS), 2*REGBYTES($BUFFER_REG)
	nop
	stqd $(CURRENT_VAL_REG+3*NUMREGS), 3*REGBYTES($BUFFER_REG)
</programlisting>
</example>

<!-- branch hints -->
<!-- optimize function call and return -->

<example>
<title>Multibuffering the Main Function</title>
<programlisting>
.data

.align 4
conversion_info:
conversion_length:
	.octa 0
conversion_data:
	.octa 0
.equ CONVERSION_STRUCT_SIZE, 32

.section .bss #Uninitialized Data Section
.align 4
.lcomm conversion_buffer_1, 16384
.lcomm conversion_buffer_2, 16384

.equ CONVERSION_TRANSFER_SIZE, 128
.text

#MFC Constants
.equ MFC_GETB_CMD, 0x41
.equ MFC_PUTB_CMD, 0x21

.equ LR_OFFSET, 16

.global main
.type main, @function
.equ MAIN_FRAME_SIZE, 64
.equ REGSAVE_OFFSET, 32

#Name our registers
	.equ PARAM_1, 3
	.equ PARAM_2, 4
	.equ PARAM_3, 5
	.equ PARAM_4, 6
	.equ PARAM_5, 7

	.equ TMP_1, 8
	.equ TMP_SZ_NEXT_XFER, 9
	.equ TMP_SZ_NEXT_XFER_64, 10

	.equ DATA_REMAINING, 127
	.equ CURRENT_PTR, 126
	.equ BUF1_EA, 125
	.equ BUF1_SIZE, 124	
	.equ BUF2_EA, 123
	.equ BUF2_SIZE, 122
	.equ TRANSFER_SIZE, 121
main:
	#Prologue
	stqd $lr, LR_OFFSET($sp)
	stqd $sp, -MAIN_FRAME_SIZE($sp)
	ai $sp, $sp, -MAIN_FRAME_SIZE

	il $TRANSFER_SIZE, CONVERSION_TRANSFER_SIZE

	##COPY IN CONVERSION INFORMATION##
	ila $PARAM_1, conversion_info         #Local Store Address
	#register 4 already has address #64-bit Effective Address
	il $PARAM_3, CONVERSION_STRUCT_SIZE   #Transfer size
	il $PARAM_4, 0                        #DMA Tag
	il $PARAM_5, MFC_GETB_CMD              #DMA Command
	brsl $lr, perform_dma

conversion_loop:
	
	#Wait for DMA to complete
	il $PARAM_1, 0
	brsl $lr, wait_for_dma_completion

	lqr $DATA_REMAINING, conversion_length
	lqr $CURRENT_PTR, conversion_data

	#Is there a full transfer left?
	cgt $TMP_1, $TRANSFER_SIZE, $DATA_REMAINING
	selb $TMP_SZ_NEXT_XFER, $TRANSFER_SIZE, $DATA_REMAINING, $TMP_1
	
	#Save Buffer 1 Info
	lr $BUF1_EA, $CURRENT_PTR
	lr $BUF1_SIZE, $TMP_SZ_NEXT_XFER

	#Move Pointer and size
	sf $DATA_REMAINING, $DATA_REMAINING, $TMP_SZ_NEXT_XFER
	#MISMATCH!!! 64-bit and 32-bit
	a $CURRENT_PTR, $CURRENT_PTR, $TMP_SZ_NEXT_XFER

	#Start Copy Buffer 1
	ila $PARAM_1, conversion_buffer_1 #Local Store
	lr $PARAM_2, $BUF1_EA             #64-bit Effective Address
	lr $PARAM_3, $BUF1_SIZE           #SIZE
	il $PARAM_4, 0                    #DMA Tag
	il $PARAM_5, MFC_GETB_CMD          #DMA Command
	brsl $lr, perform_dma

	#Is there a full transfer left?
	cgt $TMP_1, $TRANSFER_SIZE, $DATA_REMAINING
	selb $TMP_SZ_NEXT_XFER, $TRANSFER_SIZE, $DATA_REMAINING, $TMP_1

	#Save Buffer 2 Info
	lr $BUF2_EA, $CURRENT_PTR
	lr $BUF2_SIZE, $TMP_SZ_NEXT_XFER

	#Move pointer and size
	sf $DATA_REMAINING, $DATA_REMAINING, $TMP_SZ_NEXT_XFER
	#MISMATCH!!! 64-bit and 32-bit
	a $CURRENT_PTR, $CURRENT_PTR, $TMP_SZ_NEXT_XFER

	#Start Copy Buffer 2
	ila $PARAM_1, conversion_buffer_2 #Local Store
	lr $PARAM_2, $BUF2_EA             #64-bit Effective Address
	lr $PARAM_3, $BUF2_SIZE           #SIZE
	il $PARAM_4, 1                    #DMA Tag
	il $PARAM_5, MFC_GETB_CMD          #DMA Command
	brsl $lr, perform_dma
	
	#Wait for First DMA to complete
	il $PARAM_1, 0
	brsl $lr, wait_for_dma_completion

	#Perform Conversion on buffer 1
	ila $PARAM_1, conversion_buffer_1
	lr $PARAM_2, $BUF1_SIZE
	brsl $lr, convert_buffer_to_upper

	#Start Copy Data Back on Buffer 1
	ila $PARAM_1, conversion_buffer_1   #Local Store Address
	lr $PARAM_2, $BUF1_EA     #64-bit effective address
	lr $PARAM_3, $BUF1_SIZE   #Size
	il $PARAM_4, 0                    #DMA Tag
	il $PARAM_5, MFC_PUTB_CMD          #DMA Command
	brsl $lr, perform_dma

	#Queue Up Next Copy on Buffer 1
	#Is there a full transfer left?
	cgt $TMP_1, $TRANSFER_SIZE, $DATA_REMAINING
	selb $TMP_SZ_NEXT_XFER, $TRANSFER_SIZE, $DATA_REMAINING, $TMP_1
	
	#Save Buffer 1 Info
	lr $BUF1_EA, $CURRENT_PTR
	lr $BUF1_SIZE, $TMP_SZ_NEXT_XFER

	#Move Pointer and size
	sf $DATA_REMAINING, $DATA_REMAINING, $TMP_SZ_NEXT_XFER
	#MISMATCH!!!
	a $CURRENT_PTR, $CURRENT_PTR, $TMP_SZ_NEXT_XFER

	#Start Copy Buffer 1
	ila $PARAM_1, conversion_buffer_1 #Local Store
	lr $PARAM_2, $BUF1_EA             #64-bit Effective Address
	lr $PARAM_3, $BUF1_SIZE           #SIZE
	il $PARAM_4, 0                    #DMA Tag
	il $PARAM_5, MFC_GETB_CMD          #DMA Command
	brsl $lr, perform_dma


	#Wait for Data on Buffer 2
	il $PARAM_1, 1
	brsl $lr, wait_for_dma_completion

	#Perform Conversion on Buffer 2
	ila $PARAM_1, conversion_buffer_2
	lr $PARAM_2, $BUF2_SIZE
	brsl $lr, convert_buffer_to_upper

	#Start Copy Data Back on Buffer 2
	ila $PARAM_1, conversion_buffer_2
	lr $PARAM_2, BUF2_EA
	lr $PARAM_3, BUF2_SIZE
	il $PARAM_4, 1
	il $PARAM_5, MFC_PUTB_CMD
	brsl $lr, perform_dma

	#Queue Up Next Copy on Buffer 2
	#Is there a full transfer left?
	cgt $TMP_1, $TRANSFER_SIZE, $DATA_REMAINING
	selb $TMP_SZ_NEXT_XFER, $TRANSFER_SIZE, $DATA_REMAINING, $TMP_1
	
	#Save Buffer 2 Info
	lr $BUF2_EA, $CURRENT_PTR
	lr $BUF2_SIZE, $TMP_SZ_NEXT_XFER

	#Move Pointer and size
	sf $DATA_REMAINING, $DATA_REMAINING, $TMP_SZ_NEXT_XFER
	##MISMATCH!!!
	a $CURRENT_PTR, $CURRENT_PTR, $TMP_SZ_NEXT_XFER

	#Start Copy Buffer 2
	ila $PARAM_1, conversion_buffer_2 #Local Store
	lr $PARAM_2, $BUF2_EA             #64-bit Effective Address
	lr $PARAM_3, $BUF2_SIZE           #SIZE
	il $PARAM_4, 0                    #DMA Tag
	il $PARAM_5, MFC_GETB_CMD          #DMA Command
	brsl $lr, perform_dma
	
	#Branch if there is data remaining
	# (FIXME -- should skip some steps if $DATA_REMAINING is 0)
	# (FIXME -- should do branch hints to help out the loop)
	brnz  $DATA_REMAINING, conversion_loop

main_end:

	#Return Value
	il $3, 0

	#Epilogue
	ai $sp, $sp, MAIN_FRAME_SIZE
	lqd $lr, LR_OFFSET($sp)
	bi $lr
</programlisting>
</example>